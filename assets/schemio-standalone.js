/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 9669:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(1609);

/***/ }),

/***/ 5448:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);
var settle = __webpack_require__(6026);
var cookies = __webpack_require__(4372);
var buildURL = __webpack_require__(5327);
var buildFullPath = __webpack_require__(4097);
var parseHeaders = __webpack_require__(4109);
var isURLSameOrigin = __webpack_require__(7985);
var createError = __webpack_require__(5061);
var defaults = __webpack_require__(5655);
var Cancel = __webpack_require__(5263);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      var transitional = config.transitional || defaults.transitional;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ 1609:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);
var bind = __webpack_require__(1849);
var Axios = __webpack_require__(321);
var mergeConfig = __webpack_require__(7185);
var defaults = __webpack_require__(5655);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(5263);
axios.CancelToken = __webpack_require__(4972);
axios.isCancel = __webpack_require__(6502);
axios.VERSION = (__webpack_require__(7288).version);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(8713);

// Expose isAxiosError
axios.isAxiosError = __webpack_require__(6268);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports["default"] = axios;


/***/ }),

/***/ 5263:
/***/ ((module) => {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ 4972:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var Cancel = __webpack_require__(5263);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ 6502:
/***/ ((module) => {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ 321:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);
var buildURL = __webpack_require__(5327);
var InterceptorManager = __webpack_require__(782);
var dispatchRequest = __webpack_require__(3572);
var mergeConfig = __webpack_require__(7185);
var validator = __webpack_require__(4875);

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ 782:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ 4097:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isAbsoluteURL = __webpack_require__(1793);
var combineURLs = __webpack_require__(7303);

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ 5061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var enhanceError = __webpack_require__(481);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ 3572:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);
var transformData = __webpack_require__(8527);
var isCancel = __webpack_require__(6502);
var defaults = __webpack_require__(5655);
var Cancel = __webpack_require__(5263);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new Cancel('canceled');
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ 481:
/***/ ((module) => {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  };
  return error;
};


/***/ }),

/***/ 7185:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};


/***/ }),

/***/ 6026:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var createError = __webpack_require__(5061);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ 8527:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);
var defaults = __webpack_require__(5655);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};


/***/ }),

/***/ 5655:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);
var normalizeHeaderName = __webpack_require__(6016);
var enhanceError = __webpack_require__(481);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(5448);
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(5448);
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;


/***/ }),

/***/ 7288:
/***/ ((module) => {

module.exports = {
  "version": "0.22.0"
};

/***/ }),

/***/ 1849:
/***/ ((module) => {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ 5327:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ 7303:
/***/ ((module) => {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ 4372:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ 1793:
/***/ ((module) => {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ 6268:
/***/ ((module) => {

"use strict";


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};


/***/ }),

/***/ 7985:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ 6016:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ 4109:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(4867);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ 8713:
/***/ ((module) => {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ 4875:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var VERSION = (__webpack_require__(7288).version);

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};


/***/ }),

/***/ 4867:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(1849);

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};


/***/ }),

/***/ 2643:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "I": () => (/* binding */ enrichObjectWithDefaults)
/* harmony export */ });
/* unused harmony export defaultifyObject */
/* harmony import */ var _ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4691);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

/**
 * Performs a deep scan and returns object without fields that are exactly the same as in default object
 * @param {Object} obj object that is supposed to be cleaned up
 * @param {Object} defaultObject an object representing the default object with default fields
 * @returns {Object} object with removed default fields
 */

function defaultifyObject(obj, defaultObject) {
  if (!obj) {
    return null;
  }

  const resultingObject = {};
  let completeMatch = true;

  for (let field in obj) {
    if (obj.hasOwnProperty(field)) {
      let shouldCopy = true;
      let subDefObj = undefined;

      if (defaultObject.hasOwnProperty('*')) {
        // this means that all fields of the object should be checked
        // this is going to be applied for item.textSlots
        subDefObj = defaultObject['*'];
      } else if (defaultObject.hasOwnProperty(field)) {
        subDefObj = defaultObject[field];
      }

      if (typeof subDefObj !== 'undefined') {
        if (typeof obj[field] === typeof subDefObj) {
          if (Array.isArray(obj[field])) {
            resultingObject[field] = [];

            if (Array.isArray(subDefObj) && subDefObj.length === 1) {
              if (obj[field].length > 0) {
                // if there is at least one item in array - we should not let it be removed completelly 
                completeMatch = false;
              }

              for (let i = 0; i < obj[field].length; i++) {
                const nestedResult = defaultifyObject(obj[field][i], subDefObj[0]);

                if (typeof nestedResult !== 'undefined') {
                  resultingObject[field][i] = nestedResult;
                } else {
                  resultingObject[field][i] = {};
                }
              }

              shouldCopy = false;
            } else {
              shouldCopy = true;
            }
          } else if (typeof obj[field] === 'object') {
            const nestedResult = defaultifyObject(obj[field], subDefObj);

            if (typeof nestedResult !== 'undefined') {
              resultingObject[field] = nestedResult;
              shouldCopy = false;
              completeMatch = false;
            } else {
              shouldCopy = false;
            }
          } else if (obj[field] === subDefObj) {
            shouldCopy = false;
          }
        }
      }

      if (shouldCopy) {
        resultingObject[field] = obj[field];
        completeMatch = false;
      }
    }
  }

  if (completeMatch) {
    return undefined;
  }

  return resultingObject;
}
/**
 * Enriches object with defaults specified in another object.
 * It uses the same structure as 'defaultifyObject' function
 * @param {*} obj 
 * @param {*} defaultObj 
 */

function enrichObjectWithDefaults(obj, defaultObj) {
  for (let field in defaultObj) {
    if (defaultObj.hasOwnProperty(field)) {
      if (field === '*') {
        for (let objField in obj) {
          enrichObjectWithDefaults(obj[objField], defaultObj['*']);
        }
      } else {
        const subDefObj = defaultObj[field];

        if (!obj.hasOwnProperty(field) || obj[field] === null || typeof obj[field] !== typeof subDefObj || Array.isArray(subDefObj) && !Array.isArray(obj[field])) {
          // in case they have different types - we should correct the object, otherwise it will be in broken state
          if (Array.isArray(subDefObj)) {
            obj[field] = [];
          } else {
            obj[field] = _ui_utils__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clone */ .Z.clone(subDefObj);
          }
        } else {
          if (typeof subDefObj === 'object' && !Array.isArray(subDefObj)) {
            enrichObjectWithDefaults(obj[field], subDefObj);
          } else if (Array.isArray(subDefObj) && subDefObj.length === 1) {
            for (let i = 0; i < obj[field].length; i++) {
              // enriching each array element
              enrichObjectWithDefaults(obj[field][i], subDefObj[0]);
            }
          }
        }
      }
    }
  }

  return obj;
}

/***/ }),

/***/ 3762:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const sanitizeHtml = __webpack_require__(1036);

module.exports = function (html) {
  return sanitizeHtml(html, {
    allowedTags: ['blockquote', 'code', 'div', 'em', 'li', 'ol', 'p', 'strong', 'b', 's', 'i', 'u', 'ul', 'img', 'a', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
    allowedAttributes: {
      'a': ['href'],
      'img': ['src']
    }
  });
};

/***/ }),

/***/ 2217:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ Animation)
/* harmony export */ });
/* harmony import */ var shortid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4670);
/* harmony import */ var shortid__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shortid__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4486);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_1__);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


class Animation {
  constructor() {
    this.enabled = true;
    this.entityId = null;
    this.id = shortid__WEBPACK_IMPORTED_MODULE_0___default().generate();
  }
  /**
   * Invoked before playing. 
   * @returns Boolean status whether it has succeeded initializing animation elements
   */


  init() {
    return true;
  }
  /**
   * Function that is invoked on each frame.
   * In case it returns false - it means that animation has finished and it will invoke destroy function
   * @param {Number} dt delta time between frames of animation
   * @returns Boolean status that specifies whether animation should proceed. 
   */


  play(dt) {
    return false;
  }
  /**
   * Invoked when animation is instructed to remove its elements from dom.
   */


  destroy() {}

  svg(name, args, childElements) {
    const element = document.createElementNS('http://www.w3.org/2000/svg', name);

    this._enrichDomElement(element, args, childElements);

    return element;
  }

  html(name, args, childElements) {
    const element = document.createElement(name);

    this._enrichDomElement(element, args, childElements);

    return element;
  }

  _enrichDomElement(element, args, childElements) {
    if (args) {
      lodash_forEach__WEBPACK_IMPORTED_MODULE_1___default()(args, (value, argName) => {
        element.setAttribute(argName, value);
      });
    }

    if (childElements) {
      lodash_forEach__WEBPACK_IMPORTED_MODULE_1___default()(childElements, childElement => {
        element.appendChild(childElement);
      });
    }
  }

  stop() {
    this.enabled = false;
  }

}

/***/ }),

/***/ 9737:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4486);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_0__);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
 // desired delta time between loop cycles in milliseconds

const DESIRED_DELTA_TIME = 16;
let animationsEnabled = true;
let isAlreadyLooping = false;
const animations = [];

function loopCycle(timeMarker, deltaTime) {
  if (animations.length === 0) {
    // stopping the empty loop as it does not make sense since there are no animations
    isAlreadyLooping = false;
    return;
  }

  if (animationsEnabled) {
    let i = 0;

    while (i < animations.length) {
      let animation = animations[i];
      let status = true;

      try {
        if (animation.enabled) {
          status = animation.play(deltaTime);
        } else {
          status = false;
        }
      } catch (e) {
        status = false;
        console.error(e);
      }

      if (!status) {
        try {
          animation.destroy();
        } catch (e) {
          console.error(e);
        }

        animations.splice(i, 1);
      } else {
        i += 1;
      }
    }

    window.requestAnimationFrame(() => {
      const nextTimeMarker = performance.now();
      loopCycle(nextTimeMarker, nextTimeMarker - timeMarker);
    });
  } else {
    isAlreadyLooping = false;
  }
}

function startAnimationLoop() {
  if (animationsEnabled && !isAlreadyLooping) {
    isAlreadyLooping = true;
    window.requestAnimationFrame(() => loopCycle(performance.now(), DESIRED_DELTA_TIME));
  }
}

function stopSimilarAnimationForItem(entityId, animationId) {
  lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(animations, animation => {
    if (animation.entityId === entityId && animation.animationId === animationId) {
      animation.enabled = false;
    }
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   *
   * @param {Animation} animation
   * @param {String} entityId Id of an item. It is needed in order to be able to stop all animations for a specific item
   * @param {String} animationId Id of animation. It is used to avoid race conditions when same animations are played in parallel for the same item
   */
  play(animation, entityId, animationId) {
    // checking whether such animation already exists
    // this can be a case for frame player
    // instead of linear search this could be optimized by using a map of animation ids
    // but I don't think we are going to be using that many animations at the same time,
    // so it's fine like this for now
    for (let i = 0; i < animations.length; i++) {
      if (animations[i].id === animation.id) {
        animations.enabled = false;
        animations.splice(i, 1);
        break;
      }
    }

    animation.entityId = entityId;
    animation.animationId = animationId;

    if (animationId) {
      stopSimilarAnimationForItem(entityId, animationId);
    }

    let success = false;

    try {
      animation.enabled = true;
      success = animation.init();
    } catch (e) {
      console.error('Could not initialize animation', e);
    }

    if (success) {
      animations.push(animation);
      startAnimationLoop();
    } else {
      animation.destroy();
    }
  },

  stopAllAnimations() {
    const animations = this.animations;
    this.animations = [];
    lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(animations, animation => {
      animation.destroy();
    });
  },

  disableAnimations() {
    animationsEnabled = false;
  },

  enableAnimations() {
    animationsEnabled = true;
  },

  stopAllAnimationsForEntity(entityId) {
    lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(animations, animation => {
      if (animation.entityId === entityId) {
        animation.enabled = false;
      }
    });
  }

});

/***/ }),

/***/ 3805:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "jU": () => (/* binding */ Interpolations),
/* harmony export */   "rJ": () => (/* binding */ convertTime),
/* harmony export */   "ZP": () => (/* binding */ ValueAnimation)
/* harmony export */ });
/* harmony import */ var _Animation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2217);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

const Interpolations = {
  LINEAR: 'linear',
  STEP: 'step',
  SMOOTH: 'smooth',
  // ease in and out
  EASE_IN: 'ease-in',
  EASE_OUT: 'ease-out',
  EASE_IN_OUT: 'ease-in-out',
  BOUNCE: 'bounce',

  values() {
    return [this.LINEAR, this.STEP, this.SMOOTH, this.EASE_IN, this.EASE_OUT, this.EASE_IN_OUT, this.BOUNCE];
  }

};
/**
 * This fuction converts t according to movement type. This is needed in order to get smooth animation or any other effect.
 * @param {Float} t - time of animation in ratio to animation length (from 0.0 to 1.0)
 * @param {String} type - type of animation (e.g. "linear", "ease-in" etc.)
 */

function convertTime(t, type) {
  if (type === Interpolations.SMOOTH) {
    return Math.sin(t * Math.PI / 2.0);
  } else if (type === Interpolations.EASE_IN) {
    return t * t;
  } else if (type === Interpolations.EASE_OUT) {
    return 1 - (t - 1) * (t - 1);
  } else if (type === Interpolations.EASE_IN_OUT) {
    return 0.5 - Math.cos(t * Math.PI) / 2;
  } else if (type === 'bounce') {
    return 1 - Math.pow(3, -10 * t) * Math.cos(10 * Math.PI * t);
  }

  return t;
}
class ValueAnimation extends _Animation__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z {
  constructor(settings) {
    super();
    this.updateCallback = null;
    this.durationMillis = 1000;
    this.elapsedTime = 0;
    this.initCallback = null;
    this.destroyCallback = null;
    this.animationType = 'ease-out';

    if (settings) {
      if (settings.durationMillis) {
        this.durationMillis = settings.durationMillis;
      }

      if (settings.update) {
        this.updateCallback = settings.update;
      }

      if (settings.init) {
        this.initCallback = settings.init;
      }

      if (settings.destroy) {
        this.destroyCallback = settings.destroy;
      }

      if (settings.animationType) {
        this.animationType = settings.animationType;
      }
    }
  }

  init() {
    if (!this.updateCallback) {
      return false;
    }

    if (this.initCallback) {
      this.initCallback();
    }

    return true;
  }

  play(dt) {
    this.elapsedTime += dt;

    if (this.elapsedTime >= this.durationMillis) {
      this.updateCallback(1.0);
      return false;
    }

    const t = this.elapsedTime / this.durationMillis;
    this.updateCallback(convertTime(t, this.animationType));
    return true;
  }

  destroy() {
    if (this.destroyCallback) {
      this.destroyCallback();
    }
  }

}

/***/ }),

/***/ 3277:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_editor_EventBus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(536);
/* harmony import */ var _components_editor_items_shapes_Shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3363);
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3590);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'Move along path',
  args: {
    item: {
      name: 'Item',
      type: 'element',
      value: null
    },
    path: {
      name: 'Path',
      type: 'element',
      value: null
    },
    rotateItem: {
      name: 'Rotate item',
      type: 'boolean',
      value: false,
      description: 'Adjust rotation of the item to path'
    },
    rotationOffset: {
      name: 'Rotation offset',
      type: 'number',
      value: 0,
      description: 'Rotation angle offset',
      depends: {
        rotateItem: true
      }
    }
  },
  // the following fields are going to be used in animation tracks
  inputs: {
    distance: {
      name: 'Distance (%)',
      type: 'number',
      value: 0,
      endValue: 100
    }
  },

  // this function is supposed to prepare object that would be passed into execute function
  // if null is returned then the function preparation was not successfull
  create(args, schemeContainer) {
    const item = schemeContainer.findFirstElementBySelector(args.item);

    if (!item) {
      return null;
    }

    const pathItem = schemeContainer.findFirstElementBySelector(args.path);

    if (!pathItem) {
      return null;
    }

    const shape = _components_editor_items_shapes_Shape__WEBPACK_IMPORTED_MODULE_1__/* ["default"].find */ .Z.find(pathItem.shape);

    if (!shape) {
      return null;
    }

    const path = schemeContainer.getSvgOutlineOfItem(pathItem);

    if (!path) {
      return null;
    }

    return {
      path,
      item,
      pathItem,
      schemeContainer,
      totalLength: path.getTotalLength(),
      rotateItem: args.rotateItem,
      rotationOffset: args.rotationOffset
    };
  },

  getFullName(args, schemeContainer) {
    const nameOfItem = selector => {
      const item = schemeContainer.findFirstElementBySelector(selector);

      if (item) {
        return item.name;
      }

      return 'unknown';
    };

    const itemName = nameOfItem(args.item);
    const pathItemName = nameOfItem(args.path);
    return `Move "${itemName}" along the path of "${pathItemName}"`;
  },

  // the first argument is the object returned by the "create" function
  // the second argument is an object containing the inputs
  execute({
    path,
    item,
    pathItem,
    schemeContainer,
    totalLength,
    rotateItem,
    rotationOffset
  }, {
    distance
  }) {
    const length = distance * totalLength / 100;
    const point = path.getPointAtLength(length);
    let worldPoint = schemeContainer.worldPointOnItem(point.x, point.y, pathItem);

    if (rotateItem) {
      const nextPoint = path.getPointAtLength(length + 2);
      const worldNextPoint = schemeContainer.worldPointOnItem(nextPoint.x, nextPoint.y, pathItem);
      const Vx = worldNextPoint.x - worldPoint.x;
      const Vy = worldNextPoint.y - worldPoint.y;
      const dSquared = Vx * Vx + Vy * Vy;

      if (!_myMath__WEBPACK_IMPORTED_MODULE_2__/* ["default"].tooSmall */ .Z.tooSmall(dSquared)) {
        const d = Math.sqrt(dSquared);
        const vx = Vx / d;
        const vy = Vy / d;
        const angle = _myMath__WEBPACK_IMPORTED_MODULE_2__/* ["default"].fullAngleForNormalizedVector */ .Z.fullAngleForNormalizedVector(vx, vy) * 180 / Math.PI;
        item.area.r = angle;

        if (isFinite(rotationOffset)) {
          item.area.r += rotationOffset;
        }

        ;
      }
    } // bringing transform back from world to local so that also works correctly for sub-items


    let localPoint = worldPoint;

    if (item.meta && item.meta.parentId) {
      const parentItem = schemeContainer.findItemById(item.meta.parentId);

      if (parentItem) {
        localPoint = schemeContainer.localPointOnItem(worldPoint.x, worldPoint.y, parentItem);
      }
    }

    item.area.x = localPoint.x - item.area.w / 2;
    item.area.y = localPoint.y - item.area.h / 2;
    schemeContainer.reindexItemTransforms(item);
    _components_editor_EventBus__WEBPACK_IMPORTED_MODULE_0__/* ["default"].emitItemChanged */ .Z.emitItemChanged(item.id);
  }

});

/***/ }),

/***/ 6012:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "N": () => (/* binding */ encodeColor),
/* harmony export */   "l": () => (/* binding */ parseColor)
/* harmony export */ });
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
function parseCommaSeparateRgba(text) {
  const arr = text.split(',');
  let r = 0,
      g = 0,
      b = 0,
      a = 1.0;

  if (arr.length > 0) {
    r = parseInt(arr[0]);
  }

  if (arr.length > 1) {
    g = parseInt(arr[1]);
  }

  if (arr.length > 2) {
    b = parseInt(arr[2]);
  }

  if (arr.length > 3) {
    a = parseFloat(arr[3]);
  }

  return {
    r,
    g,
    b,
    a
  };
}

function parseHexColor(text) {
  let r = 0,
      g = 0,
      b = 0,
      a = 1.0;

  if (text.length === 3) {
    r = parseInt(`${text[0]}${text[0]}`, 16);
    g = parseInt(`${text[1]}${text[1]}`, 16);
    b = parseInt(`${text[2]}${text[2]}`, 16);
  } else {
    if (text.length >= 2) {
      r = parseInt(text.substring(0, 2), 16);
    }

    if (text.length >= 4) {
      g = parseInt(text.substring(2, 4), 16);
    }

    if (text.length >= 6) {
      b = parseInt(text.substring(4, 6), 16);
    }
  }

  return {
    r,
    g,
    b,
    a
  };
}
/**
 * 
 * @param {Object} color structure of {r,g,b,a}
 */


function encodeColor(c) {
  return `rgba(${c.r},${c.g},${c.b},${c.a})`;
}
/**
 * 
 * @param {String} text encoded color in rgb(), rgba(), or hex format
 * @returns {Object} {r,g,b,a} structure
 */

function parseColor(text) {
  text = text.toLowerCase();

  try {
    const bracketIdx = text.indexOf('(');
    const closeBracketIdx = text.indexOf(')');

    if (bracketIdx > 0 && closeBracketIdx > 0) {
      const firstWord = text.substring(0, bracketIdx).trim();

      if (firstWord === 'rgb' || firstWord === 'rgba') {
        return parseCommaSeparateRgba(text.substring(bracketIdx + 1, closeBracketIdx));
      }
    }

    if (text.charAt(0) === '#') {
      return parseHexColor(text.substring(1));
    }
  } catch (e) {// do nothing
  }

  return {
    r: 0,
    g: 0,
    b: 0,
    a: 1.0
  };
}

/***/ }),

/***/ 536:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1094);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2017);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8442);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




const log = new _logger__WEBPACK_IMPORTED_MODULE_0__/* .Logger */ .Yd('EventBus');
const EventBus = new (vue__WEBPACK_IMPORTED_MODULE_2___default())({
  data() {
    return {
      START_CREATING_ITEM: 'start-creating-item',
      START_CONNECTING_ITEM: 'start-connecting-item',
      START_CURVE_EDITING: 'start-curve-editing',
      START_DRAWING: 'start-drawing',
      STOP_DRAWING: 'stop-drawing',
      COMPONENT_LOAD_REQUESTED: 'component-load-requested',
      COMPONENT_LOAD_FAILED: 'component-load-failed',
      COMPONENT_SCHEME_MOUNTED: 'component-scheme-mounted',
      PLACE_ITEM: 'place-item',
      CANCEL_CURRENT_STATE: 'cancel-current-state',
      EDITOR_STATE_CHANGED: 'editor-state-changed',
      KEY_PRESS: 'key-press',
      KEY_UP: 'key-up',
      BRING_TO_VIEW: 'bring-to-view',
      SCHEME_CHANGE_COMMITED: 'scheme-changed-commited',
      ANY_ITEM_CLICKED: 'any-item-clicked',
      ITEM_CHANGED: 'item-changed',
      ITEM_SELECTED: 'item-selected',
      ITEM_DESELECTED: 'item-deselected',
      ANY_ITEM_CHANGED: 'any-item-changed',
      ANY_ITEM_SELECTED: 'any-item-selected',
      ANY_ITEM_DESELECTED: 'any-item-deselected',
      ITEM_HIGHLIGHT_SET: 'item-highlight-set',
      // used to trigger in-svg text edit of an item
      ITEM_TEXT_SLOT_EDIT_TRIGGERED: 'item-text-slot-edit-triggered',
      ITEM_TEXT_SLOT_EDIT_CANCELED: 'item-text-slot-edit-canceled',
      // emited when user moves one text slot into another
      ITEM_TEXT_SLOT_MOVED: 'item-text-slot-moved',
      // used when in place rich text editor is created and mounted, this comes after ITEM_TEXT_SLOT_EDIT_TRIGGERED event
      ITEM_IN_PLACE_TEXT_EDITOR_CREATED: 'item-in-place-text-editor-created',
      // triggered when user clicks empty space
      VOID_CLICKED: 'void-clicked',
      // triggered when user clicks empty space with right button
      VOID_RIGHT_CLICKED: 'void-clicked',
      // triggered when user double clicks empty space
      VOID_DOUBLE_CLICKED: 'void-double-clicked',
      // used to trigger display of item description as a tooltip (when in interactive mode)
      ITEM_TOOLTIP_TRIGGERED: 'item-tooltip-triggered',
      // used to trigger side panel for specified item in interaction (view) mode
      ITEM_SIDE_PANEL_TRIGGERED: 'item-side-panel-triggered',
      // used in view mode in case item has links
      ITEM_LINKS_SHOW_REQUESTED: 'item-links-show-requested',
      RIGHT_CLICKED_ITEM: 'right-clicked-item',
      // used inside ElementPicker and force editor state to switch to StatePickElement
      ELEMENT_PICK_REQUESTED: 'element-pick-requested',
      ELEMENT_PICK_CANCELED: 'element-pick-canceled',
      ELEMENT_PICKED: 'element-picked',
      CURVE_EDITED: 'curve-edited',
      CURVE_EDIT_STOPPED: 'curve-edit-stopped',
      CURVE_EDIT_POINTS_UPDATED: 'curve-edit-points-updated',
      CUSTOM_CONTEXT_MENU_REQUESTED: 'custom-context-menu-requested',
      SCREEN_TRANSFORM_UPDATED: 'screen-transform-updated',
      ITEMS_HIGHLIGHTED: 'items-highlighted',
      ITEM_SURROUND_CREATED: 'item-surround-created',
      BEHAVIOR_PANEL_REQUESTED: 'behavior-panel-requested',
      MULTI_ITEM_EDIT_BOX_ITEMS_UPDATED: 'multi-item-edit-box-items-updated',
      MULTI_ITEM_EDIT_BOX_AREA_UPDATED: 'multi-item-edit-box-area-updated',
      ITEM_CREATION_DRAGGED_TO_SVG_EDITOR: 'item-creation-dragged-to-svg-editor',
      // triggered in case user clicked undo or redo and the scheme was reset to a new state
      HISTORY_UNDONE: 'history-undone',
      IMAGE_CROP_TRIGGERED: 'image-crop-triggered',
      SCHEME_PATCH_REQUESTED: 'scheme-patch-requested',
      FLOATING_HELPER_PANEL_UPDATED: 'floating-helper-panel-updated',
      // used for each frame_player item to initialize it's callbacks for its own frame animation
      FRAME_PLAYER_PREPARED: 'frame-player-prepared',
      CLICKABLE_MARKERS_TOGGLED: 'clickable-markers-toggled',
      EXTRA_SHAPE_GROUP_REGISTERED: 'extra-shape-group-registered',
      ART_PACK_ADDED: 'art-pack-added'
    };
  },

  methods: {
    emitSchemeChangeCommited(affinityId) {
      this.$emit(EventBus.SCHEME_CHANGE_COMMITED, affinityId);
    },

    /**
     * emits an event when a single item is supposed to be highlighted
     * @param {Array} itemIds array of ids of items that should be highlighted. In case it is set as null or empty - then no items should be highlighted at all.
     */
    emitItemsHighlighted(itemIds, options) {
      const highlightPins = options ? options.highlightPins : false;
      this.$emit(EventBus.ITEMS_HIGHLIGHTED, itemIds, {
        highlightPins
      });
    },

    /**
     * @param {string} itemId  id of an item
     * @param {string} propertyPath  path to a field that was changed. This argument is optional
     */
    emitItemChanged(itemId, propertyPath) {
      this.$emit(this._itemChangedEvent(itemId), propertyPath);
      this.$emit(EventBus.ANY_ITEM_CHANGED, itemId, propertyPath);
    },

    subscribeForItemChanged(itemId, callback) {
      this.$on(this._itemChangedEvent(itemId), callback);
    },

    unsubscribeForItemChanged(itemId, callback) {
      this.$off(this._itemChangedEvent(itemId), callback);
    },

    _itemChangedEvent(itemId) {
      return `${EventBus.ITEM_CHANGED}/${itemId}`;
    },

    emitItemSelected(itemId) {
      this.$emit(this._itemSelectedEvent(itemId));
      this.$emit(EventBus.ANY_ITEM_SELECTED, itemId);
    },

    subscribeForItemSelected(itemId, callback) {
      this.$on(this._itemSelectedEvent(itemId), callback);
    },

    unsubscribeForItemSelected(itemId, callback) {
      this.$off(this._itemSelectedEvent(itemId), callback);
    },

    _itemSelectedEvent(itemId) {
      return `${EventBus.ITEM_SELECTED}/${itemId}`;
    },

    emitItemDeselected(itemId) {
      this.$emit(this._itemDeselectedEvent(itemId));
      this.$emit(EventBus.ANY_ITEM_DESELECTED, itemId);
    },

    subscribeForItemDeselected(itemId, callback) {
      this.$on(this._itemDeselectedEvent(itemId), callback);
    },

    unsubscribeForItemDeselected(itemId, callback) {
      this.$off(this._itemDeselectedEvent(itemId), callback);
    },

    _itemDeselectedEvent(itemId) {
      return `${EventBus.ITEM_DESELECTED}/${itemId}`;
    },

    emitAnyItemDeselected() {
      this.$emit(EventBus.ANY_ITEM_DESELECTED);
    },

    emitRightClickedItem(item, mouseX, mouseY) {
      this.$emit(EventBus.RIGHT_CLICKED_ITEM, item, mouseX, mouseY);
    },

    /**
     * 
     * @param {Item} item 
     * @param {string} slotName 
     * @param {Area} area - Area of a text slot and not of an item
     * @param {Boolean} markupDisabled - true if HTML markup is disabled. This means that a simple textarea is going to be used for text editing
     * @param {Boolean} creatingNewItem - true if it is triggered for a new item (e.g. double clicking void)
     */
    emitItemTextSlotEditTriggered(item, slotName, area, markupDisabled, creatingNewItem) {
      this.$emit(EventBus.ITEM_TEXT_SLOT_EDIT_TRIGGERED, item, slotName, area, markupDisabled, creatingNewItem);
    },

    emitItemTextSlotEditCanceled(item, slotName) {
      this.$emit(EventBus.ITEM_TEXT_SLOT_EDIT_CANCELED, item, slotName);
    },

    emitItemTextSlotMoved(item, slotName, destinationSlotName) {
      this.$emit(EventBus.ITEM_TEXT_SLOT_MOVED, item, slotName, destinationSlotName);
    },

    emitItemInPlaceTextEditorCreated(editor) {
      this.$emit(this.ITEM_IN_PLACE_TEXT_EDITOR_CREATED, editor);
    },

    emitElementPickRequested(elementPickCallback) {
      this.$emit(EventBus.ELEMENT_PICK_REQUESTED, elementPickCallback);
    },

    emitElementPickCanceled() {
      this.$emit(EventBus.ELEMENT_PICK_CANCELED);
    },

    emitCurveEdited(item) {
      this.$emit(EventBus.CURVE_EDITED, item);
    },

    emitCustomContextMenuRequested(mouseX, mouseY, menuOptions) {
      this.$emit(EventBus.CUSTOM_CONTEXT_MENU_REQUESTED, mouseX, mouseY, menuOptions);
    },

    emitItemSurroundCreated(item, boundingBox, padding) {
      this.$emit(EventBus.ITEM_SURROUND_CREATED, item, boundingBox, padding);
    },

    emitBringToViewAnimated(area) {
      this.$emit(EventBus.BRING_TO_VIEW, area, true);
    },

    emitBringToViewInstantly(area) {
      this.$emit(EventBus.BRING_TO_VIEW, area, false);
    },

    emitItemCreationDraggedToSvgEditor(item, pageX, pageY) {
      this.$emit(EventBus.ITEM_CREATION_DRAGGED_TO_SVG_EDITOR, item, pageX, pageY);
    },

    emitComponentLoadRequested(item) {
      this.$emit(EventBus.COMPONENT_LOAD_REQUESTED, item);
    },

    emitComponentLoadFailed(item) {
      this.$emit(EventBus.COMPONENT_LOAD_FAILED, item);
    },

    emitComponentSchemeMounted(item) {
      this.$emit(EventBus.COMPONENT_SCHEME_MOUNTED, item);
    },

    emitEditorStateChanged(stateName) {
      this.$emit(EventBus.EDITOR_STATE_CHANGED, stateName);
    },

    emitSchemePatchRequested(scheme) {
      this.$emit(EventBus.SCHEME_PATCH_REQUESTED, scheme);
    },

    emitFloatingHelperPanelUpdated() {
      this.$emit(EventBus.FLOATING_HELPER_PANEL_UPDATED);
    },

    emitFramePlayerPrepared(framePlayerItem, frameCallbacks) {
      this.$emit(EventBus.FRAME_PLAYER_PREPARED, framePlayerItem, frameCallbacks);
    }

  }
}); // Adding logging of all events in EventBus

const _old$emit = EventBus.$emit;

EventBus.$emit = (...args) => {
  log.infoEvent(args[0], args);

  if (_old$emit) {
    _old$emit.apply(EventBus, args);
  }
};

document.addEventListener('keyup', event => {
  event = event || window.event;

  if (event.target === document.body) {
    const key = (0,_events__WEBPACK_IMPORTED_MODULE_1__/* .identifyKeyPress */ .W)(event);

    if (key) {
      event.preventDefault();
      EventBus.$emit(EventBus.KEY_UP, key, {
        ctrlCmdPressed: event.metaKey || event.ctrlKey
      });
    }
  }
});
document.addEventListener('keydown', event => {
  event = event || window.event;

  if (event.target === document.body) {
    const key = (0,_events__WEBPACK_IMPORTED_MODULE_1__/* .identifyKeyPress */ .W)(event);

    if (key) {
      event.preventDefault();
      EventBus.$emit(EventBus.KEY_PRESS, key, {
        ctrlCmdPressed: event.metaKey || event.ctrlKey
      });
    }
  }
});
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventBus);

/***/ }),

/***/ 9874:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3311);
/* harmony import */ var lodash_find__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_find__WEBPACK_IMPORTED_MODULE_0__);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

const _knownTypes = [{
  name: 'default',
  fontAwesomeSymbol: '\uf0c1',
  cssClass: 'fas fa-link'
}, {
  name: 'doc',
  fontAwesomeSymbol: '\uf542',
  cssClass: 'fas fa-project-diagram'
}, {
  name: 'logs',
  fontAwesomeSymbol: '\uf550',
  cssClass: 'fas fa-stream'
}, {
  name: 'graphs',
  fontAwesomeSymbol: '\uf201',
  cssClass: 'fas fa-chart-line'
}, {
  name: 'video',
  fontAwesomeSymbol: '\uf03d',
  cssClass: 'fas fa-video'
}];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  knownTypes: _knownTypes,

  findTypeByNameOrDefault(name) {
    var linkType = lodash_find__WEBPACK_IMPORTED_MODULE_0___default()(_knownTypes, t => t.name === name);

    if (linkType) {
      return linkType;
    } else {
      return _knownTypes[0];
    }
  }

});

/***/ }),

/***/ 4502:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3674);
/* harmony import */ var lodash_keys__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_keys__WEBPACK_IMPORTED_MODULE_0__);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

const patterns = {
  'solid': () => '',
  'dotted': w => `${w} ${w * 2}`,
  'dashed': w => `${w * 4} ${w * 4}`,
  'dashed-2': w => `${w * 4} ${w * 2}`,
  'dashed-3': w => `${w * 4} ${w * 8}`,
  'dashed-dotted': w => `${w * 4} ${w * 2} ${w * 2} ${w * 2}`,
  'dashed-dotted-2': w => `${w * 4} ${w} ${w} ${w}`,
  'dashed-dotted-3': w => `${w * 8} ${w * 4} ${w * 4} ${w * 4}`,
  'dashed-dotted-4': w => `${w * 8} ${w * 2} ${w * 2} ${w * 2}`
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  createDashArray(strokePattern, strokeSize) {
    const dashArrayFunc = patterns[strokePattern];

    if (dashArrayFunc) {
      return dashArrayFunc(strokeSize);
    }

    return '';
  },

  generateStrokeHtml(pattern, strokeWidth, y, w, h) {
    const dashArray = this.createDashArray(pattern, strokeWidth);
    return `<svg width="${w}px" height="${h}px">` + `<path d="M0 ${y} l ${w} 0" fill="none" stroke="#111111" stroke-width="${strokeWidth}" stroke-dasharray="${dashArray}"/>` + '</svg>';
  },

  patterns: lodash_keys__WEBPACK_IMPORTED_MODULE_0___default()(patterns),
  SOLID: 'solid',
  DASHED: 'dashed',
  DOTTED: 'dotted'
});

/***/ }),

/***/ 6942:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
function createPointsForCurlyBracket(p, d, r, D, R) {
  const A = Math.min(40, R * 0.2);
  const B = Math.min(20, R * 0.2);
  return [p, {
    type: 'Q',
    x1: p.x + d.x * D / 2,
    y1: p.y + d.y * D / 2,
    x2: p.x + d.x * D / 2 + r.x * A,
    y2: p.y + d.y * D / 2 + r.y * A
  }, {
    x: p.x + d.x * D / 2 + r.x * (R / 2 - B),
    y: p.y + d.y * D / 2 + r.y * (R / 2 - B)
  }, {
    type: 'Q',
    x1: p.x + d.x * D / 2 + r.x * (R / 2),
    y1: p.y + d.y * D / 2 + r.y * R / 2,
    x2: p.x + d.x * D + r.x * (R / 2),
    y2: p.y + d.y * D + r.y * (R / 2)
  }, {
    type: 'Q',
    x1: p.x + d.x * D / 2 + r.x * (R / 2),
    y1: p.y + d.y * D / 2 + r.y * R / 2,
    x2: p.x + d.x * D / 2 + r.x * (R / 2 + B),
    y2: p.y + d.y * D / 2 + r.y * (R / 2 + B)
  }, {
    x: p.x + d.x * D / 2 + r.x * (R - A),
    y: p.y + d.y * D / 2 + r.y * (R - A)
  }, {
    type: 'Q',
    x1: p.x + r.x * R + d.x * D / 2,
    y1: p.y + r.y * R + d.y * D / 2,
    x2: p.x + r.x * R,
    y2: p.y + r.y * R
  }];
}

function createPointsForCurlySharp(p, d, r, D, R) {
  const A = Math.min(40, R * 0.2);
  const B = Math.min(20, R * 0.2);
  return [p, {
    x: p.x + d.x * D / 2 + r.x * A,
    y: p.y + d.y * D / 2 + r.y * A
  }, {
    x: p.x + d.x * D / 2 + r.x * (R / 2 - B),
    y: p.y + d.y * D / 2 + r.y * (R / 2 - B)
  }, {
    x: p.x + d.x * D + r.x * (R / 2),
    y: p.y + d.y * D + r.y * (R / 2)
  }, {
    x: p.x + d.x * D / 2 + r.x * (R / 2 + B),
    y: p.y + d.y * D / 2 + r.y * (R / 2 + B)
  }, {
    x: p.x + d.x * D / 2 + r.x * (R - A),
    y: p.y + d.y * D / 2 + r.y * (R - A)
  }, {
    x: p.x + r.x * R,
    y: p.y + r.y * R
  }];
}

function createPointsForSquareBracket(p, d, r, D, R) {
  return [p, {
    x: p.x + d.x * D,
    y: p.y + d.y * D
  }, {
    x: p.x + d.x * D + r.x * R,
    y: p.y + d.y * D + r.y * R
  }, {
    x: p.x + r.x * R,
    y: p.y + r.y * R
  }];
}

function createPointsForRoundBracket(p, d, r, D, R) {
  const A = 0.3;
  return [p, {
    type: 'C',
    x1: p.x + d.x * D + r.x * A,
    y1: p.y + d.y * D + r.y * A,
    x2: p.x + d.x * D + r.x * (R - A),
    y2: p.y + d.y * D + r.y * (R - A),
    x3: p.x + r.x * R,
    y3: p.y + r.y * R
  }];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'bracket',
    menuItems: [{
      name: 'Curly Bracket',
      group: 'General',
      iconUrl: '/assets/images/items/curly-bracket.svg',
      item: {
        shapeProps: {
          fill: {
            type: 'none'
          },
          style: 'curly'
        }
      },
      size: {
        w: 20,
        h: 200
      },
      previewArea: {
        x: 5,
        y: 30,
        w: 130,
        h: 15,
        r: 0
      }
    }, {
      name: 'Square Bracket',
      group: 'General',
      iconUrl: '/assets/images/items/square-bracket.svg',
      item: {
        shapeProps: {
          fill: {
            type: 'none'
          },
          style: 'square'
        }
      },
      size: {
        w: 20,
        h: 200
      },
      previewArea: {
        x: 5,
        y: 30,
        w: 130,
        h: 15,
        r: 0
      }
    }, {
      name: 'Round Bracket',
      group: 'General',
      iconUrl: '/assets/images/items/round-bracket.svg',
      item: {
        shapeProps: {
          fill: {
            type: 'none'
          },
          style: 'round'
        }
      },
      size: {
        w: 20,
        h: 200
      },
      previewArea: {
        x: 5,
        y: 30,
        w: 130,
        h: 15,
        r: 0
      }
    }],

    getPins(item) {
      return [];
    },

    getTextSlots(item) {
      return [];
    },

    computePath(item) {
      // starting point
      const p = {
        x: 0,
        y: 0
      }; // direction vector (down)

      const d = {
        x: 0,
        y: 1
      };
      let D = item.area.h; // direction vector (right)

      const r = {
        x: 1,
        y: 0
      };
      let R = item.area.w;

      if (item.area.w < item.area.h) {
        d.x = 1;
        d.y = 0;
        D = item.area.w;
        r.x = 0;
        r.y = -1;
        R = item.area.h;
        p.x = 0;
        p.y = item.area.h;
      }

      let points = [];

      if (item.shapeProps.style === 'curly') {
        points = createPointsForCurlyBracket(p, d, r, D, R);
      } else if (item.shapeProps.style === 'curly-sharp') {
        points = createPointsForCurlySharp(p, d, r, D, R);
      } else if (item.shapeProps.style === 'round') {
        points = createPointsForRoundBracket(p, d, r, D, R);
      } else {
        points = createPointsForSquareBracket(p, d, r, D, R);
      }

      let path = `M ${points[0].x} ${points[0].y}`;

      for (let i = 1; i < points.length; i++) {
        if (points[i].type === 'C') {
          path += ` C ${points[i].x1} ${points[i].y1} ${points[i].x2} ${points[i].y2} ${points[i].x3} ${points[i].y3}`;
        } else if (points[i].type === 'Q') {
          path += ` Q ${points[i].x1} ${points[i].y1} ${points[i].x2} ${points[i].y2}`;
        } else {
          path += ` L ${points[i].x} ${points[i].y}`;
        }
      }

      return path;
    },

    args: {
      style: {
        type: 'choice',
        value: 'curly',
        name: 'Style',
        options: ['curly', 'curly-sharp', 'square', 'round']
      }
    }
  }
});

/***/ }),

/***/ 1008:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4486);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3590);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



function makeTailControlPoint(item) {
  let x = 0,
      y = 0;

  if (item.shapeProps.tailSide === 'top') {
    x = item.shapeProps.tailPosition;
    y = -item.shapeProps.tailLength;
  } else if (item.shapeProps.tailSide === 'bottom') {
    x = item.shapeProps.tailPosition;
    y = item.area.h + item.shapeProps.tailLength;
  } else if (item.shapeProps.tailSide === 'left') {
    x = -item.shapeProps.tailLength;
    y = item.shapeProps.tailPosition;
  } else if (item.shapeProps.tailSide === 'right') {
    x = item.area.w + item.shapeProps.tailLength;
    y = item.shapeProps.tailPosition;
  }

  return {
    x,
    y
  };
}

function handleTailControlPointDrag(item, originalX, originalY, dx, dy) {
  let x = originalX + dx;
  let y = originalY + dy; // here we identify from which side of the two diagonal lines does is the current point positioned
  // This way we divide the space into 4 regions which would correspond to the tail side

  const side1 = _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].identifyPointSideAgainstLine */ .Z.identifyPointSideAgainstLine(x, y, _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].createLineEquation */ .Z.createLineEquation(0, 0, item.area.w, item.area.h));
  const side2 = _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].identifyPointSideAgainstLine */ .Z.identifyPointSideAgainstLine(x, y, _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].createLineEquation */ .Z.createLineEquation(0, item.area.h, item.area.w, 0));
  let sideId = 3;

  if (side1 < 0) {
    sideId = sideId & 1;
  }

  if (side2 < 0) {
    sideId = sideId & 2;
  }

  if (sideId === 0) {
    item.shapeProps.tailSide = 'top';
    item.shapeProps.tailPosition = x;
    item.shapeProps.tailLength = -y;
  } else if (sideId === 3) {
    item.shapeProps.tailSide = 'bottom';
    item.shapeProps.tailPosition = x;
    item.shapeProps.tailLength = y - item.area.h;
  }

  if (sideId == 2) {
    item.shapeProps.tailSide = 'left';
    item.shapeProps.tailPosition = y;
    item.shapeProps.tailLength = -x;
  } else if (sideId == 1) {
    item.shapeProps.tailSide = 'right';
    item.shapeProps.tailPosition = y;
    item.shapeProps.tailLength = x - item.area.w;
  }
}

function makeTailWidthPoint(item) {
  const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 4, item.area.h / 4);
  const W = item.area.w;
  const H = item.area.h;
  let x = 0,
      y = 0;
  const tailWidth = Math.max(0, item.shapeProps.tailWidth);

  if (item.shapeProps.tailSide === 'top') {
    let t = 0;
    const length = Math.max(0, W - 2 * R);

    if (length > 0) {
      t = _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(item.shapeProps.tailPosition / length, 0, 1);
    }

    x = R + tailWidth + (length - tailWidth) * t;
    y = 0;
  } else if (item.shapeProps.tailSide === 'bottom') {
    let t = 0;
    const length = Math.max(0, W - 2 * R);

    if (length > 0) {
      t = 1 - _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(item.shapeProps.tailPosition / length, 0, 1);
    }

    x = W - R - tailWidth - (length - tailWidth) * t;
    y = H;
  } else if (item.shapeProps.tailSide === 'left') {
    let t = 0;
    const length = Math.max(0, H - 2 * R);

    if (length > 0) {
      t = 1 - _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(item.shapeProps.tailPosition / length, 0, 1);
    }

    x = 0;
    y = H - R - tailWidth - (length - tailWidth) * t;
  } else if (item.shapeProps.tailSide === 'right') {
    let t = 0;
    const length = Math.max(0, H - 2 * R);

    if (length > 0) {
      t = _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(item.shapeProps.tailPosition / length, 0, 1);
    }

    x = W;
    y = R + tailWidth + (length - tailWidth) * t;
  }

  return {
    x,
    y
  };
}

function handleTailWidthControlPointDrag(item, originalX, originalY, dx, dy) {
  const x = originalX + dx;
  const y = originalY + dy;
  const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 4, item.area.h / 4);
  const W = item.area.w;
  const H = item.area.h;
  const tailWidth = Math.max(0, item.shapeProps.tailWidth);

  if (item.shapeProps.tailSide === 'top') {
    let t = 0;
    const length = Math.max(0, W - 2 * R);

    if (length > 0) {
      t = _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(item.shapeProps.tailPosition / length, 0, 1);
    }

    const x0 = R + (length - tailWidth) * t;
    item.shapeProps.tailWidth = _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(x - x0, 0, length / 2);
  } else if (item.shapeProps.tailSide === 'bottom') {
    let t = 0;
    const length = Math.max(0, W - 2 * R);

    if (length > 0) {
      t = 1 - _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(item.shapeProps.tailPosition / length, 0, 1);
    }

    const x0 = W - R - (length - tailWidth) * t;
    item.shapeProps.tailWidth = _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(x0 - x, 0, length / 2);
  } else if (item.shapeProps.tailSide === 'left') {
    let t = 0;
    const length = Math.max(0, H - 2 * R);

    if (length > 0) {
      t = 1 - _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(item.shapeProps.tailPosition / length, 0, 1);
    }

    const y0 = H - R - (length - tailWidth) * t;
    item.shapeProps.tailWidth = _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(y0 - y, 0, length / 2);
  } else if (item.shapeProps.tailSide === 'right') {
    let t = 0;
    const length = Math.max(0, H - 2 * R);

    if (length > 0) {
      t = _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(item.shapeProps.tailPosition / length, 0, 1);
    }

    const y0 = R + (length - tailWidth) * t;
    item.shapeProps.tailWidth = _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(y - y0, 0, length / 2);
  }
}

function makeCornerRadiusControlPoint(item) {
  return {
    x: Math.min(item.area.w, Math.max(item.area.w - item.shapeProps.cornerRadius, item.area.w / 2)),
    y: 0
  };
}

const controlPointFuncs = {
  tail: makeTailControlPoint,
  tailWidth: makeTailWidthPoint,
  cornerRadius: makeCornerRadiusControlPoint
};
/*

Example of constructing tail shape for bottom side
 /--------------------------\
|                           |
|         Coment            |
|                           |
|                           |
| P5     P4       P2     P1 |
\<-------x<-------x<------x/ .     <---- V (side vector (vx, vy))
    b     \  TW  /    a      .             N (perpendicular vector (nx, ny))
           \    /            .             .
            \  /             .             .
             \/              .             .
             x               .             v
             P3              TL
          ........
             TW
 ...........................
           side.length

TL = tail length
TW = tail width
V1 = a * V
P2 = P1 + V1
*/

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'comment',
    menuItems: [{
      group: 'Basic Shapes',
      name: 'Comment',
      iconUrl: '/assets/images/items/comment.svg',
      item: {
        text: 'Text...',
        shapeProps: {
          fontSize: 8,
          cornerRadius: 5,
          tailLength: 20,
          tailWidth: 20,
          tailSide: 'bottom',
          tailPosition: 10
        }
      },
      previewArea: {
        x: 5,
        y: 5,
        w: 130,
        h: 60,
        r: 0
      }
    }],

    computePath(item) {
      const W = item.area.w;
      const H = item.area.h;
      const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 4, item.area.h / 4);
      let path = `M 0 ${R} `;
      let sides = [{
        name: 'top',
        length: W - 2 * R,
        invertT: true,
        p1x: R,
        p1y: 0,
        vx: 1,
        vy: 0,
        nx: 0,
        ny: -1,
        ax: 1,
        ay: -1
      }, {
        name: 'right',
        length: H - 2 * R,
        invertT: true,
        p1x: W,
        p1y: R,
        vx: 0,
        vy: 1,
        nx: 1,
        ny: 0,
        ax: 1,
        ay: 1
      }, {
        name: 'bottom',
        length: W - 2 * R,
        invertT: false,
        p1x: W - R,
        p1y: H,
        vx: -1,
        vy: 0,
        nx: 0,
        ny: 1,
        ax: -1,
        ay: 1
      }, {
        name: 'left',
        length: H - 2 * R,
        invertT: false,
        p1x: 0,
        p1y: H - R,
        vx: 0,
        vy: -1,
        nx: -1,
        ny: 0,
        ax: -1,
        ay: -1
      }];
      const tailWidth = Math.max(0, item.shapeProps.tailWidth);

      for (let i = 0; i < sides.length; i++) {
        const side = sides[i];
        path += `a ${R} ${R} 0 0 1 ${R * side.ax} ${R * side.ay} `;

        if (item.shapeProps.tailSide === side.name) {
          const TL = item.shapeProps.tailLength;
          const TW = Math.min(Math.max(0, side.length - tailWidth), tailWidth);
          let t = 0;

          if (side.length > 0) {
            t = _myMath__WEBPACK_IMPORTED_MODULE_1__/* ["default"].clamp */ .Z.clamp(item.shapeProps.tailPosition / side.length, 0, 1);
          }

          if (side.invertT) {
            t = 1 - t;
          }

          const a = (side.length - TW) * (1 - t);
          const b = (side.length - TW) * t;
          const v1x = a * side.vx;
          const v1y = a * side.vy;
          const p2x = side.p1x + v1x;
          const p2y = side.p1y + v1y;
          const p4x = p2x + TW * side.vx;
          const p4y = p2y + TW * side.vy;
          const p5x = p4x + b * side.vx;
          const p5y = p4y + b * side.vy;
          let p3x = 0,
              p3y = 0;

          if (side.name === 'bottom' || side.name === 'top') {
            p3x = item.shapeProps.tailPosition;
            p3y = side.p1y + TL * side.ny;
          } else {
            p3y = item.shapeProps.tailPosition;
            p3x = side.p1x + TL * side.nx;
          }

          path += `L ${side.p1x} ${side.p1y} L ${p2x} ${p2y} L ${p3x} ${p3y}  L ${p4x} ${p4y} L ${p5x} ${p5y} `;
        } else {
          path += `l ${side.length * side.vx} ${side.length * side.vy} `;
        }
      }

      path = path + ' z';
      return path;
    },

    controlPoints: {
      make(item, pointId) {
        if (!pointId) {
          const controlPoints = {};
          lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(controlPointFuncs, (func, name) => {
            controlPoints[name] = func(item);
          });
          return controlPoints;
        } else {
          return controlPointFuncs[pointId](item);
        }
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'tail') {
          handleTailControlPointDrag(item, originalX, originalY, dx, dy);
        } else if (controlPointName === 'cornerRadius') {
          item.shapeProps.cornerRadius = Math.max(0, item.area.w - Math.max(item.area.w / 2, originalX + dx));
        } else if (controlPointName === 'tailWidth') {
          handleTailWidthControlPointDrag(item, originalX, originalY, dx, dy);
        }
      }

    },
    args: {
      cornerRadius: {
        type: 'number',
        value: 10,
        name: 'Corner radius'
      },
      tailLength: {
        type: 'number',
        value: 30,
        name: 'Tail Length'
      },
      tailWidth: {
        type: 'number',
        value: 40,
        name: 'Tail Width'
      },
      tailSide: {
        type: 'choice',
        value: 'bottom',
        name: 'Tail Side',
        options: ['top', 'bottom', 'left', 'right']
      },
      tailPosition: {
        type: 'number',
        value: 0,
        name: 'Tail Position'
      }
    }
  }
});

/***/ }),

/***/ 125:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "g": () => (/* binding */ createConnectorCap)
/* harmony export */ });
/* unused harmony export getCapTypes */
/* harmony import */ var lodash_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3674);
/* harmony import */ var lodash_keys__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_keys__WEBPACK_IMPORTED_MODULE_0__);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


function standard(func) {
  return {
    hollow: false,
    renderFunc: func
  };
}

function hollow(func) {
  return {
    hollow: true,
    renderFunc: func
  };
}

const allCaps = {
  'empty': null,
  'triangle': standard((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 1, 2, true)),
  'triangle-1': standard((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 1, 1, true)),
  'triangle-2': standard((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 1, 3, true)),
  'arrow': standard((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 1, 2, false)),
  'arrow-1': standard((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 1, 1, false)),
  'arrow-2': standard((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 1, 3, false)),
  'triangle-h': hollow((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 1, 2, true)),
  'triangle-h-1': hollow((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 1, 1, true)),
  'triangle-h-2': hollow((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 1, 3, true)),
  'circle': standard((x, y, Vx, Vy) => {
    const squaredD = Vx * Vx + Vy * Vy;

    if (squaredD > 0.01) {
      let r = Math.sqrt(squaredD) / 2;
      const cx = x + Vx / 2;
      const cy = y + Vy / 2;
      return {
        path: ` M ${cx - r}, ${cy} a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${r * 2},0`,
        hollow: false,
        entryPoint: {
          x: x + Vx,
          y: y + Vy
        }
      };
    }

    return null;
  }),
  'circle-cross': hollow((x, y, Vx, Vy) => {
    const squaredD = Vx * Vx + Vy * Vy;

    if (squaredD > 0.01) {
      let r = Math.sqrt(squaredD) / 2;
      const cx = x + Vx / 2;
      const cy = y + Vy / 2;
      const d = Math.cos(Math.PI / 4) * r;
      return {
        path: ` M ${cx - r}, ${cy} a ${r},${r} 0 1,0 ${r * 2},0 a ${r},${r} 0 1,0 -${r * 2},0 z M ${cx - d} ${cy - d} L ${cx + d} ${cy + d}  M ${cx + d} ${cy - d} L ${cx - d} ${cy + d}`,
        hollow: true,
        entryPoint: {
          x: x + Vx,
          y: y + Vy
        }
      };
    }

    return null;
  }),
  'double-arrow': standard((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 2, 2, false)),
  'double-arrow-1': standard((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 2, 1, false)),
  'double-arrow-2': standard((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 2, 3, false)),
  'double-triangle': standard((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 2, 2, true)),
  'double-triangle-1': standard((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 2, 1, true)),
  'double-triangle-2': standard((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 2, 3, true)),
  'double-triangle-h': hollow((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 2, 2, true)),
  'double-triangle-h-1': hollow((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 2, 1, true)),
  'double-triangle-h-2': hollow((x, y, Vx, Vy) => createArrowCap(x, y, Vx, Vy, 2, 3, true)),
  'diamond': standard((x, y, Vx, Vy) => createDiamondCap(x, y, Vx, Vy, 0.5)),
  'diamond-1': standard((x, y, Vx, Vy) => createDiamondCap(x, y, Vx, Vy, 1)),
  'diamond-2': standard((x, y, Vx, Vy) => createDiamondCap(x, y, Vx, Vy, 1.5)),
  'diamond-h': hollow((x, y, Vx, Vy) => createDiamondCap(x, y, Vx, Vy, 0.5)),
  'diamond-h-1': hollow((x, y, Vx, Vy) => createDiamondCap(x, y, Vx, Vy, 1)),
  'diamond-h-2': hollow((x, y, Vx, Vy) => createDiamondCap(x, y, Vx, Vy, 1.5)),
  'line': standard((x, y, Vx, Vy) => createLineCap(x, y, Vx, Vy, 1)),
  'double-line': standard((x, y, Vx, Vy) => createLineCap(x, y, Vx, Vy, 2)),
  'tripple-line': standard((x, y, Vx, Vy) => createLineCap(x, y, Vx, Vy, 3))
};

const _capTypes = lodash_keys__WEBPACK_IMPORTED_MODULE_0___default()(allCaps);

function getCapTypes() {
  return _capTypes;
}
function createConnectorCap(x, y, Vx, Vy, capType) {
  const cap = allCaps[capType];

  if (cap) {
    const result = cap.renderFunc(x, y, Vx, Vy);

    if (cap.hollow) {
      result.hollow = true;
    }

    return result;
  }

  return null;
}

function createLineCap(x, y, Vx, Vy, numberOfLines) {
  let path = '';
  const Bx = Vy / 2;
  const By = -Vx / 2;

  for (let i = 0; i < numberOfLines; i++) {
    const x0 = x + Vx * (i + 1) / (numberOfLines + 1);
    const y0 = y + Vy * (i + 1) / (numberOfLines + 1);
    const x1 = x0 + Bx;
    const y1 = y0 + By;
    const x2 = x0 - Bx;
    const y2 = y0 - By;
    path += `M ${x1} ${y1} L ${x2} ${y2} `;
  }

  return {
    path: path,
    hollow: true,
    prolongLine: true,
    entryPoint: {
      x: x + Vx,
      y: y + Vy
    }
  };
}

function createArrowCap(x, y, Vx, Vy, numberOfArrows, ratio, close) {
  let path = '';
  const Bx = Vy / (2 * ratio);
  const By = -Vx / (2 * ratio);

  for (let i = 0; i < numberOfArrows; i++) {
    const x0 = x + Vx * i / numberOfArrows;
    const y0 = y + Vy * i / numberOfArrows;
    const x1 = x0 + Vx / numberOfArrows + Bx;
    const y1 = y0 + Vy / numberOfArrows + By;
    const x2 = x0 + Vx / numberOfArrows - Bx;
    const y2 = y0 + Vy / numberOfArrows - By;
    path += `M ${x1} ${y1} L ${x0} ${y0} L ${x2} ${y2} `;

    if (close) {
      path += ' z ';
    }
  }

  return {
    path: path,
    hollow: !close,
    prolongLine: !close,
    entryPoint: {
      x: x + Vx,
      y: y + Vy
    }
  };
}

function createDiamondCap(x, y, Vx, Vy, ratio) {
  const Bx = ratio * Vy / 2;
  const By = -ratio * Vx / 2;
  const x1 = x + Vx / 2 - Bx;
  const y1 = y + Vy / 2 - By;
  const x2 = x + Vx;
  const y2 = y + Vy;
  const x3 = x + Vx / 2 + Bx;
  const y3 = y + Vy / 2 + By;
  return {
    path: `M ${x} ${y} L ${x1} ${y1} L ${x2} ${y2} L ${x3} ${y3} z`,
    hollow: false,
    entryPoint: {
      x: x + Vx,
      y: y + Vy
    }
  };
}

/***/ }),

/***/ 8915:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'ellipse',
    menuItems: [{
      group: 'Basic Shapes',
      name: 'Ellipse',
      iconUrl: '/assets/images/items/ellipse.svg'
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_0__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      const rx = item.area.w / 2;
      const ry = item.area.h / 2;
      return `M 0 ${ry} A ${rx} ${ry} 0 1 1 ${item.area.w} ${ry}  A ${rx} ${ry} 0 1 1 0 ${ry} Z`;
    }

  }
});

/***/ }),

/***/ 5664:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'npoly',
    menuItems: [{
      group: 'Basic Shapes',
      name: 'N-Polygon',
      iconUrl: '/assets/images/items/npolygon.svg',
      size: {
        w: 60,
        h: 60
      },
      previewArea: {
        x: 0,
        y: 0,
        w: 150,
        h: 150,
        r: 0
      }
    }],

    computePath(item) {
      const cx = item.area.w / 2;
      const cy = item.area.h / 2;
      const corners = Math.max(3, item.shapeProps.corners);
      let path = '';

      for (let i = 0; i < corners; i++) {
        const x = item.area.w / 2 * Math.cos(i * 2 * Math.PI / corners - Math.PI / 2 + item.shapeProps.angle * Math.PI / 180) + cx;
        const y = item.area.h / 2 * Math.sin(i * 2 * Math.PI / corners - Math.PI / 2 + item.shapeProps.angle * Math.PI / 180) + cy;

        if (i === 0) {
          path = `M ${x} ${y} `;
        }

        path += ` L ${x} ${y}`;
      }

      return path + ' Z';
    },

    args: {
      corners: {
        type: 'number',
        value: 6,
        name: 'Corners'
      },
      angle: {
        type: 'number',
        value: 0,
        name: 'Angle'
      }
    }
  }
});

/***/ }),

/***/ 9831:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'empty',
    id: 'none',
    menuItems: [{
      group: 'General',
      name: 'Text',
      iconUrl: '/assets/images/items/text.svg',
      item: {
        textSlots: {
          body: {
            text: 'Text ...',
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            paddingBottom: 0
          }
        }
      }
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_0__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      const w = item.area.w;
      const h = item.area.h;
      return `M 0 0  L ${w} 0  L ${w} ${h}  L 0 ${h} Z`;
    },

    args: {}
  }
});

/***/ }),

/***/ 1969:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    // id is used in order to register in Shape Registry
    // this will be the identifier that is specified with "shape" field in items
    id: 'rect',
    // menuItems is used in order to display shape in the items menu (left panel)
    menuItems: [{
      group: 'Basic Shapes',
      name: 'Rect',
      iconUrl: '/assets/images/items/rect.svg',
      item: {
        shapeProps: {
          cornerRadius: 0
        }
      }
    }, {
      group: 'Basic Shapes',
      name: 'Rounded Rect',
      iconUrl: '/assets/images/items/rounded-rect.svg',
      item: {
        shapeProps: {
          cornerRadius: 20
        }
      }
    }, {
      group: 'General',
      name: 'Overlay',
      iconUrl: '/assets/images/items/overlay.svg',
      description: `
                It lets you create a clickable area on the image (or any other element of the scheme) and treat it like an object.
                E.g. you can select it, trigger events or connect it to other items on the page.
            `,
      item: {
        cursor: 'pointer',
        opacity: 5,
        shapeProps: {
          cornerRadius: 0
        },
        behavior: {
          events: [{
            event: 'mousein',
            actions: [{
              element: 'self',
              method: 'set',
              args: {
                field: 'opacity',
                value: 50
              }
            }]
          }, {
            event: 'mouseout',
            actions: [{
              element: 'self',
              method: 'set',
              args: {
                field: 'opacity',
                value: 5
              }
            }]
          }]
        }
      }
    }, {
      group: 'General',
      name: 'Button',
      iconUrl: '/assets/images/items/button.svg',
      item: {
        cursor: 'pointer',
        opacity: 100,
        shapeProps: {
          cornerRadius: 20,
          fill: {
            type: 'gradient',
            color: 'rgba(29, 108, 176, 1)',
            gradient: {
              colors: [{
                c: 'rgba(25, 121, 204, 1)',
                p: 0
              }, {
                c: 'rgba(86, 172, 246, 1)',
                p: 100
              }],
              type: 'linear',
              direction: 0
            }
          },
          strokeColor: 'rgba(39, 132, 211, 1)',
          strokeSize: 2,
          strokePattern: 'solid'
        },
        textSlots: {
          body: {
            text: '<p><strong>Button</strong></p>',
            color: 'rgba(255, 255, 255, 1)',
            halign: 'center',
            valign: 'middle'
          }
        },
        behavior: {
          events: [{
            event: 'mousein',
            actions: [{
              element: 'self',
              method: 'set',
              args: {
                field: 'opacity',
                value: 90
              }
            }]
          }, {
            event: 'mouseout',
            actions: [{
              element: 'self',
              method: 'set',
              args: {
                field: 'opacity',
                value: 100
              }
            }]
          }]
        }
      },
      previewArea: {
        x: 0,
        y: 0,
        w: 140,
        h: 60,
        r: 0
      }
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      const W = item.area.w;
      const H = item.area.h;
      const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 2, item.area.h / 2);
      return `M ${W - R} ${H}  L ${R} ${H} a ${R} ${R} 0 0 1 ${-R} ${-R}  L 0 ${R}  a ${R} ${R} 0 0 1 ${R} ${-R}   L ${W - R} 0   a ${R} ${R} 0 0 1 ${R} ${R}  L ${W} ${H - R}   a ${R} ${R} 0 0 1 ${-R} ${R} Z`;
    },

    editorProps: {},
    controlPoints: {
      make(item) {
        return {
          cornerRadius: {
            x: Math.min(item.area.w, Math.max(item.area.w - item.shapeProps.cornerRadius, item.area.w / 2)),
            y: 0
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'cornerRadius') {
          item.shapeProps.cornerRadius = Math.max(0, _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].roundPrecise */ .Z.roundPrecise(item.area.w - Math.max(item.area.w / 2, originalX + dx), 1));
        }
      }

    },
    args: {
      cornerRadius: {
        type: 'number',
        value: 0,
        name: 'Corner radius',
        min: 0
      }
    }
  }
});

/***/ }),

/***/ 3363:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4486);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3674);
/* harmony import */ var lodash_keys__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_keys__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _myMath_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3590);
/* harmony import */ var _StandardCurves_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8270);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4691);
/* harmony import */ var _AdvancedFill_vue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6777);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */







const basicShapeGroup = (__webpack_require__(2291)/* ["default"] */ .Z);

let _shapes = [(__webpack_require__(1969)/* ["default"] */ .Z), (__webpack_require__(9831)/* ["default"] */ .Z), (__webpack_require__(8915)/* ["default"] */ .Z), (__webpack_require__(5664)/* ["default"] */ .Z), (__webpack_require__(3057)/* ["default"] */ .Z), (__webpack_require__(7533)/* ["default"] */ .Z), (__webpack_require__(6942)/* ["default"] */ .Z), (__webpack_require__(2709)/* ["default"] */ .Z), (__webpack_require__(1008)/* ["default"] */ .Z), (__webpack_require__(7025)/* ["default"] */ .Z), (__webpack_require__(9758)/* ["default"] */ .Z), (__webpack_require__(8148)/* ["default"] */ .Z), (__webpack_require__(3942)/* ["default"] */ .Z), (__webpack_require__(4310)/* ["default"] */ .Z), (__webpack_require__(2270)/* ["default"] */ .Z), (__webpack_require__(5198)/* ["default"] */ .Z), (__webpack_require__(2584)/* ["default"] */ .Z), (__webpack_require__(332)/* ["default"] */ .ZP), (__webpack_require__(8733)/* ["default"] */ .Z), (__webpack_require__(9078)/* ["default"] */ .Z), (__webpack_require__(1533)/* ["default"] */ .Z), (__webpack_require__(5845)/* ["default"] */ .Z), (__webpack_require__(5906)/* ["default"] */ .Z), (__webpack_require__(9699)/* ["default"] */ .Z), (__webpack_require__(3652)/* ["default"] */ .Z), (__webpack_require__(9880)/* ["default"] */ .Z), (__webpack_require__(4437)/* ["default"] */ .Z), (__webpack_require__(2517)/* ["default"] */ .Z), (__webpack_require__(4387)/* ["default"] */ .Z), (__webpack_require__(4358)/* ["default"] */ .Z), (__webpack_require__(7569)/* ["default"] */ .Z), (__webpack_require__(6852)/* ["default"] */ .Z), (__webpack_require__(7153)/* ["default"] */ .Z), (__webpack_require__(8396)/* ["default"] */ .Z), (__webpack_require__(3486)/* ["default"] */ .Z), (__webpack_require__(1693)/* ["default"] */ .Z), (__webpack_require__(958)/* ["default"] */ .Z), (__webpack_require__(5576)/* ["default"] */ .Z)];
_shapes = _shapes.concat(basicShapeGroup.shapes);

function defaultGetEventsFunc(item) {
  return [];
}

const defaultEditorProps = {
  description: 'rich',
  onlyEditMode: false,
  ignoreEventLayer: false,
  customTextRendering: false
};
const standardShapeProps = {
  fill: {
    name: 'Fill',
    type: 'advanced-color'
  },
  strokeColor: {
    name: 'Stroke',
    type: 'color'
  },
  strokeSize: {
    name: 'Stroke Size',
    type: 'number'
  },
  strokePattern: {
    name: 'Stroke Pattern',
    type: 'stroke-pattern'
  }
};

function defaultGetTextSlots(item) {
  return [{
    name: 'body',
    area: {
      x: 0,
      y: 0,
      w: item.area.w,
      h: item.area.h
    }
  }];
}

function defaultGetPins(item) {
  return [{
    x: item.area.w / 2,
    y: item.area.h / 2
  }];
}

function worldPointOnItem(x, y, item) {
  return _myMath_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"].worldPointInArea */ .Z.worldPointInArea(x, y, item.area, item.meta && item.meta.transformMatrix ? item.meta.transformMatrix : null);
}

function defaultGetSnappers(item) {
  const p1 = worldPointOnItem(0, 0, item);
  const p2 = worldPointOnItem(item.area.w, 0, item);
  const p3 = worldPointOnItem(item.area.w, item.area.h, item);
  const p4 = worldPointOnItem(0, item.area.h, item);
  const snappers = [];

  if (item.area.w > 0.0001) {
    if (Math.abs(p1.y - p2.y) < 0.0001) {
      snappers.push({
        item,
        snapperType: 'horizontal',
        value: p1.y
      });
    }

    if (Math.abs(p3.y - p4.y) < 0.0001) {
      snappers.push({
        item,
        snapperType: 'horizontal',
        value: p3.y
      });
    }

    if (Math.abs(p1.x - p4.x) < 0.0001) {
      snappers.push({
        item,
        snapperType: 'vertical',
        value: p1.x
      });
    }

    if (Math.abs(p2.x - p3.x) < 0.0001) {
      snappers.push({
        item,
        snapperType: 'vertical',
        value: p2.x
      });
    }
  }

  return snappers;
}

function enrichShape(shapeComponent, shapeName) {
  let shapeConfig = {};

  if (shapeComponent.shapeConfig) {
    shapeConfig = shapeComponent.shapeConfig;
  }

  if (!shapeConfig.shapeType) {
    console.error(`Missing shapeType for shape "${shapeName}"`);
  }

  const args = {};

  if (shapeConfig.shapeType === 'standard') {
    lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(standardShapeProps, (arg, argName) => {
      args[argName] = _utils_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].clone */ .Z.clone(arg);
    });
  }

  if (shapeConfig.args) {
    lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(shapeConfig.args, (arg, argName) => {
      args[argName] = _utils_js__WEBPACK_IMPORTED_MODULE_4__/* ["default"].clone */ .Z.clone(arg);

      if (arg.onUpdate) {
        args[argName].onUpdate = arg.onUpdate;
      }
    });
  }

  return {
    shapeType: shapeConfig.shapeType,
    editorProps: shapeConfig.editorProps || defaultEditorProps,
    args: args,
    computePath: shapeConfig.computePath,
    computeCurves: shapeConfig.computeCurves,
    computeOutline: shapeConfig.computeOutline || shapeConfig.computePath,
    readjustItem: shapeConfig.readjustItem,
    getTextSlots: shapeConfig.getTextSlots || defaultGetTextSlots,
    getEvents: shapeConfig.getEvents || defaultGetEventsFunc,
    controlPoints: shapeConfig.controlPoints || null,
    getPins: shapeConfig.getPins || defaultGetPins,
    shapeEvents: {
      beforeCreate: shapeConfig.beforeCreate,
      mounted: shapeConfig.mounted
    },
    // used for generating item snapers which are used for snapping dragged item to other items
    getSnappers: shapeConfig.getSnappers || defaultGetSnappers,
    vueComponent: shapeConfig.shapeType === 'vue' ? shapeComponent : null,
    menuItems: shapeConfig.menuItems || [],

    argType(argName) {
      if (this.args && this.args[argName]) {
        return this.args[argName].type;
      }

      if (this.shapeType === 'standard') {
        if (standardShapeProps[argName]) {
          return standardShapeProps[argName].type;
        }
      }

      return null;
    }

  };
}

const shapeRegistry = {};

function registerShape(shape) {
  if (!shape.shapeConfig.id) {
    return;
  }

  if (shape.shapeConfig.shapeType === 'raw') {
    registerRawShape(shape.shapeConfig.id, shape.shapeConfig);
  } else {
    shapeRegistry[shape.shapeConfig.id] = enrichShape(shape);
  }
}

function registerRawShape(shapeId, shapeConfig) {
  const shape = (0,_StandardCurves_js__WEBPACK_IMPORTED_MODULE_3__/* .convertStandardCurveShape */ .BM)(shapeConfig);
  shape.shapeConfig.id = shapeId;
  shapeRegistry[shapeId] = enrichShape(shape);
}

lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(_shapes, registerShape);

function getShapePropDescriptor(shape, propName) {
  if (shape.shapeType === 'standard') {
    if (standardShapeProps.hasOwnProperty(propName)) {
      return standardShapeProps[propName];
    }
  }

  if (shape.args && shape.args.hasOwnProperty(propName)) {
    return shape.args[propName];
  }

  return null;
}

function getRegistry() {
  return shapeRegistry;
}

function computeStandardCurves(item, shape) {
  if (shape.computeCurves) {
    return shape.computeCurves(item);
  } else if (shape.computePath) {
    return [{
      path: shape.computePath(item),
      fill: _AdvancedFill_vue__WEBPACK_IMPORTED_MODULE_5__/* ["default"].computeStandardFill */ .Z.computeStandardFill(item),
      strokeColor: item.shapeProps.strokeColor,
      strokeSize: item.shapeProps.strokeSize
    }];
  }
}

function getShapeArgs(shape) {
  if (shape.shapeType === 'standard') {
    const args = {};

    const copyArg = (arg, argName) => args[argName] = arg;

    lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(standardShapeProps, copyArg);
    lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(shape.args, copyArg);
    return args;
  }

  return shape.args;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  getShapeIds() {
    return lodash_keys__WEBPACK_IMPORTED_MODULE_1___default()(shapeRegistry);
  },

  find(id) {
    return shapeRegistry[id];
  },

  standardShapeProps,
  getShapePropDescriptor,
  getRegistry,
  computeStandardCurves,
  getShapeArgs,
  registerRawShape
});

/***/ }),

/***/ 9498:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": () => (/* binding */ getStandardRectPins)
/* harmony export */ });
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
function getStandardRectPins(item) {
  const w = item.area.w;
  const h = item.area.h;
  return [{
    x: w / 2,
    y: h / 2
  }, {
    x: w / 2,
    y: 0,
    nx: 0,
    ny: -1
  }, {
    x: w / 2,
    y: h,
    nx: 0,
    ny: 1
  }, {
    x: 0,
    y: h / 2,
    nx: -1,
    ny: 0
  }, {
    x: w,
    y: h / 2,
    nx: 1,
    ny: 0
  }];
}

/***/ }),

/***/ 8270:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FI": () => (/* binding */ computeCurvePath),
/* harmony export */   "Vk": () => (/* binding */ convertCurvePointToRelative),
/* harmony export */   "oJ": () => (/* binding */ convertCurvePointToItemScale),
/* harmony export */   "BM": () => (/* binding */ convertStandardCurveShape)
/* harmony export */ });
/* unused harmony exports PATH_POINT_CONVERSION_SCALE, convertRawShapeForRender */
/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5161);
/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_map__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4486);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _AdvancedFill_vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6777);
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3590);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





function round(value) {
  return _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].roundPrecise2 */ .Z.roundPrecise2(value);
}

const PATH_POINT_CONVERSION_SCALE = 100;

function connectArc(x1, y1, x2, y2, h) {
  const L = _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].distanceBetweenPoints */ .Z.distanceBetweenPoints(x1, y1, x2, y2);
  const H = L * h / 100;

  if (_myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].tooSmall */ .Z.tooSmall(H) || _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].tooSmall */ .Z.tooSmall(L)) {
    return `L ${round(x2)} ${round(y2)} `;
  }

  const r = Math.abs(H / 2 + L * L / (8 * H));
  let largeArcFlag = Math.abs(H) > L / 2 ? 1 : 0;
  let sweepFlag = h > 0 ? 1 : 0;
  return `A ${round(r)} ${round(r)} 0 ${largeArcFlag} ${sweepFlag} ${round(x2)} ${round(y2)}`;
}

function connectPoints(p1, p2) {
  if (p1.t === 'A') {
    return connectArc(p1.x, p1.y, p2.x, p2.y, p1.h);
  } else if (p1.t === 'L' && p2.t === 'B') {
    return `Q ${round(p2.x1 + p2.x)} ${round(p2.y1 + p2.y)} ${round(p2.x)} ${round(p2.y)} `;
  } else if (p1.t === 'B' && p2.t !== 'B') {
    return `Q ${round(p1.x2 + p1.x)} ${round(p1.y2 + p1.y)} ${round(p2.x)} ${round(p2.y)} `;
  } else if (p1.t === 'B' && p2.t === 'B') {
    return `C ${round(p1.x2 + p1.x)} ${round(p1.y2 + p1.y)} ${round(p2.x1 + p2.x)} ${round(p2.y1 + p2.y)} ${round(p2.x)} ${round(p2.y)} `;
  }

  return `L ${round(p2.x)} ${round(p2.y)} `;
}
/**
 * Computes a SVG path for given points and item area. All points should be relative to item width and height.
 * @param {*} areaWidth - width of item area
 * @param {*} areaHeight - height of item area
 * @param {*} points 
 * @param {*} closed 
 * @returns 
 */


function computeCurvePath(areaWidth, areaHeight, points, closed) {
  if (points.length < 2) {
    return null;
  }

  let path = '';
  let prevPoint = null;
  let firstPoint = null;
  lodash_forEach__WEBPACK_IMPORTED_MODULE_1___default()(points, rawPoint => {
    const point = convertCurvePointToItemScale(rawPoint, areaWidth, areaHeight);

    if (!firstPoint) {
      firstPoint = point;
    }

    if (!prevPoint) {
      path += `M ${round(point.x)} ${round(point.y)} `;
    } else {
      path += connectPoints(prevPoint, point);
    }

    prevPoint = point;
  });

  if (closed && prevPoint && firstPoint) {
    path += connectPoints(prevPoint, firstPoint);
    path += ' Z';
  }

  return path;
}
;
function convertCurvePointToRelative(point, w, h) {
  let W = 1,
      H = 1;

  if (_myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].tooSmall */ .Z.tooSmall(w)) {
    w = 1;
    W = 0;
  }

  if (_myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].tooSmall */ .Z.tooSmall(h)) {
    h = 1;
    H = 0;
  }

  if (point.t === 'B') {
    return {
      t: 'B',
      x: point.x * PATH_POINT_CONVERSION_SCALE * W / w,
      y: point.y * PATH_POINT_CONVERSION_SCALE * H / h,
      x1: point.x1 * PATH_POINT_CONVERSION_SCALE * W / w,
      y1: point.y1 * PATH_POINT_CONVERSION_SCALE * H / h,
      x2: point.x2 * PATH_POINT_CONVERSION_SCALE * W / w,
      y2: point.y2 * PATH_POINT_CONVERSION_SCALE * H / h
    };
  } else if (point.t === 'A') {
    return {
      t: point.t,
      x: point.x * PATH_POINT_CONVERSION_SCALE * W / w,
      y: point.y * PATH_POINT_CONVERSION_SCALE * H / h,
      h: point.h || 50 // this is needed to not generate an error for arcs from previous versions of schemio

    };
  } else {
    return {
      t: 'L',
      x: point.x * PATH_POINT_CONVERSION_SCALE * W / w,
      y: point.y * PATH_POINT_CONVERSION_SCALE * H / h
    };
  }
}
function convertCurvePointToItemScale(point, w, h) {
  if (point.t === 'B') {
    return {
      t: point.t,
      x: w * point.x / PATH_POINT_CONVERSION_SCALE,
      y: h * point.y / PATH_POINT_CONVERSION_SCALE,
      x1: w * point.x1 / PATH_POINT_CONVERSION_SCALE,
      y1: h * point.y1 / PATH_POINT_CONVERSION_SCALE,
      x2: w * point.x2 / PATH_POINT_CONVERSION_SCALE,
      y2: h * point.y2 / PATH_POINT_CONVERSION_SCALE
    };
  } else if (point.t === 'A') {
    return {
      t: point.t,
      x: w * point.x / PATH_POINT_CONVERSION_SCALE,
      y: h * point.y / PATH_POINT_CONVERSION_SCALE,
      h: point.h
    };
  } else {
    return {
      t: 'L',
      x: w * point.x / PATH_POINT_CONVERSION_SCALE,
      y: h * point.y / PATH_POINT_CONVERSION_SCALE
    };
  }
}

function createComputeOutlineFunc(shapeConfig) {
  return item => {
    if (shapeConfig.outlines && shapeConfig.outlines.length > 0) {
      let svgPath = '';
      lodash_forEach__WEBPACK_IMPORTED_MODULE_1___default()(shapeConfig.outlines, outlineDef => {
        const outlinePath = convertRawShapeToSvgPath(item, shapeConfig, outlineDef);

        if (outlinePath) {
          svgPath += outlinePath;
        }
      });
      return svgPath;
    } else {
      const w = item.area.w;
      const h = item.area.h;
      return `M  0 0 L ${w} 0 L ${w} ${h} L 0 ${h} Z`;
    }
  };
}

function convertRawPathShapeForRender(item, shapeConfig, itemDef) {
  let svgPath = '';
  lodash_forEach__WEBPACK_IMPORTED_MODULE_1___default()(itemDef.paths, pathDef => {
    const svgSegmentPath = computeCurvePath(item.area.w, item.area.h, pathDef.points, pathDef.closed);
    svgPath += svgSegmentPath + ' ';
  });
  return svgPath;
}

function projectPointToItemArea(x, y, item) {
  return {
    x: x * item.area.w / 100,
    y: y * item.area.h / 100
  };
}

function convertRawEllipseShapeForRender(item, shapeConfig, itemDef) {
  const {
    p0,
    pw,
    ph
  } = itemDef.projection;
  const pLeftX = (ph.x - p0.x) / 2 + p0.x;
  const pLeftY = (ph.y - p0.y) / 2 + p0.y;
  const pRightX = (ph.x - p0.x) / 2 + pw.x;
  const pRightY = (ph.y - p0.y) / 2 + pw.y;
  const Pl = projectPointToItemArea(pLeftX, pLeftY, item);
  const Pr = projectPointToItemArea(pRightX, pRightY, item);
  const Po = projectPointToItemArea(p0.x, p0.y, item);
  const Pw = projectPointToItemArea(pw.x, pw.y, item);
  const Ph = projectPointToItemArea(ph.x, ph.y, item);
  const rx = _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].distanceBetweenPoints */ .Z.distanceBetweenPoints(Pw.x, Pw.y, Po.x, Po.y) / 2;
  const ry = _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].distanceBetweenPoints */ .Z.distanceBetweenPoints(Ph.x, Ph.y, Po.x, Po.y) / 2;
  return `M ${Pl.x} ${Pl.y} A ${rx} ${ry} 0 1 1 ${Pr.x} ${Pr.y}  A ${rx} ${ry} 0 1 1 ${Pl.x} ${Pl.y} Z`;
}

function convertRawRectShapeForRender(item, shapeConfig, itemDef) {
  /*
      Vw
      --->
  Po                           Pw
  *    P1-----------------P2  *
     /                      \
    /                        \
  P0                         P3
  |          RECT             |      |
  |                           |      | Vh
  P7                         P4      V
   \                          /
    \                        /
  *  P6--------------------P5 *
  Ph                            Pwh
   */
  const {
    p0,
    pw,
    ph
  } = itemDef.projection;
  const Po = projectPointToItemArea(p0.x, p0.y, item);
  const Pw = projectPointToItemArea(pw.x, pw.y, item);
  const Ph = projectPointToItemArea(ph.x, ph.y, item);
  const w = _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].distanceBetweenPoints */ .Z.distanceBetweenPoints(Pw.x, Pw.y, Po.x, Po.y);
  const h = _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].distanceBetweenPoints */ .Z.distanceBetweenPoints(Ph.x, Ph.y, Po.x, Po.y);
  const R = Math.min(itemDef.cornerRadiusRatio.w * w, itemDef.cornerRadiusRatio.h * h, w / 2, h / 2);
  const Vw = _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizedVector */ .Z.normalizedVector(Pw.x - Po.x, Pw.y - Po.y);
  const Vh = _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].normalizedVector */ .Z.normalizedVector(Ph.x - Po.x, Ph.y - Po.y);

  if (!Vw || !Vh) {
    return '';
  }

  Vw.x = Vw.x * R;
  Vw.y = Vw.y * R;
  Vh.x = Vh.x * R;
  Vh.y = Vh.y * R;
  const Pwh = _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].vectorMinusVector */ .Z.vectorMinusVector(_myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].vectorPlusVector */ .Z.vectorPlusVector(Pw, Ph), Po);
  const points = [_myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].vectorPlusVector */ .Z.vectorPlusVector(Po, Vh), _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].vectorPlusVector */ .Z.vectorPlusVector(Po, Vw), _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].vectorMinusVector */ .Z.vectorMinusVector(Pw, Vw), _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].vectorPlusVector */ .Z.vectorPlusVector(Pw, Vh), _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].vectorMinusVector */ .Z.vectorMinusVector(Pwh, Vh), _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].vectorMinusVector */ .Z.vectorMinusVector(Pwh, Vw), _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].vectorPlusVector */ .Z.vectorPlusVector(Ph, Vw), _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].vectorMinusVector */ .Z.vectorMinusVector(Ph, Vh)];

  const arc = point => {
    return ` A ${R} ${R} 0 0 1 ${point.x} ${point.y}`;
  };

  const line = point => {
    return ` L ${point.x} ${point.y}`;
  };

  let path = `M ${points[0].x} ${points[0].y}`;

  for (let i = 1; i < points.length; i++) {
    if (i % 2 === 0) {
      path += line(points[i]);
    } else {
      path += arc(points[i]);
    }
  }

  return path + line(points[0]) + ' Z';
}

function convertRawShapeToSvgPath(item, shapeConfig, itemDef) {
  if (itemDef.type === 'path') {
    return convertRawPathShapeForRender(item, shapeConfig, itemDef);
  } else if (itemDef.type === 'ellipse') {
    return convertRawEllipseShapeForRender(item, shapeConfig, itemDef);
  } else if (itemDef.type === 'rect') {
    return convertRawRectShapeForRender(item, shapeConfig, itemDef);
  } else {
    console.error('Uknown raw shape type: ' + itemDef.type);
    return null;
  }
}

function convertRawShapeForRender(item, shapeConfig, itemDef) {
  const svgPath = convertRawShapeToSvgPath(item, shapeConfig, itemDef);

  if (!svgPath) {
    return null;
  }

  let fill = 'none';

  if (itemDef.fillArg === 'fill') {
    fill = _AdvancedFill_vue__WEBPACK_IMPORTED_MODULE_2__/* ["default"].computeStandardFill */ .Z.computeStandardFill(item);
  } else if (itemDef.fillArg === 'none') {
    fill = 'none';
  } else if (itemDef.fillArg) {
    const otherFill = item.shapeProps[itemDef.fillArg]; // for now advanced-color is not supported

    if (typeof otherFill === 'string') {
      fill = otherFill;
    }
  }

  return {
    path: svgPath,
    fill,
    strokeColor: item.shapeProps.strokeColor,
    strokeSize: _myMath__WEBPACK_IMPORTED_MODULE_3__/* ["default"].roundPrecise2 */ .Z.roundPrecise2(item.shapeProps.strokeSize * itemDef.strokeSize)
  };
}

function createComputeCurvesFunc(shapeConfig) {
  return item => {
    if (shapeConfig.items) {
      const computedPaths = [];
      lodash_forEach__WEBPACK_IMPORTED_MODULE_1___default()(shapeConfig.items, itemDef => {
        const p = convertRawShapeForRender(item, shapeConfig, itemDef);

        if (p) {
          computedPaths.push(p);
        }
      });
      return computedPaths;
    }

    return [];
  };
}

function createGetPinsFunc(shapeConfig) {
  return item => {
    if (shapeConfig.pins) {
      const w = item.area.w;
      const h = item.area.h;
      return lodash_map__WEBPACK_IMPORTED_MODULE_0___default()(shapeConfig.pins, pin => {
        const calculatedPin = {
          x: pin.x * w / 100,
          y: pin.y * h / 100
        };

        if (pin.hasOwnProperty('nx') && pin.hasOwnProperty('ny')) {
          calculatedPin.nx = pin.nx;
          calculatedPin.ny = pin.ny;
        }

        return calculatedPin;
      });
    } else {
      return [{
        x: item.area.w / 2,
        y: item.area.h / 2
      }];
    }
  };
}
/**
 * Takes shape definition JSON which is generated by shape exporter and converts it into a shape component
 * @param {Object} shapeConfig 
 */


function convertStandardCurveShape(shapeConfig) {
  return {
    shapeConfig: {
      id: shapeConfig.id,
      shapeType: 'standard',
      menuItems: shapeConfig.menuItems,
      computeOutline: createComputeOutlineFunc(shapeConfig),
      // raw do not use computePath function but instead they rely on computeCurves function
      // since each curve might have its own fill and stroke
      computeCurves: createComputeCurvesFunc(shapeConfig),
      getPins: createGetPinsFunc(shapeConfig),
      args: {
        fill: {
          type: 'advanced-color',
          value: {
            type: 'solid',
            color: 'rgba(255,255,255,1)'
          },
          name: 'Fill'
        },
        strokeColor: {
          type: 'color',
          value: '#111111',
          name: 'Stroke color'
        },
        strokePattern: {
          type: 'stroke-pattern',
          value: 'solid',
          name: 'Stroke pattern'
        },
        strokeSize: {
          type: 'number',
          value: 2,
          name: 'Stroke Size'
        }
      }
    }
  };
}

/***/ }),

/***/ 5198:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


function computePath(item) {
  const w = item.area.w;
  const h = item.area.h;
  return `M ${w / 2} 0  L ${w} ${h / 2}  L ${w / 2} ${h}  L 0 ${h / 2} Z`;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'basic_diamond',
    menuItems: [{
      group: 'Basic Shapes',
      name: 'Diamond',
      iconUrl: '/assets/images/items/basic-diamond.svg'
    }, {
      group: 'UML',
      name: 'Decision',
      iconUrl: '/assets/images/items/basic-diamond.svg'
    }],

    computePath(item) {
      return computePath(item);
    },

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_0__/* .getStandardRectPins */ .F)(item);
    },

    args: {}
  }
});

/***/ }),

/***/ 2270:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'basic_triangle',

    computePath(item) {
      const xs = item.area.w * item.shapeProps.skew / 100.0;
      return `M 0 ${item.area.h}  L ${xs} 0  L ${item.area.w} ${item.area.h} Z`;
    },

    controlPoints: {
      make(item) {
        return {
          skew: {
            x: item.area.w * item.shapeProps.skew / 100,
            y: 0
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'skew') {
          if (item.area.w > 0.01) {
            item.shapeProps.skew = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].roundPrecise1 */ .Z.roundPrecise1(_myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(100 * (originalX + dx) / item.area.w, 0, 100));
          }
        }
      }

    },

    getPins(item) {
      const s = item.area.w * item.shapeProps.skew / 100;
      return [{
        x: (s + item.area.w) / 3,
        y: item.area.h * 2 / 3
      }, {
        x: s,
        y: 0
      }, {
        x: item.area.w,
        y: item.area.h
      }, {
        x: 0,
        y: item.area.h
      }, {
        x: s / 2,
        y: item.area.h / 2
      }, {
        x: s + (item.area.w - s) / 2,
        y: item.area.h / 2
      }, {
        x: item.area.w / 2,
        y: item.area.h
      }];
    },

    menuItems: [{
      group: 'Basic Shapes',
      name: 'Triangle',
      iconUrl: '/assets/images/items/basic-triangle.svg',
      item: {
        textSlots: {
          body: {
            valign: 'bottom',
            halign: 'center'
          }
        },
        shapeProps: {
          skew: 50
        }
      }
    }, {
      group: 'Basic Shapes',
      name: 'Left Triangle',
      iconUrl: '/assets/images/items/basic-triangle-left.svg',
      item: {
        textSlots: {
          body: {
            valign: 'bottom',
            halign: 'center'
          }
        },
        shapeProps: {
          skew: 0
        }
      }
    }, {
      group: 'Basic Shapes',
      name: 'Right Triangle',
      iconUrl: '/assets/images/items/basic-triangle-right.svg',
      item: {
        textSlots: {
          body: {
            valign: 'bottom',
            halign: 'center'
          }
        },
        shapeProps: {
          skew: 100
        }
      }
    }],
    args: {
      skew: {
        type: 'number',
        value: 50,
        min: 0,
        max: 100,
        name: 'Skew (%)'
      }
    }
  }
});

/***/ }),

/***/ 2291:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "group": "Basic Shapes",
  "shapes": [{
    "name": "Cloud",
    "shapeConfig": {
      "shapeType": "raw",
      "pins": [],
      "textSlots": [],
      "items": [{
        "type": "path",
        "paths": [{
          "points": [{
            "t": "B",
            "x": 14.77777777777778,
            "y": 99.72727272727273,
            "x1": 20.511111111111102,
            "y1": -0.259090909090906,
            "x2": -4.005555555555556,
            "y2": -0.8272727272727242
          }, {
            "t": "B",
            "x": 1.7499999999999998,
            "y": 83.04545454545455,
            "x1": 2.2777777777777777,
            "y1": 9.240909090909097,
            "x2": -2.2777777777777777,
            "y2": -9.240909090909097
          }, {
            "t": "B",
            "x": 4.611111111111112,
            "y": 54.04545454545455,
            "x1": -3.386111111111111,
            "y1": 6.25,
            "x2": 3.3861111111111106,
            "y2": -6.25
          }, {
            "t": "B",
            "x": 20.333333333333332,
            "y": 44.27272727272727,
            "x1": -6.336111111111111,
            "y1": -2.840909090909091,
            "x2": -0.1305555555555592,
            "y2": -4.081818181818184
          }, {
            "t": "B",
            "x": 26,
            "y": 25.04545454545455,
            "x1": -4.972222222222223,
            "y1": 5.295454545454541,
            "x2": 4.972222222222223,
            "y2": -5.295454545454548
          }, {
            "t": "B",
            "x": 40.27777777777778,
            "y": 23.090909090909083,
            "x1": -5.336111111111114,
            "y1": -3.418181818181816,
            "x2": 1.7694444444444457,
            "y2": -3.999999999999999
          }, {
            "t": "B",
            "x": 51,
            "y": 4.454545454545455,
            "x1": -7.3555555555555605,
            "y1": 6.040909090909091,
            "x2": 7.3555555555555605,
            "y2": -6.040909090909091
          }, {
            "t": "B",
            "x": 73.50000000000001,
            "y": 6.136363636363637,
            "x1": -6.500000000000018,
            "y1": -6.818181818181818,
            "x2": 6.50000000000001,
            "y2": 6.818181818181818
          }, {
            "t": "B",
            "x": 83.91666666666666,
            "y": 44,
            "x1": 1.0555555555555587,
            "y1": -18.272727272727273,
            "x2": 2.388888888888895,
            "y2": 0.8181818181818169
          }, {
            "t": "B",
            "x": 96.86111111111113,
            "y": 56.136363636363626,
            "x1": -4.222222222222219,
            "y1": -10.863636363636365,
            "x2": 4.222222222222219,
            "y2": 10.863636363636372
          }, {
            "t": "B",
            "x": 93.5277777777778,
            "y": 92.9090909090909,
            "x1": 5.91666666666667,
            "y1": -6.681818181818176,
            "x2": -5.91666666666667,
            "y2": 6.681818181818176
          }, {
            "t": "L",
            "x": 83.91666666666666,
            "y": 99.72727272727273
          }],
          "closed": true
        }],
        "fillArg": "fill",
        "strokeSize": 1
      }],
      "outlines": [{
        "type": "path",
        "paths": [{
          "points": [{
            "t": "B",
            "x": 14.777777777777779,
            "y": 99.72272727272727,
            "x1": 20.51111111111111,
            "y1": -0.259090909090906,
            "x2": -4.005555555555556,
            "y2": -0.8272727272727242
          }, {
            "t": "B",
            "x": 1.7499999999999998,
            "y": 83.0409090909091,
            "x1": 2.2777777777777777,
            "y1": 9.240909090909083,
            "x2": -2.2777777777777777,
            "y2": -9.240909090909083
          }, {
            "t": "B",
            "x": 4.611111111111112,
            "y": 54.04090909090909,
            "x1": -3.386111111111112,
            "y1": 6.249999999999994,
            "x2": 3.3861111111111106,
            "y2": -6.25
          }, {
            "t": "B",
            "x": 20.333333333333332,
            "y": 44.268181818181816,
            "x1": -6.3361111111111095,
            "y1": -2.840909090909091,
            "x2": -0.13055555555555523,
            "y2": -4.081818181818184
          }, {
            "t": "B",
            "x": 26,
            "y": 25.04090909090909,
            "x1": -4.972222222222223,
            "y1": 5.295454545454548,
            "x2": 4.972222222222223,
            "y2": -5.295454545454544
          }, {
            "t": "B",
            "x": 40.27777777777778,
            "y": 23.086363636363636,
            "x1": -5.336111111111114,
            "y1": -3.4181818181818198,
            "x2": 1.7694444444444457,
            "y2": -4.000000000000002
          }, {
            "t": "B",
            "x": 51,
            "y": 4.449999999999999,
            "x1": -7.355555555555553,
            "y1": 6.040909090909091,
            "x2": 7.355555555555553,
            "y2": -6.040909090909091
          }, {
            "t": "B",
            "x": 73.50000000000001,
            "y": 6.131818181818181,
            "x1": -6.50000000000001,
            "y1": -6.818181818181818,
            "x2": 6.499999999999994,
            "y2": 6.818181818181818
          }, {
            "t": "B",
            "x": 83.91666666666666,
            "y": 43.99545454545454,
            "x1": 1.0555555555555587,
            "y1": -18.272727272727273,
            "x2": 2.388888888888895,
            "y2": 0.8181818181818169
          }, {
            "t": "B",
            "x": 96.86111111111113,
            "y": 56.13181818181818,
            "x1": -4.222222222222219,
            "y1": -10.86363636363636,
            "x2": 4.222222222222219,
            "y2": 10.86363636363636
          }, {
            "t": "B",
            "x": 93.5277777777778,
            "y": 92.90454545454546,
            "x1": 5.91666666666667,
            "y1": -6.681818181818176,
            "x2": -5.91666666666667,
            "y2": 6.681818181818176
          }, {
            "t": "L",
            "x": 83.91666666666666,
            "y": 99.72272727272727
          }],
          "closed": true
        }]
      }],
      "id": "basic_cloud",
      "menuItems": [{
        "group": "Basic Shapes",
        "name": "Cloud",
        "iconUrl": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNDIgMjUuNjY2NjY2NjY2NjY2NjY0IiB4bWw6c3BhY2U9InByZXNlcnZlIiB3aWR0aD0iNDJweCIgaGVpZ2h0PSIyNS42NjY2NjY2NjY2NjY2NjRweCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMywgMykiPjxwYXRoIGQ9Ik0gNS4zMiAxOS42MSBDIDMuODggMTkuNDUgMS40NSAxOC4xNSAwLjYzIDE2LjMzIEMgLTAuMTkgMTQuNTEgMC40NCAxMS44NiAxLjY2IDEwLjYzIEMgMi44OCA5LjQgNS4wNCA4LjE1IDcuMzIgOC43MSBDIDcuMjcgNy45IDcuNTcgNS45NyA5LjM2IDQuOTMgQyAxMS4xNSAzLjg4IDEyLjU4IDMuODcgMTQuNSA0LjU0IEMgMTUuMTQgMy43NSAxNS43MSAyLjA2IDE4LjM2IDAuODggQyAyMS4wMSAtMC4zMSAyNC4xMiAtMC4xMyAyNi40NiAxLjIxIEMgMjguOCAyLjU1IDMwLjU5IDUuMDYgMzAuMjEgOC42NSBDIDMxLjA3IDguODEgMzMuMzUgOC45IDM0Ljg3IDExLjA0IEMgMzYuMzkgMTMuMTggMzUuOCAxNi45NiAzMy42NyAxOC4yNyBRIDMxLjU0IDE5LjU5IDMwLjIxIDE5LjYxIFEgMTIuNyAxOS41NiA1LjMyIDE5LjYxICBaICIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjMTExMTExIiBzdHJva2Utd2lkdGg9IjJweCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvZz48L3N2Zz4=",
        "size": {
          "w": 80,
          "h": 48.9
        },
        "previewArea": {
          "x": 0,
          "y": 0,
          "w": 150,
          "h": 91.7,
          "r": 0
        }
      }]
    }
  }, {
    "name": "Star",
    "shapeConfig": {
      "shapeType": "raw",
      "pins": [],
      "textSlots": [],
      "items": [{
        "type": "path",
        "paths": [{
          "points": [{
            "t": "L",
            "x": 50,
            "y": 0
          }, {
            "t": "L",
            "x": 59.59,
            "y": 26.92
          }, {
            "t": "L",
            "x": 85.35000000000002,
            "y": 14.65
          }, {
            "t": "L",
            "x": 73.10000000000002,
            "y": 40.45
          }, {
            "t": "L",
            "x": 100,
            "y": 50
          }, {
            "t": "L",
            "x": 73.10000000000002,
            "y": 59.55
          }, {
            "t": "L",
            "x": 85.35000000000002,
            "y": 85.35
          }, {
            "t": "L",
            "x": 59.56,
            "y": 73.10000000000001
          }, {
            "t": "L",
            "x": 50,
            "y": 100
          }, {
            "t": "L",
            "x": 40.45000000000002,
            "y": 73.10000000000001
          }, {
            "t": "L",
            "x": 14.650000000000004,
            "y": 85.35
          }, {
            "t": "L",
            "x": 26.900000000000006,
            "y": 59.55
          }, {
            "t": "L",
            "x": 0,
            "y": 50
          }, {
            "t": "L",
            "x": 26.900000000000006,
            "y": 40.45
          }, {
            "t": "L",
            "x": 14.650000000000004,
            "y": 14.65
          }, {
            "t": "L",
            "x": 40.45000000000002,
            "y": 26.9
          }],
          "closed": true
        }],
        "fillArg": "fill",
        "strokeSize": 1
      }],
      "outlines": [{
        "type": "path",
        "paths": [{
          "points": [{
            "t": "L",
            "x": 50,
            "y": 0
          }, {
            "t": "L",
            "x": 59.59,
            "y": 26.92
          }, {
            "t": "L",
            "x": 85.35000000000002,
            "y": 14.65
          }, {
            "t": "L",
            "x": 73.10000000000002,
            "y": 40.45
          }, {
            "t": "L",
            "x": 100,
            "y": 50
          }, {
            "t": "L",
            "x": 73.10000000000002,
            "y": 59.55
          }, {
            "t": "L",
            "x": 85.35000000000002,
            "y": 85.35
          }, {
            "t": "L",
            "x": 59.56,
            "y": 73.10000000000001
          }, {
            "t": "L",
            "x": 50,
            "y": 100
          }, {
            "t": "L",
            "x": 40.45000000000002,
            "y": 73.10000000000001
          }, {
            "t": "L",
            "x": 14.650000000000004,
            "y": 85.35
          }, {
            "t": "L",
            "x": 26.900000000000006,
            "y": 59.55
          }, {
            "t": "L",
            "x": 0,
            "y": 50
          }, {
            "t": "L",
            "x": 26.900000000000006,
            "y": 40.45
          }, {
            "t": "L",
            "x": 14.650000000000004,
            "y": 14.65
          }, {
            "t": "L",
            "x": 40.45000000000002,
            "y": 26.9
          }],
          "closed": true
        }]
      }],
      "id": "basic_star",
      "menuItems": [{
        "group": "Basic Shapes",
        "name": "Star",
        "iconUrl": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMzIgMzIiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSIzMnB4IiBoZWlnaHQ9IjMycHgiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDMsIDMpIj48cGF0aCBkPSJNIDEzIDAgTCAxNS40OSA3IEwgMjIuMTkgMy44MSBMIDE5LjAxIDEwLjUyIEwgMjYgMTMgTCAxOS4wMSAxNS40OCBMIDIyLjE5IDIyLjE5IEwgMTUuNDkgMTkuMDEgTCAxMyAyNiBMIDEwLjUyIDE5LjAxIEwgMy44MSAyMi4xOSBMIDYuOTkgMTUuNDggTCAwIDEzIEwgNi45OSAxMC41MiBMIDMuODEgMy44MSBMIDEwLjUyIDYuOTkgTCAxMyAwICBaICIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjMTExMTExIiBzdHJva2Utd2lkdGg9IjJweCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvZz48L3N2Zz4=",
        "size": {
          "w": 80,
          "h": 80
        },
        "previewArea": {
          "x": 0,
          "y": 0,
          "w": 150,
          "h": 150,
          "r": 0
        }
      }]
    }
  }],
  "preview": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSItMTAgLTEwIDIyMCAxMjAiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSIyMzBweCIgaGVpZ2h0PSIxMzBweCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMTUuNTU1NTU1NTU1NTU1NTU3KSI+PHBhdGggZD0iTSAxMS44MiA0OC43NiBDIDguNjIgNDguMzUgMy4yMiA0NS4xMiAxLjQgNDAuNiBDIC0wLjQyIDM2LjA4IDAuOTggMjkuNDggMy42OSAyNi40MiBDIDYuNCAyMy4zNyAxMS4yIDIwLjI2IDE2LjI3IDIxLjY0IEMgMTYuMTYgMTkuNjUgMTYuODIgMTQuODMgMjAuOCAxMi4yNCBDIDI0Ljc4IDkuNjYgMjcuOTUgOS42MiAzMi4yMiAxMS4yOSBDIDMzLjY0IDkuMzMgMzQuOTIgNS4xMyA0MC44IDIuMTggQyA0Ni42OCAtMC43OCA1My42IC0wLjMzIDU4LjggMyBDIDY0IDYuMzMgNjcuOTggMTIuNTggNjcuMTMgMjEuNTEgQyA2OS4wNCAyMS45MSA3NC4xMSAyMi4xMyA3Ny40OSAyNy40NCBDIDgwLjg3IDMyLjc2IDc5LjU2IDQyLjE2IDc0LjgyIDQ1LjQyIFEgNzAuMDkgNDguNjkgNjcuMTMgNDguNzYgUSAyOC4yMyA0OC42MyAxMS44MiA0OC43NiAgWiAiIGZpbGw9IiNmZmZmZmYiIHN0cm9rZT0iIzExMTExMSIgc3Ryb2tlLXdpZHRoPSIycHgiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAwLCAwKSI+PHBhdGggZD0iTSA0MCAwIEwgNDcuNjcgMjEuNTQgTCA2OC4yOCAxMS43MiBMIDU4LjQ4IDMyLjM2IEwgODAgNDAgTCA1OC40OCA0Ny42NCBMIDY4LjI4IDY4LjI4IEwgNDcuNjUgNTguNDggTCA0MCA4MCBMIDMyLjM2IDU4LjQ4IEwgMTEuNzIgNjguMjggTCAyMS41MiA0Ny42NCBMIDAgNDAgTCAyMS41MiAzMi4zNiBMIDExLjcyIDExLjcyIEwgMzIuMzYgMjEuNTIgTCA0MCAwICBaICIgZmlsbD0iI2ZmZmZmZiIgc3Ryb2tlPSIjMTExMTExIiBzdHJva2Utd2lkdGg9IjJweCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIvPjwvZz48L3N2Zz4="
});

/***/ }),

/***/ 9078:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



function calculateNameLineTop(item) {
  return _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(_myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].roundPrecise1 */ .Z.roundPrecise1(Math.max(item.shapeProps.headerHeight, item.shapeProps.cornerRadius)), 0, item.area.h);
}

function calculateSectionLineTop(item, nameLineTop) {
  return _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(_myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].roundPrecise1 */ .Z.roundPrecise1((item.area.h - nameLineTop) * Math.max(item.shapeProps.sectionRatio, 10) / 100 + nameLineTop), 0, item.area.h);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_class',
    menuItems: [{
      group: 'UML',
      name: 'Class',
      iconUrl: '/assets/images/items/uml-class.svg',
      item: {
        textSlots: {
          title: {
            text: '<b>Class</b>',
            fontSize: 16,
            halign: 'center',
            valign: 'middle',
            paddingLeft: 0,
            paddingTop: 0,
            paddingRight: 0,
            paddingBottom: 0
          },
          section1: {
            text: '',
            fontSize: 14,
            font: 'Courier New',
            halign: 'left',
            valign: 'top',
            paddingLeft: 5,
            paddingTop: 5,
            paddingRight: 5,
            paddingBottom: 5
          },
          section2: {
            text: '',
            fontSize: 14,
            font: 'Courier New',
            halign: 'left',
            valign: 'top',
            paddingLeft: 5,
            paddingTop: 5,
            paddingRight: 5,
            paddingBottom: 5
          }
        }
      },
      size: {
        w: 140,
        h: 100
      }
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      const W = item.area.w;
      const H = item.area.h;
      const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 4, item.area.h / 4);
      const nameLineTop = calculateNameLineTop(item);
      const sectionLineTop = calculateSectionLineTop(item, nameLineTop);
      return `M ${W - R} ${H}  L ${R} ${H} a ${R} ${R} 0 0 1 ${-R} ${-R}  ` + `L 0 ${R}  a ${R} ${R} 0 0 1 ${R} ${-R}  ` + `L ${W - R} 0   a ${R} ${R} 0 0 1 ${R} ${R}  ` + `L ${W} ${H - R}   a ${R} ${R} 0 0 1 ${-R} ${R} Z` + `M 0 ${nameLineTop} l ${W} 0` + `M 0 ${sectionLineTop} l ${W} 0`;
    },

    computeOutline(item) {
      const W = item.area.w;
      const H = item.area.h;
      const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 4, item.area.h / 4);
      return `M ${W - R} ${H}  L ${R} ${H} a ${R} ${R} 0 0 1 ${-R} ${-R}  ` + `L 0 ${R}  a ${R} ${R} 0 0 1 ${R} ${-R}  ` + `L ${W - R} 0   a ${R} ${R} 0 0 1 ${R} ${R}  ` + `L ${W} ${H - R}   a ${R} ${R} 0 0 1 ${-R} ${R} Z`;
    },

    getTextSlots(item) {
      const nameLineTop = calculateNameLineTop(item);
      const sectionLineTop = calculateSectionLineTop(item, nameLineTop);
      return [{
        name: 'title',
        area: {
          x: 0,
          y: 0,
          w: item.area.w,
          h: nameLineTop
        }
      }, {
        name: 'section1',
        area: {
          x: 0,
          y: nameLineTop,
          w: item.area.w,
          h: sectionLineTop - nameLineTop
        }
      }, {
        name: 'section2',
        area: {
          x: 0,
          y: sectionLineTop,
          w: item.area.w,
          h: item.area.h - sectionLineTop
        }
      }];
    },

    controlPoints: {
      make(item) {
        return {
          sectionRatio: {
            x: item.area.w / 2,
            y: calculateSectionLineTop(item, calculateNameLineTop(item))
          },
          headerHeight: {
            x: item.area.w / 2,
            y: item.shapeProps.headerHeight
          },
          cornerRadius: {
            x: item.area.w - item.shapeProps.cornerRadius,
            y: 0
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'headerHeight') {
          item.shapeProps.headerHeight = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(_myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].roundPrecise1 */ .Z.roundPrecise1(originalY + dy), 0, item.area.h);
        } else if (controlPointName === 'cornerRadius') {
          item.shapeProps.cornerRadius = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(_myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].roundPrecise1 */ .Z.roundPrecise1(item.area.w - originalX - dx), 0, Math.min(item.area.w / 4, item.area.h / 4));
        } else if (controlPointName === 'sectionRatio') {
          const nameLineTop = calculateNameLineTop(item);
          const bodyHeight = Math.max(0, item.area.h - nameLineTop);

          if (bodyHeight > 0) {
            item.shapeProps.sectionRatio = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(_myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].roundPrecise1 */ .Z.roundPrecise1(Math.max(0, originalY + dy - nameLineTop) * 100 / bodyHeight), 0, 100);
          }
        }
      }

    },
    args: {
      cornerRadius: {
        type: 'number',
        value: '0',
        name: 'Corner radius'
      },
      headerHeight: {
        type: 'number',
        value: 30,
        name: 'Header Height'
      },
      sectionRatio: {
        type: 'number',
        value: 50,
        name: 'Section Ratio (%)',
        min: 0,
        max: 100
      }
    }
  }
});

/***/ }),

/***/ 2517:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


const maxSkewRatioToHeight = 3;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_database',
    menuItems: [{
      group: 'UML',
      name: 'Database',
      iconUrl: '/assets/images/items/uml-database.svg',
      size: {
        w: 100,
        h: 130
      }
    }],

    computePath(item) {
      const w = item.area.w,
            h = item.area.h,
            s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.h / maxSkewRatioToHeight),
            d = s / 2,
            k = item.area.w / 4,
            cx = w / 2;
      return `M ${w} ${s} L ${w} ${h - s} C ${w} ${h - d}  ${w - k} ${h} ${cx} ${h} C ${k} ${h} 0 ${h - d} ${0} ${h - s} L ${0} ${s}` + `C ${0} ${d} ${k} 0 ${cx} 0  C ${w - k} 0 ${w} ${d} ${w} ${s}` + `C ${w} ${s + d} ${w - k} ${2 * s} ${cx} ${2 * s} C ${k} ${2 * s} ${0} ${s + d} ${0} ${s}`;
    },

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__/* .getStandardRectPins */ .F)(item);
    },

    computeOutline(item) {
      const w = item.area.w,
            h = item.area.h,
            s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.h / maxSkewRatioToHeight),
            d = s / 2,
            k = item.area.w / 4,
            cx = w / 2;
      return `M ${w} ${s} L ${w} ${h - s} C ${w} ${h - d}  ${w - k} ${h} ${cx} ${h} C ${k} ${h} ${0} ${h - d} ${0} ${h - s} L ${0} ${s}` + `C ${0} ${d} ${k} 0 ${cx} 0  C ${w - k} 0 ${w} ${d} ${w} ${s}`;
    },

    controlPoints: {
      make(item) {
        return {
          skew: {
            x: item.area.w / 2,
            y: _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.h / maxSkewRatioToHeight) * 2
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'skew') {
          item.shapeProps.skew = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp((originalY + dy) / 2, 0, item.area.h / maxSkewRatioToHeight);
        }
      }

    },
    args: {
      skew: {
        type: 'number',
        value: 20,
        name: 'Skew'
      }
    }
  }
});

/***/ }),

/***/ 4437:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


const maxSkewRatioToHeight = 3;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_dataflow',
    menuItems: [{
      group: 'UML',
      name: 'Data Flow',
      iconUrl: '/assets/images/items/uml-dataflow.svg'
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      const w = item.area.w,
            h = item.area.h,
            s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.w / maxSkewRatioToHeight),
            d = s / 2,
            k = item.area.h / 4,
            cy = h / 2;
      return `M ${w - s} ${h} L ${s} ${h}  Q 0 ${h - k} 0 ${cy}  Q 0 ${k} ${s} 0 L ${w - s} 0 Q ${w} ${k} ${w} ${cy} Q ${w} ${h - k} ${w - s} ${h} Q ${w - 2 * s} ${h - k} ${w - 2 * s} ${cy} Q ${w - 2 * s} ${k} ${w - s} 0`;
    },

    computeOutline(item) {
      const w = item.area.w,
            h = item.area.h,
            s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.w / maxSkewRatioToHeight),
            d = s / 2,
            k = item.area.h / 4,
            cy = h / 2;
      return `M ${w - s} ${h} L ${s} ${h}  Q 0 ${h - k} 0 ${cy}  Q 0 ${k} ${s} 0 L ${w - s} 0 Q ${w} ${k} ${w} ${cy} Q ${w} ${h - k} ${w - s} ${h}`;
    },

    controlPoints: {
      make(item) {
        return {
          skew: {
            x: item.area.w - _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.w / maxSkewRatioToHeight) * 2,
            y: item.area.h / 2
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'skew') {
          item.shapeProps.skew = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp((item.area.w - originalX - dx) / 2, 0, item.area.w / maxSkewRatioToHeight);
        }
      }

    },
    args: {
      skew: {
        type: 'number',
        value: 20,
        name: 'Skew'
      }
    }
  }
});

/***/ }),

/***/ 4387:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



function computePath(item) {
  const w = item.area.w;
  const h = item.area.h;
  const r = item.area.h / 2;
  const x2 = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(w - r, 0);
  const r2 = Math.min(r, w - x2);
  return `M 0 0 L ${x2} 0 A ${r2} ${r} 0 0 1 ${x2} ${h} L 0 ${h} Z`;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_delay',
    menuItems: [{
      group: 'UML',
      name: 'Delay',
      iconUrl: '/assets/images/items/uml-delay.svg'
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      return computePath(item);
    },

    args: {}
  }
});

/***/ }),

/***/ 9880:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
function computePath(item) {
  const d = item.area.h / 8;
  const w = item.area.w;
  const h = item.area.h - d;
  const k = h / 2;
  return `M 0 0 L ${w} 0 L ${w} ${h} C ${w / 2} ${h - k} ${w / 2} ${h + k} 0 ${h} Z`;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_document',
    menuItems: [{
      group: 'UML',
      name: 'Document',
      iconUrl: '/assets/images/items/uml-document.svg',
      size: {
        w: 140,
        h: 100
      }
    }],

    getPins(item) {
      const d = item.area.h / 8;
      const w = item.area.w;
      const h = item.area.h - d;
      const k = h / 2;
      return [{
        x: w / 2,
        y: h / 2
      }, {
        x: w / 2,
        y: 0,
        nx: 0,
        ny: -1
      }, {
        x: w / 2,
        y: h,
        nx: 0,
        ny: 1
      }, {
        x: 0,
        y: h / 2,
        nx: -1,
        ny: 0
      }, {
        x: w,
        y: h / 2,
        nx: 1,
        ny: 0
      }];
    },

    computePath(item) {
      return computePath(item);
    },

    args: {}
  }
});

/***/ }),

/***/ 3652:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


function computePath(item) {
  const w = item.area.w;
  const h = item.area.h;
  const s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, w / 2);
  return `M ${s} 0 L ${w} 0 L ${w - s} ${h} L 0 ${h} Z`;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_input',
    menuItems: [{
      group: 'UML',
      name: 'Input/Output',
      iconUrl: '/assets/images/items/uml-input.svg',
      size: {
        w: 140,
        h: 100
      }
    }],

    getPins(item) {
      const w = item.area.w;
      const h = item.area.h;
      const s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.w / 2);
      return [{
        x: w / 2,
        y: h / 2
      }, {
        x: w / 2,
        y: 0,
        nx: 0,
        ny: -1
      }, {
        x: w / 2,
        y: h,
        nx: 0,
        ny: 1
      }, {
        x: s / 2,
        y: h / 2,
        nx: -1,
        ny: 0
      }, {
        x: w - s / 2,
        y: h / 2,
        nx: 1,
        ny: 0
      }];
    },

    computePath(item) {
      return computePath(item);
    },

    computeOutline(item) {
      return computePath(item);
    },

    controlPoints: {
      make(item) {
        return {
          skew: {
            x: _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.w / 2),
            y: 0
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'skew') {
          item.shapeProps.skew = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(originalX + dx, 0, item.area.w / 2);
        }
      }

    },
    args: {
      skew: {
        type: 'number',
        value: 20,
        name: 'Skew'
      }
    }
  }
});

/***/ }),

/***/ 7569:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



function computePath(item) {
  const w = item.area.w;
  const h = item.area.h;
  const s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, Math.min(w / 4, h / 2));
  return `M ${s} 0 L ${w - s} 0 L ${w} ${s} L ${w} ${h} L 0 ${h} L 0 ${s} Z`;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_loop_limit',
    menuItems: [{
      group: 'UML',
      name: 'Loop Limit',
      iconUrl: '/assets/images/items/uml-loop-limit.svg'
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      return computePath(item);
    },

    controlPoints: {
      make(item) {
        return {
          skew: {
            x: item.area.w - _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, Math.min(item.area.w / 4, item.area.h / 2)),
            y: 0
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'skew') {
          item.shapeProps.skew = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.area.w - originalX - dx, 0, Math.min(item.area.w / 4, item.area.h / 2));
        }
      }

    },
    args: {
      skew: {
        type: 'number',
        value: 20,
        name: 'Skew'
      }
    }
  }
});

/***/ }),

/***/ 1533:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_module',
    menuItems: [{
      group: 'UML',
      name: 'Module',
      iconUrl: '/assets/images/items/uml-module.svg',
      item: {
        textSlots: {
          title: {
            text: '<b>Module</b>',
            halign: 'center'
          },
          body: {
            text: '',
            halign: 'left'
          }
        }
      },
      size: {
        w: 140,
        h: 100
      }
    }],
    controlPoints: {
      make(item) {
        return {
          brick: {
            x: Math.min(item.shapeProps.brickWidth, item.area.w / 2),
            y: _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.brickHeight, 0, item.area.h) * 4
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'brick') {
          item.shapeProps.brickWidth = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(originalX + dx, 0, item.area.w / 2);
          item.shapeProps.brickHeight = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp((originalY + dy) / 4, 0, item.area.h / 4);
        }
      }

    },

    getPins(item) {
      const bw = Math.min(item.shapeProps.brickWidth, item.area.w / 2) / 2;
      const w = item.area.w;
      const h = item.area.h;
      const W = item.area.w - bw;
      return [{
        x: bw + W / 2,
        y: h / 2
      }, {
        x: bw + W / 2,
        y: 0,
        nx: 0,
        ny: -1
      }, {
        x: bw + W / 2,
        y: h,
        nx: 0,
        ny: 1
      }, {
        x: bw,
        y: h / 2,
        nx: -1,
        ny: 0
      }, {
        x: w,
        y: h / 2,
        nx: 1,
        ny: 0
      }];
    },

    computePath(item) {
      const W = item.area.w;
      const H = item.area.h;
      const w = Math.min(item.shapeProps.brickWidth, item.area.w / 2);
      const h = Math.min(item.shapeProps.brickHeight, item.area.h / 4);
      const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 4, item.area.h / 4, h, w);
      return `M ${W - R} ${H}  L ${w / 2 + R} ${H} ` + `a ${R} ${R} 0 0 1 ${-R} ${-R} ` + `L ${w / 2} ${4 * h} L ${w} ${4 * h} L ${w} ${3 * h} L ${w / 2} ${3 * h} L ${w / 2} ${2 * h} L ${w} ${2 * h} L ${w} ${h} L ${w / 2} ${h} L ${w / 2} ${R}` + `a ${R} ${R} 0 0 1 ${R} ${-R}   ` + `L ${W - R} 0   a ${R} ${R} 0 0 1 ${R} ${R}  L ${W} ${H - R}   a ${R} ${R} 0 0 1 ${-R} ${R} Z` + `M 0 ${h} l ${w} 0  l 0 ${h} l ${-w} 0 Z` + `M 0 ${3 * h} l ${w} 0  l 0 ${h} l ${-w} 0 Z`;
    },

    computeOutline(item) {
      const W = item.area.w;
      const H = item.area.h;
      const w = Math.min(item.shapeProps.brickWidth, item.area.w / 2);
      const h = Math.min(item.shapeProps.brickHeight, item.area.h / 4);
      const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 4, item.area.h / 4, h, w);
      return `M ${W - R} ${H}  L ${w / 2 + R} ${H} ` + `a ${R} ${R} 0 0 1 ${-R} ${-R} ` + `L ${w / 2} ${4 * h} L 0 ${4 * h} L 0 ${3 * h} L ${w / 2} ${3 * h} L ${w / 2} ${2 * h} L 0 ${2 * h} L 0 ${h} L ${w / 2} ${h} L ${w / 2} ${R}` + `a ${R} ${R} 0 0 1 ${R} ${-R}   ` + `L ${W - R} 0   a ${R} ${R} 0 0 1 ${R} ${R}  L ${W} ${H - R}   a ${R} ${R} 0 0 1 ${-R} ${R} Z`;
    },

    getTextSlots(item) {
      const w = Math.max(item.shapeProps.brickWidth, 0);
      return [{
        name: 'body',
        area: {
          x: w,
          y: 0,
          w: Math.max(0, item.area.w - w),
          h: item.area.h
        }
      }];
    },

    args: {
      cornerRadius: {
        type: 'number',
        value: '0',
        name: 'Corner radius'
      },
      brickWidth: {
        type: 'number',
        value: '70',
        name: 'Brick Width'
      },
      brickHeight: {
        type: 'number',
        value: '20',
        name: 'Brick Height'
      }
    }
  }
});

/***/ }),

/***/ 5906:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



const calculateD = item => {
  let D = item.shapeProps.depth;
  const minD = Math.min(item.area.w, item.area.h) / 2;

  if (D > minD) {
    D = minD;
  }

  return D;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_node',
    menuItems: [{
      group: 'UML',
      name: 'Node',
      iconUrl: '/assets/images/items/uml-node.svg',
      size: {
        w: 140,
        h: 100
      }
    }],
    controlPoints: {
      make(item) {
        const D = calculateD(item);
        return {
          depth: {
            x: _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.area.w - D, 0, item.area.w),
            y: _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(D, 0, item.area.h)
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'depth') {
          item.shapeProps.depth = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(originalY + dy, 0, Math.min(item.area.w, item.area.h) / 2);
        }
      }

    },

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__/* .getStandardRectPins */ .F)(item);
    },

    getTextSlots(item) {
      const D = calculateD(item);
      return [{
        name: 'body',
        area: {
          x: 0,
          y: D,
          w: item.area.w - D,
          h: item.area.h - D
        }
      }];
    },

    computePath(item) {
      const W = item.area.w;
      const H = item.area.h;
      const D = calculateD(item);
      return `M 0 ${D}  L ${W - D} ${D}  L ${W - D} ${H} L 0 ${H} Z` + `M 0 ${D} L ${D} 0 L ${W} 0 L ${W - D} ${D} Z` + `M ${W - D} ${D} L ${W} 0 L ${W} ${H - D} L ${W - D} ${H} Z`;
    },

    computeOutline(item) {
      const W = item.area.w;
      const H = item.area.h;
      const D = calculateD(item);
      return `M 0 ${D}  L ${D} 0  L ${W} 0  L ${W} ${H - D} L ${W - D} ${H} L 0 ${H} Z`;
    },

    args: {
      depth: {
        type: 'number',
        value: 20,
        name: 'Depth'
      }
    }
  }
});

/***/ }),

/***/ 6852:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


const maxSkewRatio = 2;

function computePath(item) {
  const w = item.area.w;
  const h = item.area.h;
  const s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, Math.min(w / maxSkewRatio, h / maxSkewRatio));
  return `M ${w} ${s} L ${w} ${h} L 0 ${h} L 0 0 L ${w - s} 0 L ${w} ${s} L ${w - s} ${s} L ${w - s} 0`;
}

function computeOutline(item) {
  const w = item.area.w;
  const h = item.area.h;
  const s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, Math.min(w / maxSkewRatio, h / maxSkewRatio));
  return `M ${w} ${s} L ${w} ${h} L 0 ${h} L 0 0 L ${w - s} 0 Z`;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_note',
    menuItems: [{
      group: 'UML',
      name: 'Note',
      iconUrl: '/assets/images/items/uml-note.svg'
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      return computePath(item);
    },

    computeOutline(item) {
      return computeOutline(item);
    },

    controlPoints: {
      make(item) {
        const s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, Math.min(item.area.w / maxSkewRatio, item.area.h / maxSkewRatio));
        return {
          skew: {
            x: item.area.w - s,
            y: s
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        const sx = item.area.w - originalX - dx;
        const sy = originalY + dy;

        if (controlPointName === 'skew') {
          item.shapeProps.skew = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(Math.max(sx, sy), 0, Math.min(item.area.w / maxSkewRatio, item.area.h / maxSkewRatio));
        }
      }

    },
    args: {
      skew: {
        type: 'number',
        value: 20,
        name: 'Skew'
      }
    }
  }
});

/***/ }),

/***/ 8733:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_object',
    menuItems: [{
      group: 'UML',
      name: 'Object',
      iconUrl: '/assets/images/items/uml-object.svg',
      item: {
        textSlots: {
          title: {
            text: '<b>Object</b>',
            fontSize: 16,
            halign: 'center',
            valign: 'middle',
            paddingLeft: 0,
            paddingTop: 0,
            paddingRight: 0,
            paddingBottom: 0
          },
          body: {
            text: '',
            fontSize: 14,
            font: 'Courier New',
            halign: 'left',
            valign: 'top',
            paddingLeft: 5,
            paddingTop: 5,
            paddingRight: 5,
            paddingBottom: 5
          }
        }
      },
      size: {
        w: 140,
        h: 100
      }
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      const W = item.area.w;
      const H = item.area.h;
      const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 4, item.area.h / 4);
      const nameLineTop = Math.min(item.area.h, Math.max(item.shapeProps.headerHeight, item.shapeProps.cornerRadius));
      return `M ${W - R} ${H}  L ${R} ${H} a ${R} ${R} 0 0 1 ${-R} ${-R}  ` + `L 0 ${R}  a ${R} ${R} 0 0 1 ${R} ${-R}  ` + `L ${W - R} 0   a ${R} ${R} 0 0 1 ${R} ${R}  ` + `L ${W} ${H - R}   a ${R} ${R} 0 0 1 ${-R} ${R} Z` + `M 0 ${nameLineTop} l ${W} 0`;
    },

    computeOutline(item) {
      const W = item.area.w;
      const H = item.area.h;
      const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 4, item.area.h / 4);
      return `M ${W - R} ${H}  L ${R} ${H} a ${R} ${R} 0 0 1 ${-R} ${-R}  ` + `L 0 ${R}  a ${R} ${R} 0 0 1 ${R} ${-R}  ` + `L ${W - R} 0   a ${R} ${R} 0 0 1 ${R} ${R}  ` + `L ${W} ${H - R}   a ${R} ${R} 0 0 1 ${-R} ${R} Z`;
    },

    getTextSlots(item) {
      return [{
        name: 'title',
        area: {
          x: 0,
          y: 0,
          w: item.area.w,
          h: item.shapeProps.headerHeight
        }
      }, {
        name: 'body',
        area: {
          x: 0,
          y: item.shapeProps.headerHeight,
          w: item.area.w,
          h: Math.max(10, item.area.h - item.shapeProps.headerHeight)
        }
      }];
    },

    controlPoints: {
      make(item) {
        return {
          headerHeight: {
            x: item.area.w / 2,
            y: item.shapeProps.headerHeight
          },
          cornerRadius: {
            x: item.area.w - item.shapeProps.cornerRadius,
            y: 0
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'headerHeight') {
          item.shapeProps.headerHeight = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(originalY + dy, 0, item.area.h);
        } else if (controlPointName === 'cornerRadius') {
          item.shapeProps.cornerRadius = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.area.w - originalX - dx, 0, Math.min(item.area.w / 4, item.area.h / 4));
        }
      }

    },
    args: {
      cornerRadius: {
        type: 'number',
        value: '0',
        name: 'Corner radius'
      },
      headerHeight: {
        type: 'number',
        value: 30,
        name: 'Header Height'
      }
    }
  }
});

/***/ }),

/***/ 5845:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_package',
    menuItems: [{
      group: 'UML',
      name: 'Package',
      iconUrl: '/assets/images/items/uml-package.svg',
      size: {
        w: 140,
        h: 100
      }
    }],
    controlPoints: {
      make(item) {
        return {
          brick: {
            x: Math.min(item.shapeProps.brickWidth, item.area.w / 2),
            y: _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.brickHeight, 0, item.area.h / 2)
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'brick') {
          item.shapeProps.brickWidth = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(originalX + dx, 0, item.area.w / 2);
          item.shapeProps.brickHeight = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(originalY + dy, 0, item.area.h / 2);
        }
      }

    },

    getPins(item) {
      const w = item.area.w;
      const h = item.area.h;
      const bh = Math.min(Math.max(0, item.shapeProps.brickHeight), item.area.h / 2);
      const H = h - bh;
      return [{
        x: w / 2,
        y: bh + H / 2
      }, {
        x: w / 2,
        y: bh,
        nx: 0,
        ny: -1
      }, {
        x: w / 2,
        y: h,
        nx: 0,
        ny: 1
      }, {
        x: 0,
        y: bh + H / 2,
        nx: -1,
        ny: 0
      }, {
        x: w,
        y: bh + H / 2,
        nx: 1,
        ny: 0
      }];
    },

    computePath(item) {
      const W = item.area.w;
      const H = item.area.h;
      const BW = Math.min(Math.max(0, item.shapeProps.brickWidth), item.area.w / 2);
      const BH = Math.min(Math.max(0, item.shapeProps.brickHeight), item.area.h / 2);
      return `M 0 0  L ${BW} 0 L ${BW} ${BH} L 0 ${BH} Z` + `M ${0} ${BH} L ${W} ${BH} L ${W} ${H} L 0 ${H} Z`;
    },

    computeOutline(item) {
      const W = item.area.w;
      const H = item.area.h;
      const BW = Math.min(Math.max(0, item.shapeProps.brickWidth), item.area.w / 2);
      const BH = Math.min(Math.max(0, item.shapeProps.brickHeight), item.area.h / 2);
      return `M 0 0  L ${BW} 0 L ${BW} ${BH}  L ${W} ${BH} L ${W} ${H} L 0 ${H} Z`;
    },

    args: {
      brickWidth: {
        type: 'number',
        value: 60,
        name: 'Brick width',
        min: 0
      },
      brickHeight: {
        type: 'number',
        value: 20,
        name: 'Brick height',
        min: 0
      }
    }
  }
});

/***/ }),

/***/ 4358:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



function computePath(item) {
  const w = item.area.w;
  const h = item.area.h;
  const s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, w / 3);
  const cy = h / 2;
  return `M ${s} 0 L ${w - s} 0 L ${w} ${cy} L ${w - s} ${h} L ${s} ${h} L 0 ${cy} Z`;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_preparation',
    menuItems: [{
      group: 'UML',
      name: 'Preparation',
      iconUrl: '/assets/images/items/uml-preparation.svg'
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      return computePath(item);
    },

    controlPoints: {
      make(item) {
        return {
          skew: {
            x: item.area.w - _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.w / 3),
            y: 0
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'skew') {
          item.shapeProps.skew = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.area.w - originalX - dx, 0, item.area.w / 3);
        }
      }

    },
    args: {
      skew: {
        type: 'number',
        value: 20,
        name: 'Skew'
      }
    }
  }
});

/***/ }),

/***/ 1693:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


const maxSkewRatio = 4;

function computePath(item) {
  const w = item.area.w;
  const h = item.area.h;
  const s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, w / maxSkewRatio);
  return `M 0 0 L ${w} 0 L ${w} ${h} L 0 ${h} Z  M ${s} 0 L ${s} ${h} M ${w - s} 0 L ${w - s} ${h}`;
}

function computeOutline(item) {
  const w = item.area.w;
  const h = item.area.h;
  return `M 0 0 L ${w} 0 L ${w} ${h} L 0 ${h} Z`;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_process',
    menuItems: [{
      group: 'UML',
      name: 'Process',
      iconUrl: '/assets/images/items/uml-process.svg'
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      return computePath(item);
    },

    computeOutline(item) {
      return computeOutline(item);
    },

    controlPoints: {
      make(item) {
        return {
          skew: {
            x: item.area.w - _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.w / maxSkewRatio),
            y: 0
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'skew') {
          item.shapeProps.skew = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.area.w - originalX - dx, 0, item.area.w / maxSkewRatio);
        }
      }

    },
    args: {
      skew: {
        type: 'number',
        value: 20,
        name: 'Skew'
      }
    }
  }
});

/***/ }),

/***/ 8396:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


function computePath(item) {
  const w = item.area.w;
  const h = item.area.h;
  const s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(h / 2, 0, w);
  return `M 0 0 L ${w} 0 L ${w} ${h} L 0 ${h} L ${s} ${h / 2} Z`;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_receive_signal',
    menuItems: [{
      group: 'UML',
      name: 'Receive Signal',
      iconUrl: '/assets/images/items/uml-receive-signal.svg'
    }],

    getPins(item) {
      const w = item.area.w;
      const h = item.area.h;
      const s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(h / 2, 0, w);
      return [{
        x: w / 2,
        y: h / 2
      }, {
        x: w / 2,
        y: 0,
        nx: 0,
        ny: -1
      }, {
        x: w / 2,
        y: h,
        nx: 0,
        ny: 1
      }, {
        x: s,
        y: h / 2,
        nx: -1,
        ny: 0
      }, {
        x: w,
        y: h / 2,
        nx: 1,
        ny: 0
      }];
    },

    computePath(item) {
      return computePath(item);
    },

    computeOutline(item) {
      return computePath(item);
    },

    args: {}
  }
});

/***/ }),

/***/ 7153:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



function computePath(item) {
  const w = item.area.w;
  const h = item.area.h;
  const s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(h / 2, 0, w);
  return `M 0 0 L ${w - s} 0 L ${w} ${h / 2} L ${w - s} ${h} L 0 ${h} Z`;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_send_signal',
    menuItems: [{
      group: 'UML',
      name: 'Send Signal',
      iconUrl: '/assets/images/items/uml-send-signal.svg'
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_1__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      return computePath(item);
    },

    computeOutline(item) {
      return computePath(item);
    },

    args: {}
  }
});

/***/ }),

/***/ 9699:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ShapeDefaults__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9498);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


function computePath(item) {
  const w = item.area.w;
  const h = item.area.h;
  const r = Math.min(w, h) / 2;
  return `M ${r} 0 L ${w - r} 0 A ${r} ${r} 0 0 1 ${w - r} ${h} L ${r} ${h} A ${r} ${r} 0 0 1 ${r} 0 Z`;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_start',
    menuItems: [{
      group: 'UML',
      name: 'Start/End',
      iconUrl: '/assets/images/items/uml-start.svg'
    }],

    getPins(item) {
      return (0,_ShapeDefaults__WEBPACK_IMPORTED_MODULE_0__/* .getStandardRectPins */ .F)(item);
    },

    computePath(item) {
      return computePath(item);
    },

    computeOutline(item) {
      return computePath(item);
    },

    args: {}
  }
});

/***/ }),

/***/ 3486:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

const maxSkewRatioToHeight = 3;

function computePath(item) {
  const w = item.area.w,
        h = item.area.h,
        s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.w / maxSkewRatioToHeight),
        d = s / 2,
        k = item.area.h / 4,
        cy = h / 2;
  return `M ${w} ${h} L ${s} ${h}  Q 0 ${h - k} 0 ${cy}  Q 0 ${k} ${s} 0 L ${w} 0 Q ${w - s} ${k} ${w - s} ${cy} Q ${w - s} ${h - k} ${w} ${h} Z`;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_storage',
    menuItems: [{
      group: 'UML',
      name: 'Storage',
      iconUrl: '/assets/images/items/uml-storage.svg'
    }],

    getPins(item) {
      const w = item.area.w;
      const h = item.area.h;
      const s = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.w / maxSkewRatioToHeight);
      return [{
        x: w / 2,
        y: h / 2
      }, {
        x: w / 2,
        y: 0,
        nx: 0,
        ny: -1
      }, {
        x: w / 2,
        y: h,
        nx: 0,
        ny: 1
      }, {
        x: 0,
        y: h / 2,
        nx: -1,
        ny: 0
      }, {
        x: w - s,
        y: h / 2,
        nx: 1,
        ny: 0
      }];
    },

    computePath(item) {
      return computePath(item);
    },

    computeOutline(item) {
      return computePath(item);
    },

    controlPoints: {
      make(item) {
        return {
          skew: {
            x: item.area.w - _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.skew, 0, item.area.w / maxSkewRatioToHeight),
            y: item.area.h / 2
          }
        };
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'skew') {
          item.shapeProps.skew = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.area.w - originalX - dx, 0, item.area.w / maxSkewRatioToHeight);
        }
      }

    },
    args: {
      skew: {
        type: 'number',
        value: 20,
        name: 'Skew'
      }
    }
  }
});

/***/ }),

/***/ 5576:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _myMath__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3590);
/* harmony import */ var _AdvancedFill_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6777);
/* harmony import */ var _scheme_ItemFixer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1377);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




function swimLaneWidth(item) {
  if (item.shapeProps.vertical) {
    return item.area.w;
  }

  return item.area.h;
}

function swimLaneHeight(item) {
  if (item.shapeProps.vertical) {
    return item.area.h;
  }

  return item.area.w;
}

function computeOutline(item) {
  return `M 0 0 L ${item.area.w} 0 L ${item.area.w} ${item.area.h} L 0 ${item.area.h} Z`;
}

function computeCurves(item) {
  const headerHeight = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.headerHeight, 0, swimLaneHeight(item));
  let headerLinePath = '';

  if (item.shapeProps.vertical) {
    headerLinePath = `M 0 ${headerHeight} L ${item.area.w} ${headerHeight}`;
  } else {
    headerLinePath = `M ${headerHeight} 0 L ${headerHeight} ${item.area.h}`;
  }

  const curves = [{
    path: computeOutline(item),
    fill: _AdvancedFill_vue__WEBPACK_IMPORTED_MODULE_1__/* ["default"].computeStandardFill */ .Z.computeStandardFill(item),
    strokeColor: item.shapeProps.strokeColor,
    strokeSize: item.shapeProps.strokeSize
  }, {
    path: headerLinePath,
    fill: 'none',
    strokeColor: item.shapeProps.strokeColor,
    strokeSize: item.shapeProps.strokeSize
  }];
  let previousColumnRatio = 0;

  for (let i = 1; i < item.shapeProps.columns; i++) {
    let columnRatio = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(previousColumnRatio + Math.abs(item.shapeProps[`colw${i}`]), 0, 100);
    const pos = columnRatio * swimLaneWidth(item) / 100.0;
    let path = '';

    if (item.shapeProps.vertical) {
      path = `M ${pos} 0 L ${pos} ${swimLaneHeight(item)}`;
    } else {
      path = `M 0 ${pos} L ${swimLaneHeight(item)} ${pos}`;
    }

    curves.push({
      path,
      fill: 'none',
      strokeColor: item.shapeProps.strokeColor,
      strokeSize: item.shapeProps.strokeSize
    });
    previousColumnRatio = columnRatio;
  }

  return curves;
} // This implementation is very inefficient since for each column control point it will have to scan through all columns from the start
// but I am not able to solve it in a better way without refactoring control points implementation completely
// there is another way to solve: by replacing colw (relative column width) arguments with colp (relative column position),
// but this has a bad side effect when user modifies number of columns - it would look ugly


function makeColumnControlPoint(item, columnNumber) {
  let offset = 0;

  for (let i = 1; i <= columnNumber; i++) {
    const r = item.shapeProps[`colw${i}`];
    offset += r * swimLaneWidth(item) / 100.0;
  }

  if (item.shapeProps.vertical) {
    return {
      x: _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(offset, 0, swimLaneWidth(item)),
      y: 0
    };
  } else {
    return {
      x: 0,
      y: _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(offset, 0, swimLaneWidth(item))
    };
  }
}

function getTextSlots(item) {
  const textSlots = [];
  const W = swimLaneWidth(item);
  let previousColumnRatio = 0;
  let previousPosition = 0;

  for (let i = 1; i <= item.shapeProps.columns; i++) {
    let columnRatio = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(previousColumnRatio + Math.abs(item.shapeProps[`colw${i}`]), 0, 100);
    const pos = columnRatio * W / 100.0;
    let width = pos - previousPosition;

    if (i === item.shapeProps.columns) {
      width = W - previousPosition;
    }

    if (item.shapeProps.vertical) {
      textSlots.push({
        name: `col${i}`,
        area: {
          x: previousPosition,
          y: 0,
          w: width,
          h: item.shapeProps.headerHeight
        }
      });
    } else {
      textSlots.push({
        name: `col${i}`,
        area: {
          x: 0,
          y: previousPosition,
          w: item.shapeProps.headerHeight,
          h: width
        }
      });
    }

    previousColumnRatio = columnRatio;
    previousPosition = pos;
  }

  return textSlots;
}

function onColumnNumberUpdate($store, item, columns, previousColumns) {
  const columnWidths = [];
  let totalColumnSum = 0;
  let W = swimLaneWidth(item);

  for (let i = 1; i < previousColumns; i++) {
    const width = item.shapeProps[`colw${i}`] * W / 100.0;
    columnWidths.push(width);
    totalColumnSum += width;
  }

  if (columns > previousColumns && columns > 1 && !_myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].tooSmall */ .Z.tooSmall(W)) {
    // adding a column
    const columnWidth = W / (columns - 1);

    if (item.shapeProps.vertical) {
      item.area.w += columnWidth;
    } else {
      item.area.h += columnWidth;
    }

    W = swimLaneWidth(item);
    item.shapeProps[`colw${columns - 1}`] = 100 * columnWidth / W;

    for (let i = 1; i < previousColumns; i++) {
      item.shapeProps[`colw${i}`] = 100 * columnWidths[i - 1] / W;
    }

    if (!item.textSlots[`col${columns}`]) {
      item.textSlots[`col${columns}`] = {
        text: `<b>Title ${columns}</b>`
      };
      (0,_scheme_ItemFixer__WEBPACK_IMPORTED_MODULE_2__/* .enrichItemTextSlotWithDefaults */ .q4)(item.textSlots[`col${columns}`]);
    }
  }

  if (columns < previousColumns && columns > 0 && !_myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].tooSmall */ .Z.tooSmall(W)) {
    if (item.shapeProps.vertical) {
      item.area.w = totalColumnSum;
    } else {
      item.area.h = totalColumnSum;
    }

    W = swimLaneWidth(item);

    if (!_myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].tooSmall */ .Z.tooSmall(W)) {
      for (let i = 1; i < columns; i++) {
        item.shapeProps[`colw${i}`] = 100 * columnWidths[i - 1] / W;
      }
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  shapeConfig: {
    shapeType: 'standard',
    id: 'uml_swim_lane',
    menuItems: [{
      group: 'UML',
      name: 'Swim Lane',
      iconUrl: '/assets/images/items/uml-swim-lane.svg',
      item: {
        shapeProps: {
          columns: 3,
          colw1: 33.33333,
          colw2: 33.33333,
          colw3: 33.33333
        },
        textSlots: {
          col1: {
            text: '<b>Todo</b>'
          },
          col2: {
            text: '<b>In Progress</b>'
          },
          col3: {
            text: '<b>Done</b>'
          }
        }
      },
      previewArea: {
        x: 5,
        y: 5,
        w: 250,
        h: 100
      },
      size: {
        w: 800,
        h: 400
      }
    }, {
      group: 'UML',
      name: 'Swim Lane (Horizontal)',
      iconUrl: '/assets/images/items/uml-swim-lane-horizontal.svg',
      item: {
        shapeProps: {
          columns: 3,
          vertical: false,
          headerHeight: 110,
          colw1: 33.33333,
          colw2: 33.33333,
          colw3: 33.33333
        },
        textSlots: {
          col1: {
            text: '<b>Todo</b>'
          },
          col2: {
            text: '<b>In Progress</b>'
          },
          col3: {
            text: '<b>Done</b>'
          }
        }
      },
      previewArea: {
        x: 5,
        y: 5,
        w: 250,
        h: 100
      },
      size: {
        w: 800,
        h: 400
      }
    }],
    computeCurves,
    computeOutline,
    getTextSlots,

    // triggered when user initiates creation of this item
    beforeCreate(store, item) {
      const columns = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.columns, 1, 12);
      const columnRatio = 100 / columns;

      for (let i = 0; i < columns; i++) {
        item.shapeProps[`colw${i}`] = columnRatio;
      }
    },

    controlPoints: {
      make(item) {
        const cps = {};

        if (item.shapeProps.vertical) {
          cps.headerHeight = {
            x: 0,
            y: _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.headerHeight, 0, item.area.h)
          };
        } else {
          cps.headerHeight = {
            x: _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(item.shapeProps.headerHeight, 0, item.area.w),
            y: 0
          };
        } // doing it in reverse order so that control point for first column would always be rendered on top of second control point


        for (let i = item.shapeProps.columns - 1; i > 0; i--) {
          cps[`colw${i}`] = makeColumnControlPoint(item, i);
        }

        return cps;
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName.indexOf('colw') === 0) {
          let movement = originalX + dx;

          if (!item.shapeProps.vertical) {
            movement = originalY + dy;
          }

          const W = swimLaneWidth(item);
          const columns = Math.max(1, item.shapeProps.columns);

          if (_myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].tooSmall */ .Z.tooSmall(W)) {
            return;
          }

          const columnNumber = parseInt(controlPointName.substr(4));
          let offset = 0;

          for (let i = 1; i < columnNumber; i++) {
            const r = item.shapeProps[`colw${i}`];
            offset += r * W / 100.0;
          }

          const width = Math.max(0, movement - offset);
          const minWidth = 5 / columns;
          const maxWidth = 100 - 5 / columns;
          item.shapeProps[`colw${columnNumber}`] = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(100 * width / W, minWidth, maxWidth);
        } else if (controlPointName === 'headerHeight') {
          let movement = originalY + dy;

          if (!item.shapeProps.vertical) {
            movement = originalX + dx;
          }

          item.shapeProps.headerHeight = _myMath__WEBPACK_IMPORTED_MODULE_0__/* ["default"].clamp */ .Z.clamp(movement, 0, swimLaneHeight(item));
        }
      }

    },
    args: {
      columns: {
        type: 'number',
        value: 3,
        name: 'Columns',
        min: 1,
        max: 12,
        onUpdate: onColumnNumberUpdate
      },
      headerHeight: {
        type: 'number',
        value: 50,
        name: 'Header Height',
        min: 0,
        hidden: true
      },
      vertical: {
        type: 'boolean',
        value: true,
        name: 'Vertical'
      },
      colw1: {
        type: 'number',
        value: 20,
        name: 'Column Width 1',
        min: 0,
        max: 100.0,
        hidden: true
      },
      colw2: {
        type: 'number',
        value: 20,
        name: 'Column Width 2',
        min: 0,
        max: 100.0,
        hidden: true
      },
      colw3: {
        type: 'number',
        value: 20,
        name: 'Column Width 3',
        min: 0,
        max: 100.0,
        hidden: true
      },
      colw4: {
        type: 'number',
        value: 20,
        name: 'Column Width 4',
        min: 0,
        max: 100.0,
        hidden: true
      },
      colw5: {
        type: 'number',
        value: 20,
        name: 'Column Width 5',
        min: 0,
        max: 100.0,
        hidden: true
      },
      colw6: {
        type: 'number',
        value: 20,
        name: 'Column Width 6',
        min: 0,
        max: 100.0,
        hidden: true
      },
      colw7: {
        type: 'number',
        value: 20,
        name: 'Column Width 7',
        min: 0,
        max: 100.0,
        hidden: true
      },
      colw8: {
        type: 'number',
        value: 20,
        name: 'Column Width 8',
        min: 0,
        max: 100.0,
        hidden: true
      },
      colw9: {
        type: 'number',
        value: 20,
        name: 'Column Width 9',
        min: 0,
        max: 100.0,
        hidden: true
      },
      colw10: {
        type: 'number',
        value: 20,
        name: 'Column Width 10',
        min: 0,
        max: 100.0,
        hidden: true
      },
      colw11: {
        type: 'number',
        value: 20,
        name: 'Column Width 11',
        min: 0,
        max: 100.0,
        hidden: true
      },
      colw12: {
        type: 'number',
        value: 20,
        name: 'Column Width 12',
        min: 0,
        max: 100.0,
        hidden: true
      }
    }
  }
});

/***/ }),

/***/ 5635:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "A": () => (/* binding */ generateTextStyle)
/* harmony export */ });
/* harmony import */ var _scheme_Fonts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3086);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

function generateTextStyle(textSlot) {
  const style = {
    'color': textSlot.color,
    'font-size': textSlot.fontSize + 'px',
    'font-family': (0,_scheme_Fonts__WEBPACK_IMPORTED_MODULE_0__/* .getFontFamilyFor */ .It)(textSlot.font),
    'padding-left': textSlot.paddingLeft + 'px',
    'padding-right': textSlot.paddingRight + 'px',
    'padding-top': textSlot.paddingTop + 'px',
    'padding-bottom': textSlot.paddingBottom + 'px',
    'text-align': textSlot.halign,
    'vertical-align': textSlot.valign,
    'white-space': textSlot.whiteSpace,
    'display': 'table-cell',
    'box-sizing': 'border-box'
  };
  return style;
}

/***/ }),

/***/ 8442:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "R": () => (/* binding */ Keys),
/* harmony export */   "W": () => (/* binding */ identifyKeyPress)
/* harmony export */ });
/* harmony import */ var lodash_findKey__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(894);
/* harmony import */ var lodash_findKey__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_findKey__WEBPACK_IMPORTED_MODULE_0__);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

const Keys = {
  ESCAPE: 'escape',
  DELETE: 'delete',
  CTRL_A: 'ctrl-a',
  CTRL_C: 'ctrl-c',
  CTRL_V: 'ctrl-v',
  CTRL_S: 'ctrl-s',
  CTRL_Z: 'ctrl-z',
  CTRL_SHIFT_Z: 'ctrl-shift-z',
  UP: 'up',
  DOWN: 'down',
  LEFT: 'left',
  RIGHT: 'right',
  SPACE: 'space',
  MINUS: 'minus',
  EQUALS: 'equals'
};
const keyMap = {};

keyMap[Keys.ESCAPE] = event => event.key === 'Escape' || event.key === 'Esc' || event.keyCode === 27;

keyMap[Keys.DELETE] = event => event.key === 'Backspace' || event.key === 'Delete' || event.keyCode === 8 || event.keyCode === 127;

keyMap[Keys.CTRL_A] = event => event.key === 'a' && (event.metaKey || event.ctrlKey);

keyMap[Keys.CTRL_C] = event => event.key === 'c' && (event.metaKey || event.ctrlKey);

keyMap[Keys.CTRL_V] = event => event.key === 'v' && (event.metaKey || event.ctrlKey);

keyMap[Keys.CTRL_S] = event => event.key === 's' && (event.metaKey || event.ctrlKey);

keyMap[Keys.CTRL_Z] = event => event.key === 'z' && (event.metaKey || event.ctrlKey) && !event.shiftKey;

keyMap[Keys.CTRL_SHIFT_Z] = event => event.key === 'z' && (event.metaKey || event.ctrlKey) && event.shiftKey;

keyMap[Keys.LEFT] = event => event.key === 'ArrowLeft';

keyMap[Keys.RIGHT] = event => event.key === 'ArrowRight';

keyMap[Keys.UP] = event => event.key === 'ArrowUp';

keyMap[Keys.DOWN] = event => event.key === 'ArrowDown';

keyMap[Keys.SPACE] = event => event.key === ' ' || event.keyCode === 32;

keyMap[Keys.MINUS] = event => event.key === '-' || event.keyCode === 189;

keyMap[Keys.EQUALS] = event => event.key === '=' || event.keyCode === 187;
/**
 * 
 * @param {MouseEvent} event 
 * @returns {String} id of event which is available in Keys object
 */


function identifyKeyPress(event) {
  return lodash_findKey__WEBPACK_IMPORTED_MODULE_0___default()(keyMap, (check, keyName) => check(event));
}

/***/ }),

/***/ 2017:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Yd": () => (/* binding */ Logger),
/* harmony export */   "qc": () => (/* binding */ Debugger)
/* harmony export */ });
/* unused harmony exports LogConfig, registerDebuggerInitiation */
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4486);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_0__);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


function strhash(text) {
  let hash = 0;

  for (let i = 0; i < text.length; i++) {
    hash = (hash << 5) - hash + text.charCodeAt(i);
    hash |= 0;
  }

  return hash;
}

function currentTimeToString() {
  const date = new Date();
  return date.toLocaleTimeString() + '.' + date.getMilliseconds();
}

const LogConfig = {
  loggers: {},
  filterRegex: null,

  registerLogger(name) {
    const hue = Math.abs(strhash(name)) % 360;
    let enabled = false; // checking if it was already configured or loaded from local storage

    if (this.loggers.hasOwnProperty(name)) {
      enabled = this.loggers[name].enabled;
    }

    this.loggers[name] = {
      enabled: enabled,
      background: `hsl(${hue}, 75%, 35%)`
    };
  },

  showLoggers() {
    console.log('%cSchemio Log Config!', 'color: white; display: inline-block; padding: 5px 10px; background: #00aaff; font-family: Helvetica; font-size: 20px; font-weight: bold');
    lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(this.loggers, (settings, name) => {
      console.log(name);
    });
  },

  enable(name) {
    if (!this.loggers[name]) {
      console.error('Unknown logger: ' + name);
    }

    this.loggers[name].enabled = true;
    saveConfigToLocalStorage();
  },

  disable(name) {
    if (!this.loggers[name]) {
      console.error('Unknown logger: ' + name);
    }

    this.loggers[name].enabled = false;
    saveConfigToLocalStorage();
  },

  filter(filterRegex) {
    if (filterRegex) {
      this.filterRegex = new RegExp(filterRegex);
    } else {
      this.filterRegex = null;
    }

    saveConfigToLocalStorage();
  }

};

function passesFilter(filterRegex, args) {
  if (filterRegex) {
    let fullArgsText = '';

    for (let i = 0; i < args.length; i++) {
      const arg = args[i];

      if (typeof arg === 'string') {
        fullArgsText = fullArgsText + ' ' + arg;
      }
    }

    return filterRegex.test(fullArgsText);
  }

  return true;
}

class Logger {
  constructor(name) {
    this.name = name;
    this.timers = {};
    LogConfig.registerLogger(name);
  }

  info(...args) {
    const settings = LogConfig.loggers[this.name];

    if (settings && settings.enabled) {
      if (passesFilter(LogConfig.filterRegex, args)) {
        const time = currentTimeToString();
        console.log.apply(console, [`${time} %c${this.name}`, `display: inline-block; font-weight: bold; background: ${settings.background}; text-shadow: 0 0 4px rgba(0, 0, 0, 0.5); padding: 2px 5px; border-radius: 2px; color: white`, ...args]);
      }
    }
  }

  time(timerName) {
    this.timers[timerName] = performance.now();
  }

  timeEnd(timerName) {
    const settings = LogConfig.loggers[this.name];

    if (!settings || !settings.enabled) {
      return;
    }

    if (this.timers[timerName]) {
      if (passesFilter(LogConfig.filterRegex, `${this.name} ${timerName}`)) {
        const timeTaken = performance.now() - this.timers[timerName];
        const time = currentTimeToString();
        console.log.apply(console, [`${time} %c${this.name}%c Timer: %c${timerName}%c took ${timeTaken} ms`, `display: inline-block; font-weight: bold; background: ${settings.background}; text-shadow: 0 0 4px rgba(0, 0, 0, 0.5); padding: 2px 5px; border-radius: 2px; color: white`, '', `display: inline-block; font-weight: bold; background: hsl(142, 45%, 30%); padding: 2px 5px; border-radius: 2px; color: white`, '']);
      }
    } else {
      console.error(`Could not measure time in ${this.name}. Missing timer ${timerName} initialisation`);
    }
  } // used by event bus


  infoEvent(eventName, args) {
    const settings = LogConfig.loggers[this.name];

    if (settings && settings.enabled) {
      if (passesFilter(LogConfig.filterRegex, args)) {
        const hue = Math.abs(strhash(eventName)) % 360;
        const time = currentTimeToString();
        console.log.apply(console, [`${time} %c${this.name} %c${eventName}`, `display: inline-block; font-weight: bold; background: ${settings.background}; text-shadow: 0 0 4px rgba(0, 0, 0, 0.5) padding: 2px 5px; padding: 2px 5px; border-radius: 2px; color: white; margin-right: 10px`, `display: inline-block; font-weight: bold; background: hsl(${hue}, 70%, 30%); padding: 2px 5px; border-radius: 2px; color: white;`, ...args]);
      }
    }
  }

}

;
const Debugger = {
  objects: [],

  register(typeName, obj) {
    this.objects.push({
      type: typeName,
      obj: obj
    });
  }

};
const SCHEMIO_LOG_CONFIG = 'SchemioLogConfig';

function loadConfigFromLocalStorage() {
  if (!window || !window.localStorage) {
    return;
  }

  const configText = window.localStorage.getItem(SCHEMIO_LOG_CONFIG);

  if (!configText) {
    return;
  }

  try {
    const config = JSON.parse(configText);

    if (!config.loggers) {
      return;
    }

    lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(config.loggers, (settings, name) => {
      LogConfig.loggers[name] = {
        enabled: settings.enabled || false
      };
    });
  } catch (e) {}
}

function saveConfigToLocalStorage() {
  if (typeof window !== 'undefined' || !window.localStorage) {
    return;
  }

  window.localStorage.setItem(SCHEMIO_LOG_CONFIG, JSON.stringify(LogConfig));
}

loadConfigFromLocalStorage();
let debuggerInitiationCallback = null;

if (typeof window !== 'undefined') {
  window.SchemioDebugger = Debugger;

  window.SchemioLogConfig = () => {
    if (debuggerInitiationCallback) {
      debuggerInitiationCallback();
    }
  };
}

function registerDebuggerInitiation(callback) {
  debuggerInitiationCallback = callback;
}



/***/ }),

/***/ 3590:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

const MAX_PATH_DIVISIONS = 20;
const MIN_PATH_DIVISIONS = 8;
const PATH_DIVISION_LENGTH = 40;
const EPSILON = 0.00001;

function tooSmall(value) {
  return Math.abs(value) < EPSILON;
}
/**
 *
 * @param {*} x1
 * @param {*} y1
 * @param {*} x2
 * @param {*} y2
 * @returns angle in radians
 */


function angleBetweenVectors(x1, y1, x2, y2) {
  const ds1 = x1 * x1 + y1 * y1;

  if (!tooSmall(ds1)) {
    const ds2 = x2 * x2 + y2 * y2;

    if (!tooSmall(ds2)) {
      const d1 = Math.sqrt(ds1);
      const d2 = Math.sqrt(ds2);
      return Math.asin((x1 * y2 - y1 * x2) / (d1 * d2));
    }
  }

  return 0;
}

function cosineAngleBetweenVectors(x1, y1, x2, y2) {
  const ds1 = x1 * x1 + y1 * y1;

  if (ds1 > 0.001) {
    const ds2 = x2 * x2 + y2 * y2;

    if (ds2 > 0.001) {
      const d1 = Math.sqrt(ds1);
      const d2 = Math.sqrt(ds2);
      return Math.acos((x1 * x2 + y1 * y2) / (d1 * d2));
    }
  }

  return 0;
}

function fullAngleForVector(x, y) {
  const dSquared = x * x + y * y;

  if (!tooSmall(dSquared)) {
    const d = Math.sqrt(dSquared);
    return fullAngleForNormalizedVector(x / d, y / d);
  }

  return 0;
}

function fullAngleForNormalizedVector(x, y) {
  if (y >= 0) {
    return Math.acos(x);
  } else {
    return -Math.acos(x);
  }
}
/**
 * Generates line equation in form of ax + by + c = 0 which intersects given two points
 * returns an object with a, b, c parameters
 * @param {*} x1
 * @param {*} y1
 * @param {*} x2
 * @param {*} y2
 */


function createLineEquation(x1, y1, x2, y2) {
  return {
    a: y1 - y2,
    b: x2 - x1,
    c: x1 * y2 - x2 * y1
  };
}
/**
 * Calculates distance from given point to a line
 * @param {Number} x
 * @param {Number} y
 * @param {*} line line equation in form of {a, b, c}
 * @returns {Number} distance from given point to a line
 */


function distanceFromPointToLine(x, y, {
  a,
  b,
  c
}) {
  if (tooSmall(a) && tooSmall(b)) {
    return 0;
  }

  return Math.abs(a * x + b * y + c) / Math.sqrt(a * a + b * b);
}

function _simplifyPathPointsUsingRDP(points, epsilon, idxStart, idxEnd) {
  if (idxEnd - idxStart < 2) {
    return [points[idxStart], points[idxEnd]];
  }

  const line = createLineEquation(points[idxStart].x, points[idxStart].y, points[idxEnd].x, points[idxEnd].y);
  let furtherstPointIdx = idxStart + 1;
  let furtherstDistance = 0;

  for (let i = idxStart + 1; i < idxEnd; i++) {
    const d = distanceFromPointToLine(points[i].x, points[i].y, line);

    if (d > furtherstDistance) {
      furtherstDistance = d;
      furtherstPointIdx = i;
    }
  }

  if (furtherstDistance > epsilon) {
    // then we break it into smaller problems
    const pointsA = _simplifyPathPointsUsingRDP(points, epsilon, idxStart, furtherstPointIdx);

    const pointsB = _simplifyPathPointsUsingRDP(points, epsilon, furtherstPointIdx, idxEnd); // since both arrays will have point at furtherstPointIdx included, we need to remove it


    pointsB.splice(0, 1);
    return pointsA.concat(pointsB);
  } else {
    // we can skip all the points
    return [points[idxStart], points[idxEnd]];
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  /**
   * Checks whether two float values are considered to be the same within specified precision
   * @param {Number} a
   * @param {Number} b
   * @param {Number} precision Precision to which it should defined two values as "same". If not specified a default of 0.0001 will be used
   * @returns {Boolean} true if a is the same as b
   */
  sameFloatingValue(a, b, precision) {
    if (typeof precision === 'undefined' || precision === null) {
      precision = 0.0001;
    }

    return Math.abs(a - b) < precision;
  },

  tooSmall,

  /**
   * Rounds floating value and converts it to another floating value leaving only the specified significant digits after point
   * @param {*} value
   * @param {*} precision
   */
  roundPrecise(value, precision) {
    if (precision > 0) {
      const base = Math.pow(10, precision);
      return Math.round(value * base) / base;
    } else {
      return Math.round(value);
    }
  },

  roundPrecise1(value) {
    return this.roundPrecise(value, 1);
  },

  roundPrecise2(value) {
    return this.roundPrecise(value, 2);
  },

  clamp(value, min, max) {
    if (value < min) {
      return min;
    }

    if (value > max) {
      return max;
    }

    return value;
  },

  vectorLength(x, y) {
    return Math.sqrt(x * x + y * y);
  },

  vectorPlusVector(v1, v2) {
    return {
      x: v1.x + v2.x,
      y: v1.y + v2.y
    };
  },

  vectorMinusVector(v1, v2) {
    return {
      x: v1.x - v2.x,
      y: v1.y - v2.y
    };
  },

  distanceBetweenPoints(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  },

  normalizedVector(x, y) {
    const dSquared = x * x + y * y;

    if (this.tooSmall(dSquared)) {
      return null;
    }

    const d = Math.sqrt(dSquared);
    return {
      x: x / d,
      y: y / d
    };
  },

  angleBetweenVectors,
  cosineAngleBetweenVectors,
  fullAngleForNormalizedVector,
  fullAngleForVector,
  createLineEquation,
  distanceFromPointToLine,

  /**
   * Calculates instersection point of two lines
   * @param {Line} line1 line equation in form of {a, b, c}
   * @param {Line} line2 line equation in form of {a, b, c}
   * @returns
   */
  linesIntersection(line1, line2) {
    const ly = line1.a * line2.b - line2.a * line1.b;

    if (this.tooSmall(ly)) {
      return null;
    }

    const y = (line2.a * line1.c - line1.a * line2.c) / ly;
    let x = 0;

    if (this.tooSmall(line1.a)) {
      if (this.tooSmall(line2.a)) {
        return null;
      }

      x = (-line2.b * y - line2.c) / line2.a;
    } else {
      x = (-line1.b * y - line1.c) / line1.a;
    }

    return {
      x,
      y
    };
  },

  /**
   * Returns either -1 or 1 depending on which plane the point is lying agaist specified line
   * @param {*} x
   * @param {*} y
   * @param {Line} line Line equation in form of {a, b, c} object
   */
  identifyPointSideAgainstLine(x, y, {
    a,
    b,
    c
  }) {
    if (a * x + b * y + c >= 0) {
      return 1;
    }

    return -1;
  },

  isPointInArea(x, y, area) {
    return x >= area.x && x <= area.x + area.w && y >= area.y && y <= area.y + area.h;
  },

  isAreaInArea(area, largerArea) {
    return area.x >= largerArea.x && area.y >= largerArea.y && area.x + area.w < largerArea.x + largerArea.w && area.y + area.h < largerArea.y + largerArea.h;
  },

  /**
   * calculates overlapping area, returns null if there is no overlap
   * @param {Area} area1
   * @param {Area} area2
   * @returns {Area} overlapping area of two given areas
   */
  overlappingArea(area1, area2) {
    const a1x = area1.x;
    const a1y = area1.y;
    const b1x = area1.x + area1.w;
    const b1y = area1.y + area1.h;
    const a2x = area2.x;
    const a2y = area2.y;
    const b2x = area2.x + area2.w;
    const b2y = area2.y + area2.h;
    let y1 = 0,
        y2 = 0,
        x1 = 0,
        x2 = 0;

    if (a2x >= a1x) {
      x1 = a2x;
    } else {
      x1 = a1x;
    }

    if (b2x >= b1x) {
      x2 = b1x;
    } else {
      x2 = b2x;
    }

    if (a2y >= a1y) {
      y1 = a2y;
    } else {
      y1 = a1y;
    }

    if (b2y >= b1y) {
      y2 = b1y;
    } else {
      y2 = b2y;
    }

    if (y2 >= y1 && x2 >= x1) {
      return {
        x: x1,
        y: y1,
        w: x2 - x1,
        h: y2 - y1
      };
    }

    return null;
  },

  /**
  Checks if the point within line segment. It doesn't really check if it is placed exacly on the line segment
  */
  isPointWithinLineSegment(point, segmentPointA, segmentPointB) {
    var Ax = segmentPointA.x - point.x;
    var Ay = segmentPointA.y - point.y;
    var Bx = segmentPointB.x - point.x;
    var By = segmentPointB.y - point.y;
    var Lx = segmentPointB.x - segmentPointA.x;
    var Ly = segmentPointB.y - segmentPointA.y;
    return Lx * Lx + Ly * Ly > (Ax + Bx) * (Ax + Bx) + (Ay + By) * (Ay + By);
  },

  /**
   * calculates world point in specified area including its parent transform
   * @param {Number} x
   * @param {Number} y
   * @param {Area} area
   * @param {Array} transformMatrix - parent transform matrix of the item. May be null
   * @returns {Point}
   */
  worldPointInArea(x, y, area, transformMatrix) {
    if (!area) {
      return {
        x: 0,
        y: 0
      };
    }

    if (!transformMatrix) {
      transformMatrix = this.identityMatrix();
    }

    const itemCompleteTransform = this.standardTransformWithArea(transformMatrix, area);
    return this.transformPoint(itemCompleteTransform, x, y);
  },

  /**
   *
   * @param {Number} x
   * @param {Number} y
   * @param {Area} area
   * @param {Array} transformMatrix
   * @returns {Point}
   */
  localPointInArea(x, y, area, transformMatrix) {
    // To understand how to calculate local point in area we first need to imagine how we calculate a world point based on the items complete transform matrix
    // We can imagine it with this formula:
    //      Pw = At * P
    // where
    //      Pw - world point
    //      At - complete transform matrix of item
    //      P  - local point in item
    //
    // We can derive another formula from above by multiplying both sides by inverted transform matrix (from the left):
    //      Ai * Pw = Ai * At * P
    // where
    //      Ai - is the inverse matrix of At
    // this will turn into (because Ai * At - is equal to identity matrix):
    //      P = Ai * Pw
    // that is exactly what we need
    if (!area) {
      return {
        x: 0,
        y: 0
      };
    }

    if (!transformMatrix) {
      transformMatrix = this.identityMatrix();
    }

    const completeTransform = this.standardTransformWithArea(transformMatrix, area);
    const invertedTransform = this.inverseMatrix3x3(completeTransform);

    if (!invertedTransform) {
      return {
        x: 0,
        y: 0
      };
    }

    return this.transformPoint(invertedTransform, x, y);
  },

  /**
   * Calculates {x,y,distance} that is the closest to a specified point on the specified path
   * @param {Number} x
   * @param {Number} y
   * @param {SVGPathElement} svgPath
   * @param {Object} settings
   * @returns {SVGPathPoint}
   */
  closestPointOnPath(x, y, svgPath, settings) {
    let startDistance = undefined;
    let stopDistance = undefined;
    let precision = 0.5;

    if (settings && settings.startDistance !== undefined) {
      startDistance = settings.startDistance;
    }

    if (settings && settings.stopDistance !== undefined) {
      stopDistance = settings.stopDistance;
    }

    if (settings && settings.precision !== undefined) {
      precision = settings.precision;
    }

    const pathLength = svgPath.getTotalLength();

    if (pathLength < 0.0000001) {
      const p = svgPath.getPointAtLength(0);
      p.distance = 0;
      return p;
    }

    let closestSegmentLeft = 0;
    let closestSegmentRight = 0;

    if (startDistance === undefined || stopDistance === undefined) {
      // first doing a linear scan by cutting path into segments with equal length
      // trying to find the closest segment to the path first by checking each segments mid point
      const numberOfDivisions = Math.max(MIN_PATH_DIVISIONS, Math.min(pathLength / PATH_DIVISION_LENGTH, MAX_PATH_DIVISIONS));
      const divisionLength = pathLength / numberOfDivisions;
      let closestSegmentIdx = 0;
      let closestDistance = 0;

      for (let i = 0; i < numberOfDivisions; i++) {
        // taking a point at the mid of the segment
        const point = svgPath.getPointAtLength(i * divisionLength + divisionLength / 2);
        const distance = (x - point.x) * (x - point.x) + (y - point.y) * (y - point.y);

        if (i === 0) {
          closestSegmentIdx = i;
          closestDistance = distance;
        } else {
          if (closestDistance > distance) {
            closestDistance = distance;
            closestSegmentIdx = i;
          }
        }
      }

      closestSegmentLeft = closestSegmentIdx * divisionLength;
      closestSegmentRight = (closestSegmentIdx + 1) * divisionLength;
    } else {
      closestSegmentLeft = Math.min(startDistance, pathLength);
      closestSegmentRight = Math.min(stopDistance, pathLength);
    }

    const closestSegmentMid = (closestSegmentLeft + closestSegmentRight) / 2; // now doing a binary search on selected segment

    const leftSegment = [closestSegmentLeft, closestSegmentMid];
    const rightSegment = [closestSegmentMid, closestSegmentRight];
    let segmentWidth = (closestSegmentRight - closestSegmentLeft) / 2;
    let closestPoint = svgPath.getPointAtLength(closestSegmentLeft);
    closestPoint.distance = closestSegmentLeft;

    while (segmentWidth > precision) {
      const middle = segmentWidth / 2;
      let pointLeft = svgPath.getPointAtLength(leftSegment[0] + middle);
      pointLeft.distance = leftSegment[0] + middle;
      let pointRight = svgPath.getPointAtLength(rightSegment[0] + middle);
      pointRight.distance = rightSegment[0] + middle;
      let distanceLeft = (x - pointLeft.x) * (x - pointLeft.x) + (y - pointLeft.y) * (y - pointLeft.y);
      let distanceRight = (x - pointRight.x) * (x - pointRight.x) + (y - pointRight.y) * (y - pointRight.y);
      segmentWidth = middle;

      if (distanceLeft < distanceRight) {
        closestPoint = pointLeft;
        leftSegment[1] = leftSegment[0] + segmentWidth;
      } else {
        closestPoint = pointRight;
        leftSegment[0] = rightSegment[0];
        leftSegment[1] = leftSegment[0] + segmentWidth;
      }

      rightSegment[0] = leftSegment[1];
      rightSegment[1] = rightSegment[0] + segmentWidth;
    }

    return closestPoint;
  },

  /**
   * Converts world point in relative transform to coords in viewport for a given screen transform
   * @param {ScreenTransform} screenTransform - transform of a screen
   * @param {Number} x - X coords in the world (relative) transform
   * @param {Number} y - Y coords in the world (relative) transform
   * @returns {Point}
   */
  worldPointToViewport(screenTransform, x, y) {
    return {
      x: (x + screenTransform.x) / screenTransform.scale,
      y: (y + screenTransform.y) / screenTransform.scale
    };
  },

  /**
   * Converts viewport point to coords in relative transform for a given screen transform
   * @param {ScreenTransform} screenTransform - transform of a screen
   * @param {Number} x - X coords in the viewport transform
   * @param {Number} y - Y coords in the viewport transform
   * @returns {Point}
   */
  viewportPointToWorld(screenTransform, x, y) {
    return {
      x: x * screenTransform.scale - screenTransform.x,
      y: y * screenTransform.scale - screenTransform.y
    };
  },

  _snapScales: [500, 100, 20, 5, 1, 0.2, 0.04, 0.008],

  /**
   *
   * @param {Number} scale The scale value on screen transform
   * @returns {Number} size of grid snapping in world coords
   */
  getSnappingWidthForScale(scale) {
    const log5 = Math.round(Math.log(scale) / Math.log(5));
    const snapIndex = log5 + 2;

    if (snapIndex > 0 && snapIndex < this._snapScales.length) {
      return this._snapScales[snapIndex];
    }

    if (snapIndex > this._snapScales.length) {
      return this._snapScales[this._snapScales.length - 1];
    }

    return this._snapScales[0];
  },

  /**
   * Simplifies specified points using Ramer-Douglas-Peucker algorithm
   * @param {Array} points array of points
   * @param {Number} epsilon minimum distance to the line in the RDP algorithm
   * @returns
   */
  simplifyPathPointsUsingRDP(points, epsilon) {
    return _simplifyPathPointsUsingRDP(points, epsilon, 0, points.length - 1);
  },

  smoothPathPoints(points) {
    const maxSmoothingLength = 100;
    const maxSmoothingLengthSquared = maxSmoothingLength * maxSmoothingLength;
    const maxSmoothingAngle = 0.1;
    const smoothingFactor = 8;

    if (points.length <= 2) {
      return points;
    }

    const smoothPoints = [points[0]];

    for (let i = 1; i < points.length - 1; i++) {
      let prevPoint = points[i - 1];
      let point = points[i];
      let nextPoint = points[i + 1];
      const aSquared = (point.x - prevPoint.x) * (point.x - prevPoint.x) + (point.y - prevPoint.y) * (point.y - prevPoint.y);
      const bSquared = (point.x - nextPoint.x) * (point.x - nextPoint.x) + (point.y - nextPoint.y) * (point.y - nextPoint.y);
      const angle = angleBetweenVectors(prevPoint.x - point.x, prevPoint.y - point.y, nextPoint.x - point.x, nextPoint.y - point.y);

      if (aSquared < maxSmoothingLengthSquared && bSquared < maxSmoothingLengthSquared || Math.abs(angle) < maxSmoothingAngle) {
        const cx = nextPoint.x - prevPoint.x;
        const cy = nextPoint.y - prevPoint.y;
        smoothPoints.push({
          t: 'B',
          x: point.x,
          y: point.y,
          x1: -cx / smoothingFactor,
          y1: -cy / smoothingFactor,
          x2: cx / smoothingFactor,
          y2: cy / smoothingFactor
        });
      } else {
        smoothPoints.push(point);
      }
    }

    smoothPoints.push(points[points.length - 1]);
    return smoothPoints;
  },

  multiplyMatrices(...matrices) {
    if (matrices.length === 0) {
      return this.identityMatrix();
    }

    let matrix = matrices[0];

    for (let i = 1; i < matrices.length; i++) {
      matrix = this.multiplyTwoMatrices(matrix, matrices[i]);
    }

    return matrix;
  },

  multiplyTwoMatrices(matrixA, matrixB) {
    let rowsA = matrixA.length;
    let colsA = matrixA[0].length;
    let colsB = matrixB[0].length;
    let result = new Array(rowsA);

    for (let r = 0; r < rowsA; r++) {
      result[r] = new Array(colsB);

      for (let c = 0; c < colsB; c++) {
        result[r][c] = 0;

        for (let i = 0; i < colsA; i++) {
          result[r][c] += matrixA[r][i] * matrixB[i][c];
        }
      }
    }

    return result;
  },

  translationMatrix(tx, ty) {
    return [[1, 0, tx], [0, 1, ty], [0, 0, 1]];
  },

  rotationMatrixInDegrees(angle) {
    return this.rotationMatrixInRadians(angle * Math.PI / 180);
  },

  rotationMatrixInRadians(angle) {
    return [[Math.cos(angle), -Math.sin(angle), 0], [Math.sin(angle), Math.cos(angle), 0], [0, 0, 1]];
  },

  scaleMatrix(sx, sy) {
    if (isNaN(sx)) {
      throw new Error('nan');
    }

    return [[sx, 0, 0], [0, sy, 0], [0, 0, 1]];
  },

  identityMatrix() {
    return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
  },

  /**
   *
   * @param {Array} parentTransform
   * @param {Area} area
   * @returns {Array} new transformation matrix
   */
  standardTransformWithArea(parentTransform, area) {
    const xr = area.w * area.px;
    const yr = area.h * area.py;
    const cosa = Math.cos(area.r * Math.PI / 180);
    const sina = Math.sin(area.r * Math.PI / 180);
    /*
    Originally the code below was used for calculation of standard transformation for area.
    But it turned out to be inefficient on large scale due to all the calculations and generation of intermediary array objects
    That inefficience caused a lot of time to be spent in GC
    */
    // return this.multiplyMatrices(
    //     parentTransform,
    //     this.translationMatrix(area.x + xr, area.y + yr),
    //     this.rotationMatrixInDegrees(area.r),
    //     this.scaleMatrix(area.sx, area.sy),
    //     this.translationMatrix(-xr, -yr),
    // );

    /*
    So the formulas below are derived from the matrix multiplication formula above
    */

    const s = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    const x1 = area.x + xr;
    const y1 = area.y + yr;
    const x2 = -xr;
    const y2 = -yr;
    const A = parentTransform;

    for (let i = 0; i < 3; i++) {
      s[i][0] = area.sx * (A[i][0] * cosa + A[i][1] * sina);
      s[i][1] = area.sy * (A[i][1] * cosa - A[i][0] * sina);
      s[i][2] = s[i][0] * x2 + s[i][1] * y2 + A[i][0] * x1 + A[i][1] * y1 + A[i][2];
    }

    return s;
  },

  /**
   * Trasforms specified point
   * @param {Array} transformMatrix
   * @param {Number} x
   * @param {Number} y
   * @returns {Point}
   */
  transformPoint(transformMatrix, x, y) {
    const resultMatrix = this.multiplyMatrices(transformMatrix, [[x], [y], [1]]);
    return {
      x: resultMatrix[0][0],
      y: resultMatrix[1][0]
    };
  },

  transformVector(transformMatrix, x, y) {
    const p0 = this.transformPoint(transformMatrix, 0, 0);
    const p1 = this.transformPoint(transformMatrix, x, y);
    return {
      x: p1.x - p0.x,
      y: p1.y - p0.y
    };
  },

  /**
   *
   * @param {Array} m - matrix of 3x3
   * @returns {Array} - inversed matrix or null in case matrix cannot be inversed
   */
  inverseMatrix3x3(m) {
    const xmod = (r, c) => {
      const rows = [0, 1, 2];
      const cols = [0, 1, 2];
      rows.splice(r, 1);
      cols.splice(c, 1);
      return m[rows[0]][cols[0]] * m[rows[1]][cols[1]] - m[rows[0]][cols[1]] * m[rows[1]][cols[0]];
    };

    const det = m[0][0] * xmod(0, 0) - m[0][1] * xmod(0, 1) + m[0][2] * xmod(0, 2);

    if (this.tooSmall(det)) {
      return null;
    }

    const result = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    let i = 2;

    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 3; c++) {
        const k = i % 2 === 0 ? 1 : -1; // here we need to get transposed matrix so we switch rows and columns, this will flip it around its own diagonal

        result[c][r] = k * xmod(r, c) / det;
        i++;
      }
    }

    return result;
  },

  /**
   * Calculates local translation for specified area so that its point in local transform
   * would match world point after transformation. Basically this function tells you how to move the item
   * so that its given local point matches world point after transformation.
   *
   * @param {Number} x - x part of world point
   * @param {Number} y - y part of world point
   * @param {Number} x0 - x part of local point
   * @param {Number} y0 - y part of local point
   * @param {Area} area
   * @param {Array} parentTransform
   * @returns {Point} - can be null. Point in the local transform of area with which it would match specified world point
   */
  findTranslationMatchingWorldPoint(x, y, x0, y0, area, parentTransform) {
    // Here we have to do some reversed computation to figure out which translation matrix should be used in the area
    // so that its local point (x0, y0) matches specified point in world.
    // We do it like this:
    // We bring the full matrix formula of world transformation of local point (P0) into world (Pw).
    // However in this formula we already know world point (Pw)
    // But the translation matrix is unknown (At). And that is actually what this function is supposed to calculate
    // Based on this we can write the following equation:
    //
    //      Pw = Ap * At * Ac1 * Ar * As * Ac2 * P0
    //
    // where
    //      Pw  - world point
    //      Ap  - parent item transform matrix
    //      At  - translation matrix. This is unknown in the equation
    //      Ac1 - translation matrix for items pivot point. It moves item by (rpx, rpy).
    //            This matrix is needed so that item is rotated around pivot point
    //      Ar  - rotation matrix. Rotates item by its area.r value
    //      As  - scale matrix
    //      Ac2 - translation matrix for items pivot point. It moves item back by (-rpx, -rpy)
    //      P0  - local point
    //
    // We can move Ap to the left if we inverse it. Lets also group all matrices
    // on the right between At and P0 and call it just matrix A
    //
    //      Ap-1 * Pw = At * A * P0
    //
    // where
    //      Ap-1 = is inverse of Ap matrix
    //      A = Ac1 * Ar * As * Ac2
    //
    // lets call matrix Ap-1 as B to make it easier to distinguish between the two matrices:
    //
    //      B * Pw = At * A * P0
    //
    // in the equation above only At is unknown so lets expand all multiplications of all matrices
    //
    //      | B11  B12  B13 |   | Xw |     | 1  0  Xt |   | A11  A12  A13 |   | Xo |
    //      | B21  B22  B23 | * | Yw |  =  | 0  1  Yt | * | A21  A22  A23 | * | Yo |
    //      | B31  B32  B33 |   | 1  |     | 0  0  1  |   | A31  A32  A33 |   |  1 |
    //
    // if we multiply all matrices we will find out that
    //
    //      | B11*Xw + B12*Yw + B13 |   | Xt*(Xo*A31 + Yo*A32 + A33) + Xo*A11 + Yo*A12 + A13 |
    //      | B21*Xw + B22*Yw + B23 | = | Yt*(Xo*A31 + Yo*A32 + A33) + Xo*A21 + Yo*A22 + A23 |
    //      |    B31 + B32 + B33    |   |              Xo*A31 + Yo*A32 + A33                 |
    //
    // from the above equation we can take out the relevant parts and finally get our complete formula
    //
    //      Xt = (B11*Xw + B12*Yw + B13 - Xo*A11 - Yo*A12 - A13) / (Xo*A31 + Yo*A32 + A33)
    //      Yt = (B21*Xw + B22*Yw + B23 - Xo*A21 - Yo*A22 - A23) / (Xo*A31 + Yo*A32 + A33)
    let parentInversedTransform = this.identityMatrix();

    if (parentTransform) {
      parentInversedTransform = this.inverseMatrix3x3(parentTransform);
    }

    if (parentInversedTransform) {
      const rpx = area.px * area.w;
      const rpy = area.py * area.h;
      const B = parentInversedTransform;
      const A = this.multiplyMatrices(this.translationMatrix(rpx, rpy), this.rotationMatrixInDegrees(area.r), this.scaleMatrix(area.sx, area.sy), this.translationMatrix(-rpx, -rpy));
      const d = x0 * A[2][0] + y0 * A[2][1] + A[2][2];

      if (!this.tooSmall(d)) {
        const Xc = x0 * A[0][0] + y0 * A[0][1] + A[0][2];
        const Yc = x0 * A[1][0] + y0 * A[1][1] + A[1][2];
        return {
          x: (B[0][0] * x + B[0][1] * y + B[0][2] - Xc) / d,
          y: (B[1][0] * x + B[1][1] * y + B[1][2] - Yc) / d
        };
      }
    }

    return null;
  },

  /**
   * Converts value to 0 in case it is null or undefined
   * @param {Number} value
   * @returns {Number}
   */
  nonNullNumber(value) {
    if (value == null) {
      return 0;
    }

    return value;
  },

  averagePoint(...points) {
    let x = 0,
        y = 0;
    points.forEach(p => {
      x += p.x;
      y += p.y;
    });

    if (points.length > 0) {
      return {
        x: x / points.length,
        y: y / points.length
      };
    }

    return {
      x,
      y
    };
  },

  /**
   * Calculates new offset for a box after its rotation around its own center so that its center would stay the same
   * @param {Number} originalX - x of top left corner of a box
   * @param {Number} originalY - y of top left corner of a box
   * @param {Number} centerX - original center of the box
   * @param {Number} centerY - original center of the box
   * @param {Number} angle - rotated angle in radians
   * @returns {Point} point with {x, y} of the new top left corner position
   */
  calculateRotationOffsetForSameCenter(originalX, originalY, centerX, centerY, angle) {
    const ax = originalX - centerX;
    const ay = originalY - centerY;
    const cosa = Math.cos(angle);
    const sina = Math.sin(angle);
    const bx = ax * cosa - ay * sina;
    const by = ax * sina + ay * cosa;
    return {
      x: centerX + bx,
      y: centerY + by
    };
  },

  rotateVector90Clockwise(x, y) {
    return {
      x: -y,
      y: x
    };
  },

  rotateVector90CounterClockwise(x, y) {
    return {
      x: y,
      y: -x
    };
  }

});

/***/ }),

/***/ 3086:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "vq": () => (/* binding */ getDefaultFont),
/* harmony export */   "It": () => (/* binding */ getFontFamilyFor),
/* harmony export */   "_W": () => (/* binding */ getAllFonts)
/* harmony export */ });
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
const FONTS_ENCODED = ['Arial, Helvetica, sans-serif', '"Arial Black", Gadget, sans-serif', '"Book Antiqua", Palatino, serif', '"Comic Sans MS", cursive, sans-serif', '"Courier New", Courier, monospace', 'Georgia, serif', 'Helvetica, sans-serif', 'Impact, Charcoal, sans-serif', '"Lucida Grande", sans-serif', '"Lucida Sans Unicode", "Lucida Grande", sans-serif', '"Lucida Console", Monaco, monospace', 'Monaco, monospace', '"Palatino Linotype", "Book Antiqua", Palatino, serif', 'Tahoma, Geneva, sans-serif', '"Times New Roman", Times, serif', '"Trebuchet MS", Helvetica, sans-serif', 'Verdana, Geneva, sans-serif', 'Alfa Slab One', 'Cherry Swash', 'Caveat Brush', 'Heebo', 'Carter One', 'Permanent Marker', 'Josefin Sans', 'Cherry Swash', 'Josefin Sans', 'Knewave'];

function loadFonts() {
  const fonts = {};

  for (let i = 0; i < FONTS_ENCODED.length; i++) {
    let commaIdx = FONTS_ENCODED[i].indexOf(',');
    let fontName = FONTS_ENCODED[i].trim();

    if (commaIdx > 0) {
      fontName = FONTS_ENCODED[i].substring(0, commaIdx).trim();
    }

    if (fontName.charAt(0) === '"' && fontName.charAt(fontName.length - 1) === '"') {
      fontName = fontName.substring(1, fontName.length - 1);
    }

    fonts[fontName] = FONTS_ENCODED[i];
  }

  return fonts;
}

function createFontsList(fonts) {
  const fontsList = [];

  for (let fontName in fonts) {
    if (fonts.hasOwnProperty(fontName)) {
      fontsList.push({
        name: fontName,
        family: fonts[fontName]
      });
    }
  }

  fontsList.sort((a, b) => {
    if (a.name < b.name) {
      return -1;
    } else if (a.name > b.name) {
      return 1;
    }

    return 0;
  });
  return fontsList;
}

const FONTS = loadFonts();
const FONTS_LIST = createFontsList(FONTS);
function getDefaultFont() {
  return 'Arial';
}
function getFontFamilyFor(fontName) {
  const family = FONTS[fontName];

  if (family) {
    return family;
  }

  return 'Arial, Helvetica, sans-serif';
}
function getAllFonts() {
  return FONTS_LIST;
}

/***/ }),

/***/ 7196:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pp": () => (/* binding */ ItemInteractionMode),
/* harmony export */   "td": () => (/* binding */ defaultTextSlotProps),
/* harmony export */   "$9": () => (/* binding */ STANDARD_SHAPE_PROPS),
/* harmony export */   "kT": () => (/* binding */ defaultItemDefinition),
/* harmony export */   "XZ": () => (/* binding */ defaultItem),
/* harmony export */   "Hp": () => (/* binding */ traverseItems),
/* harmony export */   "U3": () => (/* binding */ hasItemDescription),
/* harmony export */   "u2": () => (/* binding */ getItemPropertyDescriptionForShape)
/* harmony export */ });
/* unused harmony exports textWhiteSpaceOptions, textSlotProperties, prettyTextSlotProperty, coreItemPropertyTypes, defaultifyItem, applyStyleFromAnotherItem */
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4691);
/* harmony import */ var _components_editor_items_shapes_Shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3363);
/* harmony import */ var _Fonts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3086);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4486);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _defaultify__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2643);
/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5161);
/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_map__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var lodash_find__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(3311);
/* harmony import */ var lodash_find__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_find__WEBPACK_IMPORTED_MODULE_6__);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */







const ItemInteractionMode = {
  NONE: 'none',
  SIDE_PANEL: 'side-panel',
  TOOLTIP: 'tooltip',

  values() {
    return _utils_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"].enumerateConstants */ .Z.enumerateConstants(this);
  }

};
const textWhiteSpaceOptions = [{
  name: 'Wrap',
  value: 'normal'
}, {
  name: 'No Wrap',
  value: 'nowrap'
}, {
  name: 'Preserved',
  value: 'pre'
}, {
  name: 'Preserved + Wrap',
  value: 'pre-wrap'
}];
const textSlotProperties = [{
  field: 'color',
  name: 'Color',
  type: 'color'
}, {
  field: 'halign',
  name: 'Horizontal Align',
  type: 'choice',
  options: ['left', 'center', 'right']
}, {
  field: 'valign',
  name: 'Vertical Align',
  type: 'choice',
  options: ['top', 'middle', 'bottom']
}, {
  field: 'fontSize',
  name: 'Font Size',
  type: 'number'
}, {
  field: 'whiteSpace',
  name: 'White Space',
  type: 'choice',
  options: textWhiteSpaceOptions
}, {
  field: 'font',
  name: 'Font',
  type: 'choice',
  options: lodash_map__WEBPACK_IMPORTED_MODULE_5___default()((0,_Fonts__WEBPACK_IMPORTED_MODULE_2__/* .getAllFonts */ ._W)(), font => font.name)
}, {
  field: 'paddingLeft',
  name: 'Padding Left',
  type: 'number'
}, {
  field: 'paddingRight',
  name: 'Padding Right',
  type: 'number'
}, {
  field: 'paddingTop',
  name: 'Padding Top',
  type: 'number'
}, {
  field: 'paddingBottom',
  name: 'Padding Bottom',
  type: 'number'
}];
function prettyTextSlotProperty(propertyName) {
  for (let i = 0; i < textSlotProperties.length; i++) {
    if (textSlotProperties[i].field === propertyName) {
      return textSlotProperties[i].name;
    }
  }

  return propertyName;
}
const defaultTextSlotProps = {
  text: '',
  color: 'rgba(0,0,0,1.0)',
  halign: 'center',
  // can be: left, center, right
  valign: 'middle',
  // can be: top, middle, bottom,
  fontSize: 14,
  whiteSpace: 'normal',
  font: (0,_Fonts__WEBPACK_IMPORTED_MODULE_2__/* .getDefaultFont */ .vq)(),
  paddingLeft: 0,
  paddingRight: 0,
  paddingTop: 0,
  paddingBottom: 0
};
const STANDARD_SHAPE_PROPS = {
  fill: {
    type: 'solid',
    color: 'rgba(240,240,240,1.0)'
  },
  strokeColor: 'rgba(30,30,30,1.0)',
  strokeSize: 2,
  strokePattern: 'solid'
};
const defaultArea = {
  x: 0,
  y: 0,
  w: 0,
  h: 0,
  r: 0,
  px: 0.5,
  py: 0.5,
  // pivot point coords relative to items width and height
  sx: 1.0,
  sy: 1.0
};
const coreItemPropertyTypes = {
  opacity: {
    type: 'number'
  },
  selfOpacity: {
    type: 'number'
  },
  visible: {
    type: 'boolean'
  },
  clip: {
    type: 'boolean'
  }
};
const defaultItemDefinition = {
  area: defaultArea,
  opacity: 100,
  selfOpacity: 100,
  visible: true,
  tags: [],
  links: [],
  blendMode: 'normal',
  cursor: 'default',
  shape: 'none',
  clip: false,
  effects: [],
  textSlots: {
    '*': defaultTextSlotProps
  },
  description: '',
  interactionMode: ItemInteractionMode.TOOLTIP,
  behavior: {
    events: []
  },
  shapeProps: {},
  tooltipBackground: 'rgba(230,230,230,1.0)',
  tooltipColor: 'rgba(30,30,30,1.0)'
};
const defaultItem = {
  cursor: 'default',
  area: defaultArea,
  shape: 'empty',
  opacity: 100.0,
  blendMode: 'normal',
  name: '',
  description: '',
  links: [],
  textSlots: {},
  behavior: {
    events: []
  } // childItems: [], // used dynamically in case there are child items
  // _childItems: [], // used dynamically by components and it stores items that were copied from the referrence item. This field is ignored when saving or exporting

};
const shapePropsDefaults = {};

function getShapePropsDefaults(shapeId) {
  if (shapePropsDefaults[shapeId]) {
    return shapePropsDefaults[shapeId];
  }

  const shape = Shape.find(shapeId);

  if (shape) {
    shapePropsDefaults[shapeId] = {};
    forEach(shape.args, (arg, argName) => {
      shapePropsDefaults[shapeId][argName] = utils.clone(arg.value);
    });

    if (shape.shapeType === 'standard') {
      forEach(STANDARD_SHAPE_PROPS, (value, argName) => {
        shapePropsDefaults[shapeId][argName] = utils.clone(value);
      });
    }

    return shapePropsDefaults[shapeId];
  }

  return {};
}

function defaultifyItem(item) {
  const shapeId = item.shape;
  const resultedItem = defaultifyObject(item, defaultItemDefinition);
  const resultedShapeProps = defaultifyObject(resultedItem.shapeProps, getShapePropsDefaults(shapeId));

  if (resultedShapeProps) {
    resultedItem.shapeProps = resultedShapeProps;
  } else {
    delete resultedItem.shapeProps;
  }

  return resultedItem;
}
function traverseItems(rootItem, callback) {
  callback(rootItem);

  if (rootItem.childItems) {
    lodash_forEach__WEBPACK_IMPORTED_MODULE_3___default()(rootItem.childItems, item => {
      traverseItems(item, callback);
    });
  }

  if (rootItem._childItems) {
    lodash_forEach__WEBPACK_IMPORTED_MODULE_3___default()(rootItem._childItems, item => {
      traverseItems(item, callback);
    });
  }
}
/**
 *
 * @param {Item} item
 * @returns true if item has meaningfull description
 */

function hasItemDescription(item) {
  /*
  This is very dirty but it is the simplest way to check if the item has a proper description
  If would only check for non-empty strings, then it would still show side panel
  even when description is an empty paragraph like "<p></p>"
  This happens when you use rich text editor and delete the entire description.
  Obviously it would be better to check for actual text elements inside the strings but it is also an overkill.
  */
  return item.description.trim().length > 8;
}

const _supportedStyleTypes = new Set(['color', 'advanced-color', 'stroke-pattern', 'path-cap', 'number']);
/**
 * Applies item styling (shapeProps) to item based on the shapeProps of reference item
 * It only applies simple props and does not change element selectors, path-points etc.
 * @param {Item} referenceItem
 * @param {Item} dstItem
 */


function applyStyleFromAnotherItem(referenceItem, dstItem) {
  const srcShape = Shape.find(referenceItem.shape);

  if (!srcShape) {
    return;
  }

  const dstShape = Shape.find(dstItem.shape);

  if (!dstShape) {
    return;
  }

  forEach(referenceItem.shapeProps, (value, propName) => {
    const propDescriptor = Shape.getShapePropDescriptor(srcShape, propName);
    const dstPropDescriptor = Shape.getShapePropDescriptor(dstShape, propName);

    if (propDescriptor && dstPropDescriptor && propDescriptor.type === dstPropDescriptor.type && _supportedStyleTypes.has(propDescriptor.type)) {
      dstItem.shapeProps[propName] = utils.clone(value);
    }
  });
  forEach(referenceItem.textSlots, (refTextSlot, slotName) => {
    if (!dstItem.textSlots.hasOwnProperty(slotName)) {
      return;
    }

    forEach(defaultTextSlotProps, (val, propName) => {
      if (propName === 'text') {
        return;
      }

      dstItem.textSlots[slotName][propName] = utils.clone(refTextSlot[propName]);
    });
  });
}
function getItemPropertyDescriptionForShape(shape, propertyPath) {
  const corePropType = coreItemPropertyTypes[propertyPath];

  if (corePropType) {
    return corePropType;
  }

  if (shape && propertyPath.indexOf('shapeProps.') === 0) {
    const shapeArgName = propertyPath.substr('shapeProps.'.length);

    if (shape.shapeType === 'standard' && _components_editor_items_shapes_Shape__WEBPACK_IMPORTED_MODULE_1__/* ["default"].standardShapeProps.hasOwnProperty */ .Z.standardShapeProps.hasOwnProperty(shapeArgName)) {
      return _components_editor_items_shapes_Shape__WEBPACK_IMPORTED_MODULE_1__/* ["default"].standardShapeProps */ .Z.standardShapeProps[shapeArgName];
    }

    if (shape.args.hasOwnProperty(shapeArgName)) {
      return shape.args[shapeArgName];
    }
  } else if (propertyPath.indexOf('textSlots.') === 0) {
    const secondDotPosition = propertyPath.indexOf('.', 'textSlots.'.length + 1);
    const textSlotField = propertyPath.substr(secondDotPosition + 1);
    const argumentDescription = lodash_find__WEBPACK_IMPORTED_MODULE_6___default()(textSlotProperties, textSlotProperty => textSlotProperty.field === textSlotField);

    if (argumentDescription) {
      return argumentDescription;
    }
  }

  return null;
}

/***/ }),

/***/ 1377:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "z9": () => (/* binding */ enrichItemWithDefaults),
/* harmony export */   "q4": () => (/* binding */ enrichItemTextSlotWithDefaults)
/* harmony export */ });
/* unused harmony export enrichItemWithDefaultShapeProps */
/* harmony import */ var _Item__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7196);
/* harmony import */ var _components_editor_items_shapes_Shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3363);
/* harmony import */ var shortid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4670);
/* harmony import */ var shortid__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(shortid__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _defaultify__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2643);
/* harmony import */ var _components_editor_items_shapes_StandardCurves_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8270);
/* harmony import */ var _userevents_functions_Functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3013);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(4486);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(4691);









function idFixer(obj) {
  if (!obj.id) {
    obj.id = shortid__WEBPACK_IMPORTED_MODULE_2___default().generate();
  }
}

function enrichItemWithStandardShapeProps(item) {
  (0,_defaultify__WEBPACK_IMPORTED_MODULE_3__/* .enrichObjectWithDefaults */ .I)(item.shapeProps, _Item__WEBPACK_IMPORTED_MODULE_0__/* .STANDARD_SHAPE_PROPS */ .$9);
}
/**
 *
 * @param {*} action
 * @returns {Boolean} true if action is valid, false if it is not valid. In such case the action will be removed
 */


function fixAndEnrichBehaviorAction(action) {
  idFixer(action);
  const func = _userevents_functions_Functions_js__WEBPACK_IMPORTED_MODULE_5__/* ["default"].main */ .Z.main[action.method];

  if (!func) {
    return false;
  }

  if (!action.args) {
    action.args = {};
  }

  lodash_forEach__WEBPACK_IMPORTED_MODULE_6___default()(func.args, (arg, argName) => {
    if (!action.args.hasOwnProperty(argName)) {
      action.args[argName] = arg.value;
    }
  });
  lodash_forEach__WEBPACK_IMPORTED_MODULE_6___default()(action.args, (arg, argName) => {
    if (!func.args.hasOwnProperty(argName)) {
      delete action.args[argName];
    }
  });
  return true;
}

function fixAndEnrichBehaviorEvents(behavior) {
  lodash_forEach__WEBPACK_IMPORTED_MODULE_6___default()(behavior.events, event => {
    idFixer(event);
    lodash_forEach__WEBPACK_IMPORTED_MODULE_6___default()(event.actions, fixAndEnrichBehaviorAction);

    for (let i = event.actions.length - 1; i >= 0; i--) {
      if (!fixAndEnrichBehaviorAction(event.actions[i])) {
        event.actions.splice(i, 1);
      }
    }
  });
}
/**
 * This function is needed since curves were changed to support multiple paths in a single curve item
 * Also the shape id changed from "curve" to "path"
 * @param {*} item
 */


function fixOldCurveItem(item) {
  item.shape = 'path';

  if (!Array.isArray(item.shapeProps.paths) && Array.isArray(item.shapeProps.points)) {
    item.shapeProps.paths = [{
      points: item.shapeProps.points,
      closed: item.shapeProps.closed
    }];
    delete item.shapeProps.points;
  }
}

function fixPathToRelativePlacement(item) {
  if (Array.isArray(item.shapeProps.paths)) {
    item.shapeProps.paths.forEach(path => {
      if (path.pos !== 'relative') {
        path.pos = 'relative';

        if (Array.isArray(path.points)) {
          path.points = path.points.map(point => {
            return (0,_components_editor_items_shapes_StandardCurves_js__WEBPACK_IMPORTED_MODULE_4__/* .convertCurvePointToRelative */ .Vk)(point, item.area.w, item.area.h);
          });
        }
      }
    });
  }
}
/**
 * Used for backwards compatibilty and it merges "groups" array with "tags"
 */


function fixOldGroups(item) {
  if (Array.isArray(item.groups)) {
    const tags = new Set(item.groups);

    if (Array.isArray(item.tags)) {
      item.tags.forEach(tag => tags.add(tag));
    }

    item.tags = Array.from(tags);
    delete item.groups;
  }
}

function enrichItemWithDefaults(item) {
  if (!item.textSlots) {
    item.textSlots = {};
  }

  if (!item.shape) {
    item.shape = 'none';
  } // fixing old documents before curves were moved into multi-path shapes


  if (item.shape === 'curve') {
    fixOldCurveItem(item);
  }

  if (item.shape === 'path') {
    fixPathToRelativePlacement(item);
  }

  (0,_defaultify__WEBPACK_IMPORTED_MODULE_3__/* .enrichObjectWithDefaults */ .I)(item, _Item__WEBPACK_IMPORTED_MODULE_0__/* .defaultItemDefinition */ .kT);
  fixOldGroups(item);
  fixAndEnrichBehaviorEvents(item.behavior);
  lodash_forEach__WEBPACK_IMPORTED_MODULE_6___default()(item.links, idFixer);
  let shape = _components_editor_items_shapes_Shape__WEBPACK_IMPORTED_MODULE_1__/* ["default"].find */ .Z.find(item.shape);

  if (!shape) {
    return;
  }

  lodash_forEach__WEBPACK_IMPORTED_MODULE_6___default()(shape.args, (arg, argName) => {
    if (!item.shapeProps.hasOwnProperty(argName)) {
      item.shapeProps[argName] = _utils__WEBPACK_IMPORTED_MODULE_7__/* ["default"].clone */ .Z.clone(arg.value);
    } else if (typeof item.shapeProps[argName] === 'object') {
      (0,_defaultify__WEBPACK_IMPORTED_MODULE_3__/* .enrichObjectWithDefaults */ .I)(item.shapeProps[argName], shape.args[argName].value);
    }
  });

  if (shape.shapeType === 'standard') {
    enrichItemWithStandardShapeProps(item);
  } // Some getTextSlots functions in some shapes rely on specific fields in shapeProps
  // that is why it is important to enrich all shapeProps before we call getTextSlots function


  const textSlots = shape.getTextSlots(item);

  if (textSlots) {
    lodash_forEach__WEBPACK_IMPORTED_MODULE_6___default()(textSlots, textSlot => {
      if (!item.textSlots.hasOwnProperty(textSlot.name)) {
        item.textSlots[textSlot.name] = {};
        enrichItemTextSlotWithDefaults(item.textSlots[textSlot.name]);
      }
    });
  }
}
function enrichItemTextSlotWithDefaults(textSlot) {
  return (0,_defaultify__WEBPACK_IMPORTED_MODULE_3__/* .enrichObjectWithDefaults */ .I)(textSlot, _Item__WEBPACK_IMPORTED_MODULE_0__/* .defaultTextSlotProps */ .td);
}
function enrichItemWithDefaultShapeProps(item) {
  const shape = Shape.find(item.shape);

  if (!shape) {
    return;
  }

  if (shape.args) {
    if (!item.shapeProps) {
      item.shapeProps = {};
    }

    forEach(shape.args, (shapeArg, shapeArgName) => {
      if (!item.shapeProps.hasOwnProperty(shapeArgName)) {
        item.shapeProps[shapeArgName] = shapeArg.value;
      }
    });
  }
}

/***/ }),

/***/ 8566:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ZP": () => (/* binding */ scheme_SchemeContainer),
  "aR": () => (/* binding */ itemCompleteTransform),
  "Ym": () => (/* binding */ relativePointForItem),
  "rs": () => (/* binding */ worldPointOnItem),
  "pD": () => (/* binding */ worldScalingVectorOnItem),
  "uI": () => (/* binding */ worldVectorOnItem)
});

// UNUSED EXPORTS: DEFAULT_ITEM_MODIFICATION_CONTEXT, ITEM_MODIFICATION_CONTEXT_RESIZED, ITEM_MODIFICATION_CONTEXT_ROTATED, localPointOnItem, localPointOnItemToLocalPointOnOtherItem, worldAngleOfItem

// EXTERNAL MODULE: ./node_modules/lodash/map.js
var lodash_map = __webpack_require__(5161);
var map_default = /*#__PURE__*/__webpack_require__.n(lodash_map);
// EXTERNAL MODULE: ./node_modules/lodash/forEach.js
var forEach = __webpack_require__(4486);
var forEach_default = /*#__PURE__*/__webpack_require__.n(forEach);
// EXTERNAL MODULE: ./node_modules/lodash/filter.js
var filter = __webpack_require__(3105);
var filter_default = /*#__PURE__*/__webpack_require__.n(filter);
// EXTERNAL MODULE: ./node_modules/lodash/keys.js
var keys = __webpack_require__(3674);
var keys_default = /*#__PURE__*/__webpack_require__.n(keys);
// EXTERNAL MODULE: ./node_modules/lodash/indexOf.js
var indexOf = __webpack_require__(3651);
var indexOf_default = /*#__PURE__*/__webpack_require__.n(indexOf);
// EXTERNAL MODULE: ./node_modules/lodash/findIndex.js
var findIndex = __webpack_require__(998);
var findIndex_default = /*#__PURE__*/__webpack_require__.n(findIndex);
// EXTERNAL MODULE: ./node_modules/lodash/find.js
var find = __webpack_require__(3311);
var find_default = /*#__PURE__*/__webpack_require__.n(find);
;// CONCATENATED MODULE: ./src/ui/SpatialIndex.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
class QuadTreeNode {
  constructor(x, y, value) {
    this.point = {
      x,
      y
    };
    this.value = value; // north west

    /** @type {QuadTreeNode} */

    this.nw = null; // north east

    /** @type {QuadTreeNode} */

    this.ne = null; // south west

    /** @type {QuadTreeNode} */

    this.sw = null; // south east

    /** @type {QuadTreeNode} */

    this.se = null;
  }
  /**
   * 
   * @param {Number} x - value on x axis
   * @param {Number} y - value on y axis
   * @param {*} value - value that stored at this point
   */


  addPoint(x, y, value) {
    if (x >= this.point.x && y >= this.point.y) {
      this.se = insertPoint(this.se, x, y, value);
    } else if (x <= this.point.x && y >= this.point.y) {
      this.sw = insertPoint(this.sw, x, y, value);
    } else if (x >= this.point.x && y <= this.point.y) {
      this.ne = insertPoint(this.ne, x, y, value);
    } else {
      this.nw = insertPoint(this.nw, x, y, value);
    }
  }

  forEachInRange(x1, y1, x2, y2, callback) {
    if (x1 <= this.point.x && this.point.x <= x2 && y1 <= this.point.y && this.point.y <= y2) {
      callback(this.value, this.point);
    }

    if (this.se && (x1 >= this.point.x || x2 >= this.point.x) && (y1 >= this.point.y || y2 >= this.point.y)) {
      this.se.forEachInRange(x1, y1, x2, y2, callback);
    }

    if (this.sw && (x1 <= this.point.x || x2 <= this.point.x) && (y1 >= this.point.y || y2 >= this.point.y)) {
      this.sw.forEachInRange(x1, y1, x2, y2, callback);
    }

    if (this.ne && (x1 >= this.point.x || x2 >= this.point.x) && (y1 <= this.point.y || y2 <= this.point.y)) {
      this.ne.forEachInRange(x1, y1, x2, y2, callback);
    }

    if (this.nw && (x1 <= this.point.x || x2 <= this.point.x) && (y1 <= this.point.y || y2 <= this.point.y)) {
      this.nw.forEachInRange(x1, y1, x2, y2, callback);
    }
  }

}

function insertPoint(node, x, y, value) {
  if (!node) {
    return new QuadTreeNode(x, y, value);
  }

  node.addPoint(x, y, value);
  return node;
} // Quad Tree based index for storing points


class SpatialIndex {
  constructor() {
    this.root = null;
  }
  /**
   * 
   * @param {Number} x - value on x axis
   * @param {Number} y - value on y axis
   * @param {*} value - value that stored at this point
   */


  addPoint(x, y, value) {
    if (!this.root) {
      this.root = new QuadTreeNode(x, y, value);
    } else {
      this.root.addPoint(x, y, value);
    }
  }

  forEachInRange(x1, y1, x2, y2, callback) {
    if (!this.root) {
      return [];
    }

    const result = [];
    this.root.forEachInRange(x1, y1, x2, y2, callback);
  }

}
;// CONCATENATED MODULE: ./src/ui/collections.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

/**
 * Searches of occurences of all names and tries to create a unique name
 * based on given namePrefix. It adds auto-incrementing index as a suffix
 * @param {string} namePrefix - a prefix for a name
 * @param {Array} names - array of existing names
 */
function giveUniqueName(namePrefix, names) {
  let largestIndex = -1;

  for (let i = 0; i < names.length; i++) {
    const name = names[i];

    if (name.startsWith(namePrefix)) {
      const leftOverPart = name.substring(namePrefix.length).trim();

      if (leftOverPart.length > 0) {
        if (!isNaN(leftOverPart)) {
          const index = parseInt(leftOverPart);

          if (index > largestIndex) {
            largestIndex = index;
          }
        }
      } else {
        // looks like it already has the same name (we don't take empty space into account)
        // but first lets check if there already was a compination of namePrefix + index
        if (largestIndex < 0) {
          largestIndex = 1;
        }
      }
    }
  }

  if (largestIndex >= 0) {
    return `${namePrefix} ${largestIndex + 1}`;
  }

  return namePrefix;
}

/* harmony default export */ const collections = ({
  giveUniqueName
});
// EXTERNAL MODULE: ./src/ui/myMath.js
var myMath = __webpack_require__(3590);
// EXTERNAL MODULE: ./src/ui/utils.js
var ui_utils = __webpack_require__(4691);
// EXTERNAL MODULE: ./node_modules/shortid/index.js
var shortid = __webpack_require__(4670);
var shortid_default = /*#__PURE__*/__webpack_require__.n(shortid);
// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/Shape.js
var Shape = __webpack_require__(3363);
// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/Component.vue + 4 modules
var Component = __webpack_require__(332);
// EXTERNAL MODULE: ./src/ui/scheme/Item.js
var Item = __webpack_require__(7196);
// EXTERNAL MODULE: ./src/ui/scheme/ItemFixer.js
var ItemFixer = __webpack_require__(1377);
// EXTERNAL MODULE: ./src/defaultify.js
var defaultify = __webpack_require__(2643);
;// CONCATENATED MODULE: ./src/ui/scheme/Scheme.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




const defaultScheme = {
  name: '',
  description: '',
  tags: [],
  categoryId: null,
  items: [],
  settings: {
    screen: {
      draggable: true
    }
  },
  style: {
    backgroundColor: 'rgba(240, 240, 240, 1.0)',
    gridColor: 'rgba(128 ,128, 128, 0.2)',
    boundaryBoxColor: 'rgba(36, 182, 255, 1)',
    controlPointsColor: 'rgba(4,177,23, 1.0)',
    itemMarkerColor: 'rgba(36, 182, 255, 1)',
    itemMarkerToggled: false
  }
};
function enrichSchemeWithDefaults(scheme) {
  (0,defaultify/* enrichObjectWithDefaults */.I)(scheme, defaultScheme);
}
function defaultifyScheme(scheme) {
  const resultedScheme = defaultifyObject(scheme, defaultScheme);
  resultedScheme.items = map(resultedScheme.items, item => defaultifyItem(item));
  return resultedScheme;
}
function prepareSchemeForSaving(scheme) {
  const schemeCopy = utils.clone(scheme);
  const sanitizedScheme = utils.sanitizeScheme(schemeCopy);
  return defaultifyScheme(sanitizedScheme);
}
// EXTERNAL MODULE: ./src/ui/logger.js
var logger = __webpack_require__(2017);
// EXTERNAL MODULE: ./src/ui/userevents/functions/Functions.js + 32 modules
var Functions = __webpack_require__(3013);
// EXTERNAL MODULE: ./src/ui/components/editor/EventBus.js
var EventBus = __webpack_require__(536);
// EXTERNAL MODULE: ./src/ui/animations/ValueAnimation.js
var ValueAnimation = __webpack_require__(3805);
// EXTERNAL MODULE: ./src/ui/colors.js
var colors = __webpack_require__(6012);
// EXTERNAL MODULE: ./src/ui/animations/Animation.js
var Animation = __webpack_require__(2217);
;// CONCATENATED MODULE: ./src/ui/scheme/ItemConst.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

/*
    The following constants were moved from Item.js file.
    It was necessary due to webpack for some reason not handling the dependencies in test scope
    In the main bundle everything was ok.
*/
//TODO move the rest of the constants here in a such way that this file does not depend on other scripts
const knownBlendModes = ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'];
// EXTERNAL MODULE: ./src/ui/animations/functions/MoveAlongPathAnimationFunction.js
var MoveAlongPathAnimationFunction = __webpack_require__(3277);
;// CONCATENATED MODULE: ./src/ui/animations/functions/AnimationFunctions.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

/* harmony default export */ const AnimationFunctions = ({
  moveAlongPath: MoveAlongPathAnimationFunction/* default */.Z
});
;// CONCATENATED MODULE: ./src/ui/animations/FrameAnimation.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */









const NUMBER = 'number';
const COLOR = 'color';
const BOOLEAN = 'boolean';
const STRING = 'string';
const CHOICE = 'choice';
const knownPropertyTypes = new Set([NUMBER, COLOR, STRING, BOOLEAN, CHOICE]);
const knownProperties = new Map([['area.x', {
  type: NUMBER
}], ['area.y', {
  type: NUMBER
}], ['area.w', {
  type: NUMBER
}], ['area.h', {
  type: NUMBER
}], ['area.r', {
  type: NUMBER
}], ['area.sx', {
  type: NUMBER
}], ['area.sy', {
  type: NUMBER
}], ['opacity', {
  type: NUMBER
}], ['selfOpacity', {
  type: NUMBER
}], ['visible', {
  type: BOOLEAN
}], ['blendMode', {
  type: STRING,
  options: knownBlendModes
}]]);
const knownSchemeProperties = new Map([['style.backgroundColor', {
  type: COLOR
}]]);
/**
 * Finds supported scheme property descriptor for specified path
 * @param {String} propertyPath 
 * @returns 
 */

function findSchemePropertyDescriptor(propertyPath) {
  return knownSchemeProperties.get(propertyPath);
}
/**
 * Find a property descriptor for specified property path. In case the type is not supported for animations it returns null
 * @param {Item} item 
 * @param {String} propertyPath 
 * @returns 
 */

function findItemPropertyDescriptor(item, propertyPath) {
  const descriptor = knownProperties.get(propertyPath);

  if (descriptor) {
    return descriptor;
  }

  if (propertyPath.startsWith('shapeProps.')) {
    const fields = propertyPath.split('.');

    if (fields.length <= 1) {
      return null;
    }

    const shape = Shape/* default.find */.Z.find(item.shape);

    if (!shape) {
      return null;
    }

    const arg = Shape/* default.getShapePropDescriptor */.Z.getShapePropDescriptor(shape, fields[1]);

    if (!arg) {
      return null;
    }

    if (arg.type === COLOR || arg.type === 'advanced-color' && fields.length === 3 && fields[2] === 'color') {
      return {
        type: COLOR
      };
    } else {
      if (knownPropertyTypes.has(arg.type)) {
        return arg;
      }
    }
  }

  return null;
}

function buildFrameLookup(frames, totalFrames) {
  frames.sort((a, b) => {
    return a.frame - b.frame;
  });
  const frameLookup = [];

  const addBlankFrames = (num, prevIdx, nextIdx) => {
    const blankFrame = {
      prevIdx,
      nextIdx
    };

    for (let i = 0; i < num; i++) {
      frameLookup.push(blankFrame);
    }
  };

  let previosActiveFrameIdx = -1;
  forEach_default()(frames, f => {
    // protecting from duplicate frames
    if (previosActiveFrameIdx >= 0) {
      if (frameLookup[previosActiveFrameIdx].frame.frame === f.frame) {
        // looks like there is a duplicate
        return;
      }
    }

    const activeFrame = {
      frame: f,
      prevIdx: previosActiveFrameIdx,
      nextIdx: -1
    };

    if (f.frame - 1 > frameLookup.length) {
      // should fill with empty cells first and then add the frame
      addBlankFrames(f.frame - 1 - frameLookup.length, previosActiveFrameIdx, f.frame - 1);
    }

    frameLookup.push(activeFrame);

    if (previosActiveFrameIdx >= 0) {
      frameLookup[previosActiveFrameIdx].nextIdx = f.frame - 1;
    }

    previosActiveFrameIdx = f.frame - 1;
  });

  if (frameLookup.length < totalFrames) {
    addBlankFrames(totalFrames - frameLookup.length, previosActiveFrameIdx, -1);
  }

  return frameLookup;
}

function interpolateValue(propertyType, value1, value2, t) {
  if (propertyType === NUMBER) {
    return value1 * (1 - t) + t * value2;
  } else if (propertyType === COLOR) {
    const c1 = (0,colors/* parseColor */.l)(value1);
    const c2 = (0,colors/* parseColor */.l)(value2);
    const color = {
      r: c1.r * (1 - t) + t * c2.r,
      g: c1.g * (1 - t) + t * c2.g,
      b: c1.b * (1 - t) + t * c2.b,
      a: c1.a * (1 - t) + t * c2.a
    };
    return (0,colors/* encodeColor */.N)(color);
  }

  return value1;
}

function interpolateFrameValues(frameNum, prevFrame, nextFrame, propertyType) {
  if (prevFrame.kind === ValueAnimation/* Interpolations.STEP */.jU.STEP) {
    return prevFrame.value;
  }

  if (propertyType === NUMBER || propertyType === COLOR) {
    let d = nextFrame.frame - prevFrame.frame;

    if (d > 0 && frameNum >= prevFrame.frame && frameNum <= nextFrame.frame) {
      const t = (0,ValueAnimation/* convertTime */.rJ)((frameNum - prevFrame.frame) / d, prevFrame.kind);
      return interpolateValue(propertyType, prevFrame.value, nextFrame.value, t);
    }
  }

  return prevFrame.value;
}

function creatObjectFrameAnimation(obj, propertyPath, propertyDescriptor, frames, totalFrames, isItem) {
  if (!propertyDescriptor) {
    return null;
  }

  const fields = propertyPath.split('.');
  const frameLookup = buildFrameLookup(frames, totalFrames);
  return {
    toggleFrame(frame) {
      if (frame < 1) {
        return;
      }

      const frameNum = Math.floor(frame);
      let indexFrame = null;

      if (frameNum <= frameLookup.length) {
        indexFrame = frameLookup[frameNum - 1];
      } else {
        indexFrame = frameLookup[frameLookup.length - 1];
      }

      let left = indexFrame;

      if (!indexFrame.frame) {
        if (indexFrame.prevIdx < 0) {
          return;
        }

        left = frameLookup[indexFrame.prevIdx];
      }

      let right = null;

      if (indexFrame.nextIdx >= 0) {
        right = frameLookup[indexFrame.nextIdx];
      }

      let value = left.frame.value;

      if (right) {
        value = interpolateFrameValues(frame, left.frame, right.frame, propertyDescriptor.type);
      }

      ui_utils/* default.setObjectProperty */.Z.setObjectProperty(obj, fields, value);

      if (isItem) {
        EventBus/* default.emitItemChanged */.Z.emitItemChanged(obj.id);
      }
    }

  };
}

function createFunctionFrameAnimation(functionDescriptor, instance, inputTracks, totalFrames) {
  const frameLookupForInput = {};
  forEach_default()(inputTracks, (inputTrack, inputName) => {
    frameLookupForInput[inputName] = buildFrameLookup(inputTrack.frames, totalFrames);
  });
  return {
    toggleFrame(frame) {
      if (frame < 1) {
        return;
      }

      const frameNum = Math.floor(frame);
      const inputValues = {};
      let missingInputValues = false;
      forEach_default()(frameLookupForInput, (frameLookup, inputName) => {
        let indexFrame = null;

        if (frameNum <= frameLookup.length) {
          indexFrame = frameLookup[frameNum - 1];
        } else {
          indexFrame = frameLookup[frameLookup.length - 1];
        }

        let left = indexFrame;

        if (!indexFrame.frame) {
          if (indexFrame.prevIdx < 0) {
            missingInputValues = true;
            return;
          }

          left = frameLookup[indexFrame.prevIdx];
        }

        let right = null;

        if (indexFrame.nextIdx >= 0) {
          right = frameLookup[indexFrame.nextIdx];
        }

        let value = left.frame.value;

        if (right) {
          value = interpolateFrameValues(frame, left.frame, right.frame, functionDescriptor.inputs[inputName].type);
        }

        inputValues[inputName] = value;
      });

      if (!missingInputValues) {
        functionDescriptor.execute(instance, inputValues);
      }
    }

  };
}

function compileAnimationFunctions(framePlayer, functionAnimationTracks, schemeContainer) {
  const animations = [];
  forEach_default()(framePlayer.shapeProps.functions, (framePlayerFunction, playerFunctionId) => {
    if (!functionAnimationTracks[playerFunctionId]) {
      return;
    }

    const functionDescriptor = AnimationFunctions[framePlayerFunction.functionId];

    if (!functionDescriptor) {
      return;
    }

    const preparedInstance = functionDescriptor.create(framePlayerFunction.args, schemeContainer);
    const inputTracks = {}; // making sure that all inputs have at least one frame

    forEach_default()(functionDescriptor.inputs, (inputDescriptor, inputName) => {
      if (functionAnimationTracks[playerFunctionId][inputName]) {
        inputTracks[inputName] = functionAnimationTracks[playerFunctionId][inputName];
      } else {
        inputTracks[inputName] = {
          kind: 'function',
          functionId: playerFunctionId,
          property: inputName,
          frames: [{
            frame: 0,
            kind: 'linear',
            value: inputDescriptor.value // using default value

          }]
        };
      }
    });
    const animation = createFunctionFrameAnimation(functionDescriptor, preparedInstance, inputTracks, framePlayer.shapeProps.totalFrames);

    if (animation) {
      animations.push(animation);
    }
  });
  return animations;
}

function compileAnimations(framePlayer, schemeContainer) {
  const animations = [];
  const functionAnimationTracks = {};
  forEach_default()(framePlayer.shapeProps.animations, animation => {
    if (animation.kind === 'item') {
      const item = schemeContainer.findItemById(animation.id);

      if (item) {
        const propertyDescriptor = findItemPropertyDescriptor(item, animation.property);
        const itemAnimation = creatObjectFrameAnimation(item, animation.property, propertyDescriptor, animation.frames, framePlayer.shapeProps.totalFrames, true);

        if (itemAnimation) {
          animations.push(itemAnimation);
        }
      }
    } else if (animation.kind === 'function') {
      if (!functionAnimationTracks.hasOwnProperty(animation.id)) {
        functionAnimationTracks[animation.id] = {};
      }

      functionAnimationTracks[animation.id][animation.property] = animation;
    } else if (animation.kind === 'scheme') {
      const propertyDescriptor = findSchemePropertyDescriptor(animation.property);
      const schemeAnimation = creatObjectFrameAnimation(schemeContainer.scheme, animation.property, propertyDescriptor, animation.frames, framePlayer.shapeProps.totalFrames, false);

      if (schemeAnimation) {
        animations.push(schemeAnimation);
      }
    }
  });
  return animations.concat(compileAnimationFunctions(framePlayer, functionAnimationTracks, schemeContainer));
}
const MIN_FPS = 0.01;
class FrameAnimation extends Animation/* default */.Z {
  constructor(fps, totalFrames, compiledAnimations) {
    super();
    this.totalTimePassed = 0;
    this.currentFrame = 0;
    this.startFrame = 1;
    this.fps = fps;
    this.totalFrames = totalFrames;
    this.compiledAnimations = compiledAnimations;
    this.onFrame = null;
    this.onFinish = null;
    this.stopFrame = -1;
  }

  setFrame(frame) {
    this.startFrame = frame;
    this.currentFrame = Math.floor(frame) - 1;
  }

  setStopFrame(stopFrame) {
    this.stopFrame = stopFrame;
  }

  init() {
    this.totalTimePassed = 0;
    return true;
  }

  setCallbacks({
    onFrame,
    onFinish
  }) {
    this.onFrame = onFrame;
    this.onFinish = onFinish;
  }

  play(dt) {
    this.totalTimePassed += dt;
    let frame = this.startFrame + this.totalTimePassed * Math.max(this.fps, MIN_FPS) / 1000;
    let nextFrame = Math.floor(frame);

    if (nextFrame > this.currentFrame) {
      this.currentFrame = nextFrame;

      if (this.onFrame) {
        this.onFrame(this.currentFrame);
      }
    }

    const floorFrame = Math.floor(frame);
    const reachedStopFrame = this.stopFrame > 0 && floorFrame === this.stopFrame;

    if (reachedStopFrame) {
      if (this.onFrame) {
        this.onFrame(this.stopFrame);
      }

      this.toggleFrame(this.stopFrame);
      return false;
    }

    this.toggleFrame(frame);

    if (nextFrame < this.totalFrames) {
      return true;
    }

    return false;
  }

  toggleFrame(frame) {
    this.startFrame = frame;
    this.totalTimePassed = 0;
    this.currentFrame = frame;
    forEach_default()(this.compiledAnimations, animation => {
      animation.toggleFrame(frame);
    });
  }

  destroy() {
    if (this.onFinish) {
      this.onFinish();
    }
  }

}
;// CONCATENATED MODULE: ./src/ui/scheme/SchemeContainer.js
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */























const log = new logger/* Logger */.Yd('SchemeContainer'); // for now putting it here until I figure out a more elegant way of indexing item outline points
// There is a problem when the items are scaled too litle and when user zooms in to that downscaled item
// In that case it would not be able to find points in the quad tree as the generated points are too sparse
// Therefore we need to compensate for that and use this const value as the minimum search range

const minSpatialIndexDistance = 20;
const DEFAULT_ITEM_MODIFICATION_CONTEXT = {
  id: '',
  moved: true,
  rotated: false,
  resized: false
};
const ITEM_MODIFICATION_CONTEXT_RESIZED = {
  moved: false,
  rotated: false,
  resized: true,
  id: ''
};
const ITEM_MODIFICATION_CONTEXT_ROTATED = {
  moved: false,
  rotated: true,
  resized: false,
  id: ''
};
function worldPointOnItem(x, y, item) {
  return myMath/* default.worldPointInArea */.Z.worldPointInArea(x, y, item.area, item.meta && item.meta.transformMatrix ? item.meta.transformMatrix : null);
}
function localPointOnItem(x, y, item) {
  return myMath/* default.localPointInArea */.Z.localPointInArea(x, y, item.area, item.meta && item.meta.transformMatrix ? item.meta.transformMatrix : null);
}
function localPointOnItemToLocalPointOnOtherItem(x, y, srcItem, dstItem) {
  const worldPoint = worldPointOnItem(x, y, srcItem);
  return localPointOnItem(worldPoint.x, worldPoint.y, dstItem);
}
function worldAngleOfItem(item) {
  const v = worldVectorOnItem(item.area.w, 0, item);
  return myMath/* default.fullAngleForVector */.Z.fullAngleForVector(v.x, v.y) * 180 / Math.PI;
}
function worldVectorOnItem(x, y, item) {
  const p0 = worldPointOnItem(0, 0, item);
  const p1 = worldPointOnItem(x, y, item);
  return {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
}
/**
 * converts worlds coords to local point in the transform of the parent of the item
 * In case item has no parents - it returns the world coords
 * @param {*} x world position x
 * @param {*} y world position y
 * @param {*} item
 */

function relativePointForItem(x, y, item) {
  if (item.meta.parentId) {
    const parentItem = this.findItemById(item.meta.parentId);

    if (parentItem) {
      return this.localPointOnItem(x, y, parentItem);
    }
  }

  return {
    x,
    y
  };
}
/**
 * Calculates scaling effect of the item relative to the world
 * This is needed for proper computation of control points for scaled items
 * @param {Item} item
 * @returns {Point}
 */

function worldScalingVectorOnItem(item) {
  const topLengthVector = worldVectorOnItem(1, 0, item);
  const leftLengthVector = worldVectorOnItem(0, 1, item);
  return {
    x: myMath/* default.vectorLength */.Z.vectorLength(topLengthVector.x, topLengthVector.y),
    y: myMath/* default.vectorLength */.Z.vectorLength(leftLengthVector.x, leftLengthVector.y)
  };
}
function itemCompleteTransform(item) {
  const parentTransform = item.meta && item.meta.transformMatrix ? item.meta.transformMatrix : myMath/* default.identityMatrix */.Z.identityMatrix();
  return myMath/* default.standardTransformWithArea */.Z.standardTransformWithArea(parentTransform, item.area);
}

function createDefaultRectItem() {
  const item = ui_utils/* default.clone */.Z.clone(Item/* defaultItem */.XZ);
  item.shape = 'rect';
  (0,ItemFixer/* enrichItemWithDefaults */.z9)(item);
  return item;
}

function updateItemRevision(item) {
  item.meta.revision = ((item.meta.revision || 0) + 1) % 1000;
}

function visitItems(items, callback, transformMatrix, parentItem, ancestorIds, isIndexable) {
  if (!items) {
    return;
  }

  if (!transformMatrix) {
    transformMatrix = myMath/* default.identityMatrix */.Z.identityMatrix();
  }

  if (!ancestorIds) {
    ancestorIds = [];
  }

  if (isIndexable === undefined) {
    isIndexable = true;
  }

  for (let i = 0; i < items.length; i++) {
    // this has to be done here as the item might not yet be fully enriched
    // also the app optimizes schemes on saving and removes fields with default values
    (0,defaultify/* enrichObjectWithDefaults */.I)(items[i].area, Item/* defaultItemDefinition.area */.kT.area);
    callback(items[i], transformMatrix, parentItem, ancestorIds, isIndexable);
    const itemTransform = myMath/* default.standardTransformWithArea */.Z.standardTransformWithArea(transformMatrix, items[i].area);

    if (items[i].childItems) {
      visitItems(items[i].childItems, callback, itemTransform, items[i], ancestorIds.concat([items[i].id]), isIndexable);
    }

    if (items[i]._childItems) {
      visitItems(items[i]._childItems, callback, itemTransform, items[i], ancestorIds.concat([items[i].id]), false);
    }
  }
} // used for computing closest points to item paths
// it caches paths of items and resets the cache in case the items were reindexed


class ItemCache {
  /**
   *
   * @param {Function} cacheMissFallback
   */
  constructor(cacheMissFallback) {
    this.itemPaths = new Map();
    this.cacheMissFallback = cacheMissFallback;
  }
  /**
   *
   * @param {Item} item
   */


  get(item) {
    const entry = this.itemPaths.get(item.id);

    if (entry && entry.revision === item.meta.revision) {
      return entry.value;
    }

    return this.forceUpdate(item);
  }

  forceUpdate(item) {
    const value = this.cacheMissFallback(item);
    this.itemPaths.set(item.id, {
      revision: item.meta.revision,
      value
    });
    return value;
  }

}
/*
Providing access to scheme elements and provides modifiers for it
*/


class SchemeContainer {
  /**
   *
   * @param {Scheme} scheme
   * @param {EventBus} eventBus
   */
  constructor(scheme, eventBus) {
    logger/* Debugger.register */.qc.register('SchemioContainer', this);
    this.scheme = scheme;
    this.screenTransform = {
      x: 0,
      y: 0,
      scale: 1.0
    };
    this.screenSettings = {
      width: 700,
      height: 400,
      x1: -1000000,
      y1: -1000000,
      x2: 1000000,
      y2: 1000000
    };
    this.eventBus = eventBus; // contains an array of items that were selected

    this.selectedItems = []; // used to quick access to item selection state

    this.selectedItemsMap = {};
    this.activeBoundaryBox = null;
    this.itemMap = {};
    this._itemArray = []; // stores all flatten items (all sub-items are stored as well). it only stores indexable items

    this.revision = 0;
    this.hudItems = []; //used for storing hud items that are supposed to be rendered in the viewport transform

    this.worldItems = []; // used for storing top-level items with default area

    this.worldItemAreas = new Map(); // used for storing rough item bounding areas in world transform (used for finding suitable parent)

    this.dependencyItemMap = {}; // used for looking up items that should be re-adjusted once the item area is changed (e.g. curve item can be attached to other items)

    this.itemCloneIds = new Map(); // stores Set of item ids that were cloned and attached to the component from the reference item

    this.itemCloneReferenceIds = new Map(); // stores ids of reference items that were used for cloned items

    this._itemTagsToIds = {}; // used for quick access to item ids via item tags

    this.itemTags = []; // stores tags from all items

    this.framePlayers = []; // stores all frame players so that later it can prepare all animations

    this.spatialIndex = new SpatialIndex(); // used for indexing item path points

    this.pinSpatialIndex = new SpatialIndex(); // used for indexing item pins
    // contains mapping of frame player id to its compiled animations

    this.framesAnimations = {};
    this.componentItems = []; // map of component id to reference item id

    this.componentCyclicIndex = new Map();
    this.outlinePointsCache = new Map(); // stores points of item outlines so that it doesn't have to recompute it for items that were not changed

    this.svgOutlinePathCache = new ItemCache(item => {
      log.info('Computing shape outline for item', item.id, item.name);
      const shape = Shape/* default.find */.Z.find(item.shape);

      if (shape) {
        const path = shape.computeOutline(item);

        if (path) {
          const shadowSvgPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          shadowSvgPath.setAttribute('d', path);
          return shadowSvgPath;
        }
      }

      return null;
    }); // stores all snapping rules for items (used when user drags an item)

    this.relativeSnappers = {
      horizontal: [],
      vertical: []
    }; // Used to drag, resize and rotate multiple items
    // Since both the SvgEditor component and StateDragItem state needs access to it, it is easier to keep it here

    this.multiItemEditBox = null;
    enrichSchemeWithDefaults(this.scheme);
    this.reindexItems();
  }
  /**
   * Recalculates transform for each child item of specified item.
   * It is needed when user drags an item that has sub-items.
   * @param {Item} mainItem
   */


  updateChildTransforms(mainItem) {
    if (mainItem.childItems) {
      let parentTransform = myMath/* default.identityMatrix */.Z.identityMatrix();

      if (mainItem.meta && mainItem.meta.parentId) {
        const parentItem = this.findItemById(mainItem.meta.parentId);

        if (parentItem) {
          parentTransform = itemCompleteTransform(parentItem);
        }
      }

      const recalculatedTransform = myMath/* default.standardTransformWithArea */.Z.standardTransformWithArea(parentTransform, mainItem.area);

      const callback = (item, transformMatrix, parentItem, ancestorIds) => {
        if (!item.meta) {
          item.meta = {};
        }

        item.meta.transformMatrix = transformMatrix;
      };

      visitItems(mainItem.childItems, callback, recalculatedTransform, mainItem, mainItem.meta.ancestorIds);
    }
  }

  reindexItems() {
    log.info('reindexItems()', this);
    log.time('reindexItems'); //TODO optimize it to not reconstruct all indices with every change (e.g. reindex only effected items. This obviously needs to be specified from the caller)

    this.itemMap = {};
    this._itemArray = [];
    this.worldItems = [];
    this._itemTagsToIds = {};
    this.worldItemAreas = new Map();
    this.relativeSnappers.horizontal = [];
    this.relativeSnappers.vertical = [];
    this.spatialIndex = new SpatialIndex();
    this.pinSpatialIndex = new SpatialIndex();
    this.dependencyItemMap = {};
    this.itemCloneIds = new Map();
    this.itemCloneReferenceIds = new Map();
    this.framePlayers = [];
    this.componentItems = [];
    this.componentCyclicIndex = new Map();

    if (!this.scheme.items) {
      return;
    }

    this.reindexSpecifiedItems(this.scheme.items);
    this.reindexComponents();
    this.fixComponentCyclicDependencies();
    log.timeEnd('reindexItems');
  }

  reindexComponents() {
    forEach_default()(this.componentItems, item => this.reindexEmbeddedComponent(item));
  }

  reindexEmbeddedComponent(item) {
    if (item.shapeProps.kind === 'embedded' && item.shapeProps.referenceItem) {
      const referenceItem = this.findFirstElementBySelector(item.shapeProps.referenceItem);

      if (referenceItem) {
        this.componentCyclicIndex.set(item.id, referenceItem.id);

        const rootItem = _objectSpread(_objectSpread({}, referenceItem), {}, {
          meta: _objectSpread(_objectSpread({}, referenceItem.meta), {}, {
            componentRoot: true
          }),
          shape: 'none',
          opacity: 100,
          selfOpacity: 100,
          visible: true,
          shapeProps: {}
        });

        this.attachItemsToComponentItem(item, [rootItem]);
        this.eventBus.emitItemChanged(item.id);
      }
    }
  }

  fixComponentCyclicDependencies() {
    const visitedIds = new Set();

    const traverseReferenceItem = item => {
      forEach_default()(item.childItems, childItem => {
        if (childItem.shape === 'component') {
          visitComponent(childItem);
        } else {
          traverseReferenceItem(childItem);
        }
      });
    };

    const visitComponent = componentItem => {
      if (visitedIds.has(componentItem.id)) {
        // this is dirty code. We waste time on enriching components and only later check their dependecies
        // and clean up in case a cyclic dependency is detected
        componentItem._childItems = [];
        componentItem.meta.cyclicComponent = true;
        return false;
      }

      visitedIds.add(componentItem.id);
      const referenceItem = this.findItemById(this.componentCyclicIndex.get(componentItem.id));

      if (referenceItem) {
        traverseReferenceItem(referenceItem);
      }

      return true;
    };

    this.componentItems.forEach(componentItem => {
      visitedIds.clear();
      visitComponent(componentItem);
    });
  }

  attachItemsToComponentItem(componentItem, referenceItems) {
    if (!referenceItems) {
      return;
    }

    const preserveOriginalNames = true;
    const shouldIndexClones = true;
    const childItems = this.cloneItems(referenceItems, preserveOriginalNames, shouldIndexClones);
    const bBox = this.getBoundingBoxOfItems(referenceItems);
    forEach_default()(childItems, item => {
      item.area.x -= bBox.x;
      item.area.y -= bBox.y; // resetting the visiblity of component root items
      // so that the reference item can be hidden and not effect the component

      item.opacity = 100;
      item.selfOpacity = 100;
      item.visible = true; // also clearing item tags for root items
      // This is needed because reference items can have tags,
      // which could be used to hide multiple items in a single event
      // We don't want that event to get triggered for cloned component root items

      item.tags = [];
    });
    let scale = 1.0,
        dx = 0,
        dy = 0;
    let w = Math.max(bBox.w, 0.00001);
    let h = Math.max(bBox.h, 0.00001);
    let sx = componentItem.area.w / w;
    let sy = componentItem.area.h / h;

    if (componentItem.shapeProps.placement === 'centered') {
      scale = Math.min(sx, sy);
      sx = scale;
      sy = scale;
      dx = (componentItem.area.w - w * sx) / 2;
      dy = (componentItem.area.h - h * sy) / 2;
    }

    const rectItem = createDefaultRectItem();
    rectItem.shape = 'dummy';
    rectItem.selfOpacity = 0;
    rectItem.id = shortid_default().generate();
    rectItem.meta = {
      isComponentContainer: true
    };
    rectItem.area.x = dx;
    rectItem.area.y = dy;
    rectItem.area.w = w;
    rectItem.area.h = h;
    rectItem.area.px = 0;
    rectItem.area.py = 0;
    rectItem.area.sx = sx;
    rectItem.area.sy = sy;
    rectItem._childItems = childItems;

    if (componentItem.shapeProps.kind === 'external') {
      const backButton = (0,Component/* generateComponentGoBackButton */.Si)(componentItem, rectItem.area, this.screenTransform);

      if (backButton) {
        rectItem._childItems.push(backButton);
      }
    }

    componentItem._childItems = [rectItem];
    const itemTransform = myMath/* default.standardTransformWithArea */.Z.standardTransformWithArea(componentItem.meta.transformMatrix, componentItem.area);
    const nonIndexable = false;
    this.reindexSpecifiedItems(componentItem._childItems, itemTransform, componentItem, componentItem.meta.ancestorIds.concat([componentItem.id]), nonIndexable);
  }

  readjustComponentContainerRect(componentItem) {
    if (!componentItem._childItems || componentItem._childItems.length === 0) {
      return;
    }

    if (!componentItem._childItems[0]._childItems || componentItem._childItems[0]._childItems.length === 0) {
      return;
    } //TODO optimize this code. It is executed only during resizing of edit box. The following data can be cached since there is only one edit box at a time.


    const referenceItems = [];

    componentItem._childItems[0]._childItems.forEach(cloneItem => {
      const referenceItemId = this.itemCloneReferenceIds.get(cloneItem.id);

      if (referenceItemId) {
        referenceItems.push(this.findItemById(referenceItemId));
      }
    });

    const bBox = this.getBoundingBoxOfItems(referenceItems);
    let scale = 1.0,
        dx = 0,
        dy = 0;
    let w = Math.max(bBox.w, 0.00001);
    let h = Math.max(bBox.h, 0.00001);
    let sx = componentItem.area.w / w;
    let sy = componentItem.area.h / h;

    if (componentItem.shapeProps.placement === 'centered') {
      scale = Math.min(sx, sy);
      sx = scale;
      sy = scale;
      dx = (componentItem.area.w - w * sx) / 2;
      dy = (componentItem.area.h - h * sy) / 2;
    }

    componentItem._childItems[0].area.x = dx;
    componentItem._childItems[0].area.y = dy;
    componentItem._childItems[0].area.w = w;
    componentItem._childItems[0].area.h = h;
    componentItem._childItems[0].area.sx = sx;
    componentItem._childItems[0].area.sy = sy;
  }

  reindexChildItems(mainItem) {
    const itemTransform = myMath/* default.standardTransformWithArea */.Z.standardTransformWithArea(mainItem.meta.transformMatrix, mainItem.area);

    if (mainItem.childItems) {
      this.reindexSpecifiedItems(mainItem.childItems, itemTransform, mainItem, mainItem.meta.ancestorIds.concat([mainItem.id]));
    }
  }

  reindexSpecifiedItems(items, transformMatrix, parentItem, ancestorIds, isIndexable) {
    if (isIndexable === undefined) {
      isIndexable = true;
    } // stores element selectors with their dependants
    // this will be used once it has visited all items
    // so that it can finally start puting ids of existing items into dependencyItemMap


    const dependencyElementSelectorMap = {};

    const registerDependant = (elementSelector, itemId) => {
      let dependants = dependencyElementSelectorMap[elementSelector] || [];
      dependants.push(itemId);
      dependencyElementSelectorMap[elementSelector] = dependants;
    };

    const newRevision = this.revision + 1;
    visitItems(items, (item, transformMatrix, parentItem, ancestorIds, isIndexable) => {
      if (isIndexable) {
        this._itemArray.push(item);
      }

      (0,ItemFixer/* enrichItemWithDefaults */.z9)(item);
      this.enrichItemMeta(item, transformMatrix, parentItem, ancestorIds);

      if (item.tags) {
        this.indexItemTags(item.id, item.tags);
      }

      if (parentItem && (parentItem.meta.isInHUD || parentItem.shape === 'hud')) {
        item.meta.isInHUD = true;
      }

      if (item.shape === 'component') {
        this.componentItems.push(item);
      }

      if (item.shape === 'frame_player') {
        this.framePlayers.push(item);
      } // only storing top-level items


      if (!parentItem) {
        this.worldItems.push(item);
      }

      if (item.shape === 'hud') {
        this.hudItems.push(item);
      }

      if (item.id) {
        this.itemMap[item.id] = item;
      }

      if (item.shape === 'connector') {
        if (item.shapeProps.sourceItem) {
          registerDependant(item.shapeProps.sourceItem, item.id);
        }

        if (item.shapeProps.destinationItem) {
          registerDependant(item.shapeProps.destinationItem, item.id);
        }
      } // calculating real visibility based on parents visibility


      let parentVisible = true;

      if (parentItem) {
        parentVisible = parentItem.meta.calculatedVisibility;
      }

      item.meta.calculatedVisibility = parentVisible && item.visible && item.opacity > 0; // generating item snappers

      const itemSnappers = this.generateItemSnappers(item);

      if (itemSnappers) {
        forEach_default()(itemSnappers, itemSnapper => {
          if (itemSnapper.snapperType === 'horizontal') {
            this.relativeSnappers.horizontal.push(itemSnapper);
          } else if (itemSnapper.snapperType === 'vertical') {
            this.relativeSnappers.vertical.push(itemSnapper);
          }
        });
      }

      if (isIndexable) {
        const shape = Shape/* default.find */.Z.find(item.shape);

        if (shape) {
          this.indexItemPins(item, shape);
        }

        this.indexItemOutlinePoints(item);
      }

      this.worldItemAreas.set(item.id, this.calculateItemWorldArea(item));
    }, transformMatrix, parentItem, ancestorIds, isIndexable);

    if (isIndexable) {
      this.buildDependencyItemMapFromElementSelectors(this.dependencyItemMap, dependencyElementSelectorMap);
    }

    this.itemTags = keys_default()(this._itemTagsToIds);
    this.itemTags.sort();
    this.revision = newRevision;
  } // Iterates recursively through all items and reindexes item tags.
  // These tags are going to be used in the element picker


  reindexTags() {
    this._itemTagsToIds = {};
    visitItems(this.scheme.items, (item, transformMatrix, parentItem, ancestorIds) => {
      if (item.tags) {
        this.indexItemTags(item.id, item.tags);
      }
    });
    this.itemTags = keys_default()(this._itemTagsToIds);
    this.itemTags.sort();
  }

  indexSingleCloneItem(referenceItemId, clonedItemId) {
    let set = null;

    if (this.itemCloneIds.has(referenceItemId)) {
      set = this.itemCloneIds.get(referenceItemId);
    } else {
      set = new Set();
      this.itemCloneIds.set(referenceItemId, set);
    }

    this.itemCloneReferenceIds.set(clonedItemId, referenceItemId);
    set.add(clonedItemId);
  }

  getItemCloneIds(referenceItemId) {
    return this.itemCloneIds.get(referenceItemId);
  }

  calculateItemWorldArea(item) {
    const points = [{
      x: 0,
      y: 0
    }, {
      x: item.area.w,
      y: 0
    }, {
      x: item.area.w,
      y: item.area.h
    }, {
      x: 0,
      y: item.area.h
    }];
    const worldPoints = map_default()(points, point => this.worldPointOnItem(point.x, point.y, item));
    const area = {
      x: worldPoints[0].x,
      y: worldPoints[0].y,
      w: 0,
      h: 0
    };
    forEach_default()(worldPoints, point => {
      if (area.x > point.x) {
        const oldX = area.x;
        area.x = point.x;
        area.w = oldX + area.w - point.x;
      } else if (point.x > area.x + area.w) {
        area.w = point.x - area.x;
      }

      if (area.y > point.y) {
        const oldY = area.y;
        area.y = point.y;
        area.h = oldY + area.h - point.y;
      } else if (point.y > area.y + area.h) {
        area.h = point.y - area.y;
      }
    });
    return area;
  }

  getItemWorldPinPoint(item, pinIndex) {
    const shape = Shape/* default.find */.Z.find(item.shape);

    if (!shape) {
      return null;
    }

    const pins = shape.getPins(item);

    if (pinIndex >= 0 && pinIndex < pins.length) {
      const pinPoint = pins[pinIndex];
      const worldPinPoint = this.worldPointOnItem(pinPoint.x, pinPoint.y, item); // we need to recalculate pins as the item might be rotated

      if (pinPoint.nx || pinPoint.ny) {
        const p0 = this.worldPointOnItem(0, 0, item);
        const p1 = this.worldPointOnItem(pinPoint.nx, pinPoint.ny, item);
        worldPinPoint.nx = p1.x - p0.x;
        worldPinPoint.ny = p1.y - p0.y;
      }

      return worldPinPoint;
    }

    return null;
  }

  indexItemPins(item, shape) {
    if (!shape) {
      return;
    }

    const points = shape.getPins(item);
    forEach_default()(points, (p, idx) => {
      const worldPoint = this.worldPointOnItem(p.x, p.y, item); // checking if pin point has normals and converting normal to world transform

      if (p.hasOwnProperty('nx')) {
        const w0 = this.worldPointOnItem(0, 0, item);
        const worldNormal = this.worldPointOnItem(p.nx, p.ny, item);
        worldPoint.nx = worldNormal.x - w0.x;
        worldPoint.ny = worldNormal.y - w0.y;
      }

      this.pinSpatialIndex.addPoint(worldPoint.x, worldPoint.y, {
        itemId: item.id,
        pinIndex: idx,
        worldPinPoint: worldPoint
      });
    });
  }

  indexItemOutlinePoints(item) {
    let pointsCache = this.outlinePointsCache.get(item.id);

    if (!pointsCache) {
      pointsCache = {
        revision: -1,
        points: []
      };
      this.outlinePointsCache.set(item.id, pointsCache);
    }

    if (pointsCache.revision === item.meta.revision && pointsCache.points.length > 0) {
      forEach_default()(pointsCache.points, p => {
        this.spatialIndex.addPoint(p[0], p[1], {
          itemId: item.id,
          pathDistance: p[2]
        });
      });
      return;
    }

    pointsCache.revision = item.meta.revision;

    const addPoint = (x, y, pathDistance) => {
      pointsCache.points.push([x, y, pathDistance]);
      this.spatialIndex.addPoint(x, y, {
        itemId: item.id,
        pathDistance
      });
    };

    const svgPath = this.getSvgOutlineOfItem(item);

    if (!svgPath) {
      return;
    }

    const totalLength = svgPath.getTotalLength();
    const totalPoints = Math.max(1, Math.ceil(totalLength / minSpatialIndexDistance)); // Doing a breadth-first indexing by taking midpoint of each segment
    // This is needed for more efficient indexing
    //
    // For instance if you have a straight line and you perform indexing linearly
    // - then the lookup of the last point would take O(n)
    //
    // But if you index it from the mid point and then do the same for each segment
    // - then lookup of any points of the segements would take at most O(log(n))
    //
    // That's why in this code is indexing by dividing each segment in half and indexes
    // mid points first

    let segments = [[0, totalPoints]];

    while (segments.length > 0) {
      const newSegments = [];

      for (let i = 0; i < segments.length; i++) {
        const a = segments[i][0];
        const b = segments[i][1];
        let pathDistance = -1;
        let diff = b - a;

        if (diff >= 2) {
          const mid = Math.floor((a + b) / 2);
          pathDistance = mid * minSpatialIndexDistance;

          if (mid > a) {
            newSegments.push([a, mid - 1]);
          }

          if (mid < b) {
            newSegments.push([mid + 1, b]);
          }
        } else if (diff >= 1) {
          pathDistance = b * minSpatialIndexDistance;
          newSegments.push([a, a]);
        } else if (diff >= 0) {
          pathDistance = a * minSpatialIndexDistance;
        }

        if (pathDistance >= 0) {
          const point = svgPath.getPointAtLength(pathDistance);
          const worldPoint = this.worldPointOnItem(point.x, point.y, item);
          addPoint(worldPoint.x, worldPoint.y, pathDistance);
        }
      }

      segments = newSegments;
    } // The following code is a lot simpler to understand, but it creates a less efficient index
    // because it indexes points linearly

    /*
    let pathDistance = 0;
    while (pathDistance < totalLength) {
        const point = svgPath.getPointAtLength(pathDistance);
        const worldPoint = this.worldPointOnItem(point.x, point.y, item);
        this.spatialIndex.addPoint(worldPoint.x, worldPoint.y, {
            itemId: item.id,
            pathDistance
        });
        pathDistance += minSpatialIndexDistance;
    }
    */

  }

  buildDependencyItemMapFromElementSelectors(dependencyItemMap, dependencyElementSelectorMap) {
    const registerDependants = (itemId, newDependants) => {
      let dependants = dependencyItemMap[itemId] || [];
      dependants = dependants.concat(newDependants);
      dependencyItemMap[itemId] = dependants;
    };

    forEach_default()(dependencyElementSelectorMap, (dependants, elementSelector) => {
      const mainItem = this.findFirstElementBySelector(elementSelector);

      if (mainItem) {
        registerDependants(mainItem.id, dependants);
      }
    });
  }
  /**
   * Used in case an item was moved. This is needed so that we only update transforms (in meta) for objects that are children of this item
   * @param {Item} item - item that was moved or rotated
   */


  reindexItemTransforms(item) {
    if (!item.childItems) {
      return;
    }

    const callback = (childItem, transformMatrix, parentItem, ancestorIds) => {
      childItem.meta.transformMatrix = transformMatrix;
    };

    const parentItem = this.findItemById(item.meta.parentId);
    visitItems(item.childItems, callback, item.meta.transformMatrix, parentItem, item.meta.ancestorIds);
  }

  indexItemTags(itemId, tags) {
    forEach_default()(tags, tag => {
      if (!this._itemTagsToIds.hasOwnProperty(tag)) {
        this._itemTagsToIds[tag] = [];
      }

      this._itemTagsToIds[tag].push(itemId);
    });
  }

  enrichItemMeta(item, transformMatrix, parentItem, ancestorIds) {
    if (!item.meta) {
      item.meta = {
        collapsed: false,
        // used only for item tree selector
        collapseBitMask: 0 // used in item tree selector and stores information about parent items collapse state

      };
    }

    item.meta.transformMatrix = transformMatrix;
    item.meta.ancestorIds = ancestorIds;

    if (!parentItem) {
      item.meta.collapseBitMask = 0;
    } else {
      item.meta.collapseBitMask = parentItem.meta.collapseBitMask << ancestorIds.length | (parentItem.meta.collapsed ? 1 : 0);
    }

    if (parentItem) {
      item.meta.parentId = parentItem.id;
    } else {
      item.meta.parentId = null;
    }
  }
  /**
   * This function should only be called after indexing of items is finished
   * because it relies on item having its transformationAreas assigned in its 'meta' object
   * It converts the point inside the item from its local coords to world coords
   *
   * @param {Number} x local position x
   * @param {Number} y local position y
   * @param {Item} item
   * @returns {Point}
   */


  worldPointOnItem(x, y, item) {
    return worldPointOnItem(x, y, item);
  }
  /**
   * Converts world point to local item coords
   * @param {Number} x world position x
   * @param {Number} y world position y
   * @param {Item} item
   * @returns {Point}
   */


  localPointOnItem(x, y, item) {
    return localPointOnItem(x, y, item);
  }
  /**
   * converts worlds coords to local point in the transform of the parent of the item
   * In case item has no parents - it returns the world coords
   * @param {*} x world position x
   * @param {*} y world position y
   * @param {*} item
   */


  relativePointForItem(x, y, item) {
    return relativePointForItem(x, y, item);
  }
  /**
   * Finds first item that is within specified distance to path
   * @param {Number} x - x axis of world coords
   * @param {Number} y - y axis of world coords
   * @param {Number} d - maximum distance to items path
   * @param {String} excludedId - item that should be excluded
   * @param {Boolean} onlyVisibleItems - specifies whether it should check only items that are visible
   * @returns {ItemClosestPoint}
   */


  findClosestPointToItems(x, y, d, excludedId, onlyVisibleItems) {
    let closestPin = null;
    this.pinSpatialIndex.forEachInRange(x - d, y - d, x + d, y + d, ({
      itemId,
      pinIndex,
      worldPinPoint
    }, point) => {
      if (itemId !== excludedId) {
        const distance = (x - point.x) * (x - point.x) + (y - point.y) * (y - point.y);

        if (!closestPin || closestPin.distance > distance) {
          closestPin = {
            itemId,
            pinIndex,
            point: worldPinPoint,
            distance
          };
        }
      }
    });

    if (closestPin) {
      const result = {
        x: closestPin.point.x,
        y: closestPin.point.y,
        distanceOnPath: -closestPin.pinIndex - 1,
        // converting it to the negative space, yeah yeah, that's hacky, I know.
        itemId: closestPin.itemId
      };

      if (closestPin.point.hasOwnProperty('nx')) {
        result.nx = closestPin.point.nx;
        result.ny = closestPin.point.ny;
      }

      return result;
    }

    const items = new Map(); // compensating for sparse points in the quad tree because originally,
    // when the index was created, it was using the distance of 20 between points on path

    const searchDistance = Math.max(d, minSpatialIndexDistance);
    this.spatialIndex.forEachInRange(x - searchDistance, y - searchDistance, x + searchDistance, y + searchDistance, ({
      itemId,
      pathDistance
    }, point) => {
      // if there are multiple points in the same item we want to select the closest ones
      // this way we late can get better precision when search for closest point on path, since we can pass the initial search range (startDistance, stopDistance)
      const squaredDistanceToPoint = (x - point.x) * (x - point.x) + (y - point.y) * (y - point.y);

      if (!items.has(itemId)) {
        items.set(itemId, {
          pathDistance,
          squaredDistanceToPoint
        });
      } else {
        const pathLocation = items.get(itemId);

        if (pathLocation.squaredDistanceToPoint > squaredDistanceToPoint) {
          items.set(itemId, {
            pathDistance,
            squaredDistanceToPoint
          });
        }
      }
    });
    let globalPoint = {
      x,
      y
    };
    let foundPoint = null;
    let bestSquaredDistance = 100000;
    items.forEach((pathLocation, itemId) => {
      const item = this.findItemById(itemId);

      if (item.id === excludedId) {
        return;
      }

      if (onlyVisibleItems && !item.meta.calculatedVisibility) {
        return;
      }

      const closestPoint = this.closestPointToItemOutline(item, globalPoint, {
        startDistance: Math.max(0, pathLocation.pathDistance - searchDistance),
        stopDistance: pathLocation.pathDistance + searchDistance,
        precision: Math.min(d / 2, 0.5)
      });

      if (!closestPoint) {
        return;
      }

      const squaredDistance = (closestPoint.x - globalPoint.x) * (closestPoint.x - globalPoint.x) + (closestPoint.y - globalPoint.y) * (closestPoint.y - globalPoint.y);

      if (squaredDistance < d * d) {
        const candidatePoint = {
          x: closestPoint.x,
          y: closestPoint.y,
          distanceOnPath: closestPoint.distanceOnPath,
          itemId: item.id
        };

        if (!foundPoint || bestSquaredDistance > squaredDistance) {
          foundPoint = candidatePoint;
          bestSquaredDistance = squaredDistance;
        }
      }
    });
    return foundPoint;
  }

  getBoundingBoxOfItems(items) {
    if (!items || items.length === 0) {
      return {
        x: 0,
        y: 0,
        w: 0,
        h: 0
      };
    }

    let range = null;
    forEach_default()(items, item => {
      const points = [this.worldPointOnItem(0, 0, item), this.worldPointOnItem(item.area.w, 0, item), this.worldPointOnItem(item.area.w, item.area.h, item), this.worldPointOnItem(0, item.area.h, item)];
      forEach_default()(points, point => {
        if (!range) {
          range = {
            x1: point.x,
            x2: point.x,
            y1: point.y,
            y2: point.y
          };
        } else {
          if (range.x1 > point.x) {
            range.x1 = point.x;
          }

          if (range.x2 < point.x) {
            range.x2 = point.x;
          }

          if (range.y1 > point.y) {
            range.y1 = point.y;
          }

          if (range.y2 < point.y) {
            range.y2 = point.y;
          }
        }
      });
    });
    const schemeBoundaryBox = {
      x: range.x1,
      y: range.y1,
      w: range.x2 - range.x1,
      h: range.y2 - range.y1
    };
    return schemeBoundaryBox;
  }
  /**
   * This function recursively goes into all items descendants and readjusts them
   * It is needed in situation when a parent item is dragged but its children have curve items attached to them.
   * In order to keep curve readjust their shapes we need to do it with this function
   * @param {*} itemId
   * @param {Boolean} isSoft
   * @param {ItemModificationContext} context
   * @param {Number} precision - number of digits after point which it should round to
   */


  readjustItemAndDescendants(itemId, isSoft, context, precision) {
    this._readjustItemAndDescendants(itemId, {}, isSoft, context, precision);
  }
  /**
   *
   * @param {*} itemId
   * @param {Object} visitedItems
   * @param {Boolean} isSoft
   * @param {ItemModificationContext} context
   * @param {Number} precision - number of digits after point which it should round to
   */


  _readjustItemAndDescendants(itemId, visitedItems, isSoft, context, precision) {
    this._readjustItem(itemId, visitedItems, isSoft, context, precision);

    const item = this.findItemById(itemId);

    if (!item) {
      return;
    }

    forEach_default()(item.childItems, childItem => {
      this._readjustItemAndDescendants(childItem.id, visitedItems, isSoft, context, precision);
    });
  }
  /**
   * Should be invoked each time an area or path of item changes
   * @param {String} changedItemId
   * @param {Boolean} isSoft specifies whether this is just a preview readjustment (e.g. curve items need to readjust their area, but only when user stopped dragging)
   * @param {ItemModificationContext} context
   * @param {Number} precision - number of digits after point which it should round to
   */


  readjustItem(changedItemId, isSoft, context, precision) {
    if (isNaN(precision)) {
      precision = 4;
    }

    this._readjustItem(changedItemId, {}, isSoft, context, precision);
  }
  /**
   *
   * @param {*} changedItem
   * @param {*} visitedItems - tracks all items that were already visited. Need in order to exclude eternal loops
   * @param {Boolean} isSoft specifies whether this is just a preview readjustment (e.g. curve items need to readjust their area, but only when user stopped dragging)
   * @param {ItemModificationContext} context
   * @param {Number} precision - number of digits after point which it should round to
   */


  _readjustItem(changedItemId, visitedItems, isSoft, context, precision) {
    if (isNaN(precision)) {
      precision = 4;
    }

    if (visitedItems[changedItemId]) {
      return;
    }

    visitedItems[changedItemId] = true;
    const item = this.findItemById(changedItemId);

    if (!item) {
      return;
    }

    const shape = Shape/* default.find */.Z.find(item.shape);

    if (shape && shape.readjustItem) {
      shape.readjustItem(item, this, isSoft, context, precision);
      updateItemRevision(item);

      if (this.eventBus) {
        this.eventBus.emitItemChanged(item.id);
      }

      this.svgOutlinePathCache.forceUpdate(item);
    } // searching for items that depend on changed item


    if (this.dependencyItemMap[changedItemId]) {
      forEach_default()(this.dependencyItemMap[changedItemId], dependantItemId => {
        this._readjustItem(dependantItemId, visitedItems, isSoft, context, precision);
      });
    } // scanning through children of the item and readjusting them as well


    forEach_default()(item.childItems, childItem => {
      this._readjustItem(childItem.id, visitedItems, isSoft, context, precision);
    });
  }

  remountItemToRoot(itemId) {
    const position = this.scheme.items.length;
    this.remountItemInsideOtherItem(itemId, null, position);
  }

  remountItemInsideOtherItemAtTheBottom(itemId, otherItemId) {
    if (!otherItemId) {
      return;
    }

    const otherItem = this.findItemById(otherItemId);

    if (!otherItem) {
      return;
    }

    let position = 0;

    if (otherItem.childItems) {
      position = otherItem.childItems.length;
    }

    this.remountItemInsideOtherItem(itemId, otherItemId, position);
  }

  remountItemInsideOtherItem(itemId, otherItemId, position) {
    const item = this.findItemById(itemId);

    if (!item) {
      return;
    }

    let otherItem = null;

    if (otherItemId) {
      otherItem = this.findItemById(otherItemId);

      if (!otherItem) {
        return;
      }
    }

    if (isNaN(position)) {
      position = 0;

      if (otherItem.childItems) {
        position = otherItem.childItems.length;
      }
    } //checking if item is moved into its own child items. It should be protected from such move, otherwise it is going to be an eternal loop


    if (otherItem && indexOf_default()(otherItem.meta.ancestorIds, item.id) >= 0) {
      return;
    } // Recalculating item area so that its world coords would match under new transform


    const topLeftWorldPoint = this.worldPointOnItem(0, 0, item);
    let previousParentWorldAngle = 0;
    let otherItemWorldAngle = 0;
    let newParentTransform = myMath/* default.identityMatrix */.Z.identityMatrix();

    if (otherItem) {
      newParentTransform = itemCompleteTransform(otherItem);
      otherItemWorldAngle = worldAngleOfItem(otherItem);
    }

    let previousParent = null;
    let previousParentId = null;
    let itemsArray = this.scheme.items;

    if (item.meta.parentId) {
      previousParent = this.findItemById(item.meta.parentId);

      if (!previousParent) {
        return;
      }

      previousParentId = previousParent.id;
      itemsArray = previousParent.childItems;
      previousParentWorldAngle = worldAngleOfItem(previousParent);
    }

    const index = findIndex_default()(itemsArray, it => it.id === itemId);

    if (index < 0) {
      return;
    } // removing item from its original position in array


    itemsArray.splice(index, 1);
    let newItemsArray = this.scheme.items;
    let newParentId = null;

    if (otherItem) {
      if (!otherItem.childItems) {
        otherItem.childItems = [];
      }

      newItemsArray = otherItem.childItems;
      newParentId = otherItem.id;
    }

    let positionCorrection = 0;

    if (previousParentId === newParentId && index < position) {
      // if item was located in the same parent and was above destination we need to correct its new position
      positionCorrection = -1;
    }

    newItemsArray.splice(position + positionCorrection, 0, item);
    item.area.r += previousParentWorldAngle - otherItemWorldAngle;
    const newLocalPoint = myMath/* default.findTranslationMatchingWorldPoint */.Z.findTranslationMatchingWorldPoint(topLeftWorldPoint.x, topLeftWorldPoint.y, 0, 0, item.area, newParentTransform);

    if (newLocalPoint) {
      item.area.x = newLocalPoint.x;
      item.area.y = newLocalPoint.y;
    }

    if (this.eventBus) {
      if (previousParentId) {
        this.eventBus.emitItemChanged(previousParentId);
      }

      if (newParentId) {
        this.eventBus.emitItemChanged(newParentId);
      }

      this.eventBus.emitSchemeChangeCommited();
    }

    this.reindexItems();
    this.updateMultiItemEditBox();
  }

  remountItemAfterOtherItem(itemId, otherItemId) {
    this.remountItemWithOffsetToOtherItem(itemId, otherItemId, 1);
  }

  remountItemBeforeOtherItem(itemId, otherItemId) {
    this.remountItemWithOffsetToOtherItem(itemId, otherItemId, 0);
  }

  remountItemWithOffsetToOtherItem(itemId, otherItemId, indexOffset) {
    const otherItem = this.findItemById(otherItemId);

    if (!otherItem) {
      return;
    }

    let itemsArray = this.scheme.items;
    let parent = null;

    if (otherItem.meta.parentId) {
      parent = this.findItemById(otherItem.meta.parentId);

      if (!parent) {
        return;
      }

      if (!parent.childItems) {
        parent.childItems = [];
      }

      itemsArray = parent.childItems;
    }

    const index = findIndex_default()(itemsArray, it => it.id === otherItemId);

    if (index < 0) {
      return;
    }

    let parentId = null;

    if (parent) {
      parentId = parent.id;
    }

    this.remountItemInsideOtherItem(itemId, parentId, index + indexOffset);
  }
  /**
   *
   * @param {Item} item
   * @returns {SVGPathElement}
   */


  getSvgOutlineOfItem(item) {
    return this.svgOutlinePathCache.get(item);
  }
  /**
   *
   * @param {*} item
   * @param {Point} globalPoint
   * @param {Object} settings specifies whether it should calculate the normal vector on the point on specified path
   * @param {ItemClosestPoint}
   */


  closestPointToItemOutline(item, globalPoint, {
    withNormal,
    startDistance,
    stopDistance,
    precision
  }) {
    // in order to include all parent items transform into closest point finding we need to first bring the global point into local transform
    const localPoint = this.localPointOnItem(globalPoint.x, globalPoint.y, item);
    const shadowSvgPath = this.svgOutlinePathCache.get(item);

    if (!shadowSvgPath) {
      return null;
    }

    const closestPoint = myMath/* default.closestPointOnPath */.Z.closestPointOnPath(localPoint.x, localPoint.y, shadowSvgPath, {
      startDistance,
      stopDistance,
      precision
    });
    const worldPoint = this.worldPointOnItem(closestPoint.x, closestPoint.y, item);
    worldPoint.distanceOnPath = closestPoint.distance;

    if (withNormal) {
      const normal = this.calculateNormalOnPointInItemOutline(item, closestPoint.distance, shadowSvgPath);
      worldPoint.bx = normal.x;
      worldPoint.by = normal.y;
    }

    return worldPoint;
  }
  /**
   * calculates normal of specified point on svg path
   * @param {*} item
   * @param {Number} distanceOnPath
   * @param {SVGPathElement} shadowSvgPath if not specified it will try to obtain svg path from items cache
   * @returns {Point}
   */


  calculateNormalOnPointInItemOutline(item, distanceOnPath, shadowSvgPath) {
    if (!shadowSvgPath) {
      shadowSvgPath = this.svgOutlinePathCache.get(item);

      if (!shadowSvgPath) {
        return {
          x: 1,
          y: 0
        };
      }
    }

    let leftPosition = distanceOnPath - 2;

    if (leftPosition < 0) {
      leftPosition = shadowSvgPath.getTotalLength() - leftPosition;
    }

    const pointA = shadowSvgPath.getPointAtLength(leftPosition);
    const pointB = shadowSvgPath.getPointAtLength((distanceOnPath + 2) % Math.max(1, shadowSvgPath.getTotalLength()));
    let vx = pointB.x - pointA.x;
    let vy = pointB.y - pointA.y; // rotating vector by 90 degrees, could have done it earlier but doing it explicitly, to keep algorithm clear

    let t = vx;
    vx = vy;
    vy = -t; // ^ calculated perpendicular vector in local to attachmentItem transform, now it should be converted to the world transform

    const topLeftCorner = this.worldPointOnItem(0, 0, item);
    const vectorOffset = this.worldPointOnItem(vx, vy, item);
    let Vx = vectorOffset.x - topLeftCorner.x;
    let Vy = vectorOffset.y - topLeftCorner.y; // normalizing vector

    const d = Math.sqrt(Vx * Vx + Vy * Vy);

    if (d > 0.0001) {
      Vx = Vx / d;
      Vy = Vy / d;
    }

    return {
      x: myMath/* default.roundPrecise */.Z.roundPrecise(Vx, 4),
      // we don't need a high precision for normals
      y: myMath/* default.roundPrecise */.Z.roundPrecise(Vy, 4)
    };
  }

  getSelectedItems() {
    return this.selectedItems;
  }

  deleteItem(item) {
    this._deleteItem(item); //TODO refactor it so that it does not have to run a full reindex


    this.reindexItems();
  }

  deleteItems(items) {
    forEach_default()(items, item => {
      this._deleteItem(item);
    });
    this.reindexItems();
  }

  _deleteItem(item) {
    if (this.outlinePointsCache.has(item.id)) {
      this.outlinePointsCache.delete(item.id);
    }

    let itemsArray = this.scheme.items;
    let parentItem = null;

    if (item.meta.parentId) {
      parentItem = this.findItemById(item.meta.parentId);

      if (!parentItem || !parentItem.childItems) {
        return;
      }

      itemsArray = parentItem.childItems;
    }

    const index = findIndex_default()(itemsArray, it => it.id === item.id);

    if (index < 0) {
      return;
    }

    itemsArray.splice(index, 1);

    if (parentItem) {
      this.eventBus.emitItemChanged(parentItem.id);
    }
  }

  deleteNonIndexableItems(items) {
    const itemSet = new Set();
    forEach_default()(items, item => itemSet.add(item.id));

    for (let i = this.scheme.items.length - 1; i >= 0 && itemSet.size > 0; i--) {
      const item = this.scheme.items[i];

      if (this.outlinePointsCache.has(item.id)) {
        this.outlinePointsCache.delete(item.id);
      }

      if (itemSet.has(item.id)) {
        delete this.itemMap[item.id];
        this.worldItemAreas.delete(item.id);
        itemSet.delete(item.id);
        this.scheme.items.splice(i, 1);
      }
    }
  }

  deleteSelectedItems() {
    if (this.selectedItems && this.selectedItems.length > 0) {
      forEach_default()(this.selectedItems, item => {
        delete this.selectedItemsMap[item.id];

        this._deleteItem(item);
      });
      this.selectedItems = [];
      this.multiItemEditBox = null;
      this.reindexItems(); // This event is needed to inform some components that they need to update their state because selection has dissapeared

      if (this.eventBus) this.eventBus.emitAnyItemDeselected();
    }
  }

  enrichItem(item) {
    (0,ItemFixer/* enrichItemWithDefaults */.z9)(item);

    if (!item.hasOwnProperty('meta')) {
      item.meta = {};
    }

    if (!item.id) {
      item.id = shortid_default().generate();
    }
  }

  addItem(item) {
    this.enrichItem(item);
    this.scheme.items.push(item);
    this.reindexSpecifiedItems([item]);

    if (item.shape === 'component' && item.shapeProps.kind === 'embedded') {
      this.reindexEmbeddedComponent(item);
    }

    return item;
  }

  addNonIndexableItem(item) {
    this.enrichItem(item);
    this.scheme.items.push(item);
    const nonIndexable = false;
    this.reindexSpecifiedItems([item], null, null, [], nonIndexable);
    return item;
  }

  getItems() {
    return this._itemArray;
  }

  getTopLevelItems() {
    return this.worldItems;
  }

  filterNonHUDItems(items) {
    return filter_default()(items, item => item.shape !== 'hud' && !item.meta.isInHUD);
  }

  isItemInHUD(item) {
    return item.shape === 'hud' || item.meta.isInHUD;
  }

  setActiveBoundaryBox(area) {
    this.activeBoundaryBox = area;
  }

  isItemSelected(item) {
    return this.selectedItemsMap[item.id] || false;
  }
  /**
   * Selects a specified item and deselects any other items that were selected previously
   * @param {SchemeItem} item
   * @param {boolean} inclusive Flag that specifies whether it should deselect other items
   */


  selectItem(item, inclusive) {
    if (inclusive) {
      this.selectItemInclusive(item);
      this.selectedItemsMap[item.id] = true;
      if (this.eventBus) this.eventBus.emitItemSelected(item.id);
    } else {
      const deselectedItemIds = [];
      forEach_default()(this.selectedItems, selectedItem => {
        if (selectedItem.id !== item.id) {
          deselectedItemIds.push(selectedItem.id);
        }
      });
      this.selectedItems = [];
      forEach_default()(deselectedItemIds, itemId => {
        this.selectedItemsMap[itemId] = false;
        if (this.eventBus) this.eventBus.emitItemDeselected(itemId);
      });
      this.selectItemInclusive(item);
      if (this.eventBus) this.eventBus.emitItemSelected(item.id);
    }

    this.updateMultiItemEditBox();
  }

  selectMultipleItems(items, inclusive) {
    if (!inclusive) {
      this.deselectAllItems();
    }

    forEach_default()(items, item => {
      this.selectedItems.push(item);
      this.selectedItemsMap[item.id] = true;
      if (this.eventBus) this.eventBus.emitItemSelected(item.id);
    });
    this.updateMultiItemEditBox();
  }

  selectAllItems() {
    this.selectMultipleItems(this._itemArray);
  }

  selectItemInclusive(item) {
    var isAlreadyIn = false;
    var i = 0;

    for (; i < this.selectedItems.length; i++) {
      if (this.selectedItems[i] === item) {
        isAlreadyIn = true;
        break;
      }
    }

    if (!isAlreadyIn) {
      this.selectedItems.push(item);
      this.selectedItemsMap[item.id] = true;
    }

    this.sortSelectedItemsByAncestors();
  }

  sortSelectedItemsByAncestors() {
    if (this.selectedItems) {
      this.selectedItems = this.selectedItems.sort((a, b) => {
        let la = 0;
        let lb = 0;

        if (a.meta.ancestorIds) {
          la = a.meta.ancestorIds.length;
        }

        if (b.meta.ancestorIds) {
          lb = b.meta.ancestorIds.length;
        }

        return la - lb;
      });
    }
  }
  /**
   * Deselect all previously selected items
   */


  deselectAllItems() {
    const itemIds = map_default()(this.selectedItems, item => item.id);
    forEach_default()(this.selectedItems, item => {
      this.selectedItemsMap[item.id] = false;
    });
    this.selectedItems = []; // First we should reset selectedItems array and only then emit event for each event
    // Some components check selectedItems array to get information whether item is selected or not

    if (this.eventBus) {
      forEach_default()(itemIds, itemId => this.eventBus.emitItemDeselected(itemId));
    }

    this.updateMultiItemEditBox();
  }
  /**
   * This is a recursive functions that goes through all sub-items
   * @param {Array} itemArray
   */


  bringSelectedItemsToBack(itemArray) {
    if (!itemArray) {
      itemArray = this.scheme.items;
    }

    let i = 0;
    let lastItems = [];

    while (i < itemArray.length) {
      if (itemArray[i].childItems) {
        this.bringSelectedItemsToBack(itemArray[i].childItems);
      }

      if (this.isItemSelected(itemArray[i])) {
        lastItems.push(itemArray[i]);
        itemArray.splice(i, 1);
      } else {
        i++;
      }
    }

    forEach_default()(lastItems, item => {
      itemArray.splice(0, 0, item);
    });
  }
  /**
   * This is a recursive functions that goes through all sub-items
   * @param {Array} itemArray
   */


  bringSelectedItemsToFront(itemArray) {
    if (!itemArray) {
      itemArray = this.scheme.items;
    }

    let i = 0;
    let topItems = [];

    while (i < itemArray.length) {
      if (itemArray[i].childItems) {
        this.bringSelectedItemsToFront(itemArray[i].childItems);
      }

      if (this.isItemSelected(itemArray[i])) {
        topItems.push(itemArray[i]);
        itemArray.splice(i, 1);
      } else {
        i++;
      }
    }

    forEach_default()(topItems, item => {
      itemArray.push(item);
    });
  }

  findItemById(itemId) {
    return this.itemMap[itemId];
  }

  findItemsByTag(tag) {
    const itemIds = this._itemTagsToIds[tag];
    const items = [];

    if (itemIds) {
      forEach_default()(itemIds, id => {
        const item = this.findItemById(id);

        if (item) {
          items.push(item);
        }
      });
    }

    return items;
  }

  findFirstElementBySelector(selector, selfItem) {
    const elements = this.findElementsBySelector(selector, selfItem);

    if (elements.length > 0) {
      return elements[0];
    }

    return null;
  }
  /**
   * Finds items that match specified selector
   * @param {String} selector contains a selector for an element
   * @param {SchemeItem} selfItem
   */


  findElementsBySelector(selector, selfItem) {
    if (selector === 'self') {
      return [selfItem];
    }

    if (selector.charAt(0) === '#') {
      const id = selector.substr(1);
      const item = this.findItemById(id);

      if (item) {
        return [item];
      }
    } else {
      const colonIndex = selector.indexOf(':');

      if (colonIndex > 0) {
        const expression = selector.substring(0, colonIndex);

        if (expression === 'tag') {
          return this.findItemsByTag(selector.substr(colonIndex + 1).trim());
        }
      }
    }

    return [];
  }

  copySelectedItems() {
    const copyBuffer = [];
    forEach_default()(this.selectedItems, item => {
      copyBuffer.push(ui_utils/* default.clone */.Z.clone(item));
    });
    return JSON.stringify(copyBuffer);
  }

  decodeItemsFromText(text) {
    let json = null;

    try {
      json = JSON.parse(text);
    } catch (err) {
      return null;
    } // verifying items


    if (!Array.isArray(json)) {
      return null;
    }

    for (let i = 0; i < json.length; i++) {
      const item = json[i];

      if (typeof item.area !== 'object' || item.area === null) {
        return null;
      }

      if (typeof item.shape !== 'string' || item.shape === null) {
        return null;
      }
    }

    return json;
  }
  /**
   * this is needed so that any changes applied to reference item gets immidiately reflected on all embedded component cloned items
   * @param {*} item
   * @param {*} setter
   */


  setPropertyForItem(item, setter) {
    setter(item);
    this.updatePropertyForClones(item, setter);
  }

  updatePropertyForClones(item, setter) {
    const cloneIds = this.getItemCloneIds(item.id);

    if (cloneIds) {
      cloneIds.forEach(cloneId => {
        const clonedItem = this.findItemById(cloneId);

        if (clonedItem && !clonedItem.meta.componentRoot) {
          this.setPropertyForItem(clonedItem, setter);
          this.eventBus.emitItemChanged(clonedItem.id);
        }
      });
    }
  }

  cloneItems(items, preserveOriginalNames, shouldIndexClones) {
    const copiedItemIds = {};
    const copiedItems = [];
    forEach_default()(items, item => {
      // checking whether any of ancestors were already copied for this item
      // as we don't need to copy it twice
      if (!find_default()(item.meta.ancestorIds, ancestorId => copiedItemIds[ancestorId] === 1)) {
        copiedItemIds[item.id] = 1;
        const worldPoint = this.worldPointOnItem(0, 0, item);
        const worldAngle = worldAngleOfItem(item);
        const newItem = this.copyItem(item);

        if (!preserveOriginalNames) {
          newItem.name = this.copyNameAndMakeUnique(item.name);
        } else {
          newItem.name = item.name;
        }

        newItem.area.x = worldPoint.x;
        newItem.area.y = worldPoint.y;
        newItem.area.r = worldAngle;

        if (item.meta.componentRoot) {
          newItem.meta.componentRoot = true;
        }

        copiedItems.push(newItem);
      }
    }); // collecting id conversions so that later it could be used for converting attached connectors

    const idOldToNewConversions = new Map();
    forEach_default()(copiedItems, copiedItem => {
      (0,Item/* traverseItems */.Hp)(copiedItem, item => {
        idOldToNewConversions.set(item.meta.oldId, item.id);

        if (shouldIndexClones) {
          this.indexSingleCloneItem(item.meta.oldId, item.id);
        }
      });
    }); //TODO OPTIMIZE: we don't need to execute code below for a scheme container in edit mode
    // recreates element selector in case the source or destination was also copied together with it

    const rebuildElementSelector = elementSelector => {
      if (elementSelector && elementSelector.indexOf('#') === 0) {
        const oldId = elementSelector.substr(1);

        if (idOldToNewConversions.has(oldId)) {
          return '#' + idOldToNewConversions.get(oldId);
        }
      }

      return elementSelector;
    };

    forEach_default()(copiedItems, copiedItem => {
      (0,Item/* traverseItems */.Hp)(copiedItem, item => {
        if (item.shape === 'connector') {
          item.shapeProps.sourceItem = rebuildElementSelector(item.shapeProps.sourceItem);
          item.shapeProps.destinationItem = rebuildElementSelector(item.shapeProps.destinationItem);
        }

        if (item.shape === 'frame_player') {
          forEach_default()(item.shapeProps.animations, animation => {
            if (animation.kind === 'item') {
              animation.id = idOldToNewConversions.get(animation.id);
            }
          });
          forEach_default()(item.shapeProps.functions, animationFunction => {
            const funcDef = AnimationFunctions[animationFunction.functionId];

            if (!funcDef) {
              return;
            }

            forEach_default()(funcDef.args, (argDef, argName) => {
              if (argDef.type === 'element') {
                animationFunction.args[argName] = rebuildElementSelector(animationFunction.args[argName]);
              }
            });
          });
        } // converting behavior events as well


        forEach_default()(item.behavior.events, behaviorEvent => {
          forEach_default()(behaviorEvent.actions, action => {
            action.element = rebuildElementSelector(action.element); // converting element args of the function calls (e.g. path in "move" function)

            if (Functions/* default.main */.Z.main[action.method]) {
              forEach_default()(Functions/* default.main */.Z.main[action.method].args, (argConfig, argName) => {
                if (argConfig.type === 'element' && action.args[argName]) {
                  action.args[argName] = rebuildElementSelector(action.args[argName]);
                }
              });
            }
          });
        });
      });
    });
    return copiedItems;
  }
  /**
   *
   * @param {*} items array of items that should be copied and pasted
   * @param {*} centerX x in relative transform for which items should put pasted to
   * @param {*} centerY y in relative transform for which items should put pasted to
   */


  pasteItems(items, centerX, centerY) {
    if (!items || items.length === 0) {
      return;
    }

    this.deselectAllItems();
    const copiedItems = this.cloneItems(items);
    const copiedIds = new Set();
    forEach_default()(copiedItems, item => {
      copiedIds.add(item.id);
      this.scheme.items.push(item);
    }); // doing the selection afterwards so that item has all meta transform calculated after re-indexing
    // and its edit box would be aligned with the item

    forEach_default()(copiedItems, item => {
      this.selectItem(item, true); // the following code address issue: https://github.com/ishubin/schemio/issues/571

      if (item.shape === 'connector') {
        const isAttachedToCopiedItem = itemSelector => {
          if (itemSelector[0] === '#') {
            const itemId = itemSelector.substring(1);
            return copiedIds.has(itemId);
          }

          return true;
        };

        if (item.shapeProps.sourceItem && !isAttachedToCopiedItem(item.shapeProps.sourceItem)) {
          item.shapeProps.sourceItem = null;
        }

        if (item.shapeProps.destinationItem && !isAttachedToCopiedItem(item.shapeProps.destinationItem)) {
          item.shapeProps.destinationItem = null;
        }
      }
    }); //since all items are already selected, the relative multi item edit box should be centered on the specified center point

    if (this.multiItemEditBox) {
      const boxArea = this.multiItemEditBox.area;
      const boxCenterX = boxArea.x + boxArea.w / 2;
      const boxCenterY = boxArea.y + boxArea.h / 2;
      const dx = centerX - boxCenterX;
      const dy = centerY - boxCenterY;
      boxArea.x += dx;
      boxArea.y += dy;
      this.updateMultiItemEditBoxItems(this.multiItemEditBox, true, DEFAULT_ITEM_MODIFICATION_CONTEXT);
      this.updateMultiItemEditBoxItems(this.multiItemEditBox, false, DEFAULT_ITEM_MODIFICATION_CONTEXT);
    }

    this.reindexItems();
  }

  copyItem(oldItem) {
    const newId = shortid_default().generate();
    const newItem = {
      id: newId,
      meta: {
        oldId: oldItem.id
      } // setting oldId as we need to be able to convert attached copied connectors

    };
    forEach_default()(oldItem, (value, field) => {
      if (field === 'childItems' || field === '_childItems') {
        newItem[field] = map_default()(value, childItem => this.copyItem(childItem));
      } else if (field !== 'id' && field !== 'meta') {
        newItem[field] = ui_utils/* default.clone */.Z.clone(value);
      }
    });
    return newItem;
  }
  /**
   * This function is used to update the area of all items inside edit box so that
   * they reflect transformations applied to edit box.
   * The way it works is by computing original projection points of items onto new area of edit box
   * @param {MultiItemEditBox} multiItemEditBox
   * @param {Boolean} isSoft
   * @param {ItemModificationContext} context
   */


  updateMultiItemEditBoxItems(multiItemEditBox, isSoft, context, precision) {
    if (precision === undefined) {
      precision = 4;
    }

    if (!context) {
      context = DEFAULT_ITEM_MODIFICATION_CONTEXT;
    } // storing ids of dragged or rotated items in a map
    // this way we will be able to figure out whether any items ancestors were dragged already
    // so that we can skip dragging or rotating an item


    const changedItemIds = new Set();
    forEach_default()(multiItemEditBox.items, item => {
      changedItemIds.add(item.id); // checking whether the item in the box list is actually a descendant of the other item that was also in the same box
      // this is needed to build proper reindexing of items and not to double rotate child items in case their parent was already rotated

      const parentWasAlreadyUpdated = item.meta && item.meta.ancestorIds && find_default()(item.meta.ancestorIds, id => changedItemIds.has(id));
      const shouldSkipItemUpdate = parentWasAlreadyUpdated && (context.moved || context.rotated) && !context.resized;

      if (!item.locked && !shouldSkipItemUpdate) {
        // calculating new position of item based on their pre-calculated projections
        const itemProjection = multiItemEditBox.itemProjections[item.id]; // this condition is needed becase there can be a situation when edit box is first rotated and only then resized
        // in this case we should skip rotation of child items if their parents were already rotated.

        if (!parentWasAlreadyUpdated) {
          item.area.r = itemProjection.r + multiItemEditBox.area.r;
        }

        const projectBack = point => {
          return myMath/* default.worldPointInArea */.Z.worldPointInArea(point.x * multiItemEditBox.area.w, point.y * multiItemEditBox.area.h, multiItemEditBox.area);
        };

        let parentTransform = myMath/* default.identityMatrix */.Z.identityMatrix();
        const parent = this.findItemById(item.meta.parentId);

        if (parent) {
          parentTransform = itemCompleteTransform(parent);
        }

        const worldTopLeft = projectBack(itemProjection.topLeft);
        const newPoint = myMath/* default.findTranslationMatchingWorldPoint */.Z.findTranslationMatchingWorldPoint(worldTopLeft.x, worldTopLeft.y, 0, 0, item.area, parentTransform);

        if (newPoint) {
          item.area.x = newPoint.x;
          item.area.y = newPoint.y;
        } // recalculated width and height only in case multi item edit box was resized
        // otherwise it doesn't make sense


        if (context.resized) {
          const worldBottomRight = projectBack(itemProjection.bottomRight);
          const localBottomRight = localPointOnItem(worldBottomRight.x, worldBottomRight.y, item);
          item.area.w = Math.max(0, localBottomRight.x);
          item.area.h = Math.max(0, localBottomRight.y);
        }

        if (item.shape === 'component' && item.shapeProps.kind === 'embedded') {
          this.readjustComponentContainerRect(item);
        }

        this.updateChildTransforms(item); // changing item revision so that its shape gets recomputed

        updateItemRevision(item);
        this.readjustItemAndDescendants(item.id, isSoft, context, precision);
        if (this.eventBus) this.eventBus.emitItemChanged(item.id, 'area');
        this.updatePropertyForClones(item, clone => {
          clone.area.x = item.area.x;
          clone.area.y = item.area.y;
          clone.area.w = item.area.w;
          clone.area.h = item.area.h;
          clone.area.r = item.area.r;
          clone.area.px = item.area.px;
          clone.area.py = item.area.py;
        });
      }
    });
    if (this.eventBus) this.eventBus.$emit(this.eventBus.MULTI_ITEM_EDIT_BOX_ITEMS_UPDATED);
  }
  /**
   * Searches for all item names and adds numeric index so that it becomes unique in the scheme
   * @param {string} name
   */


  generateUniqueName(name) {
    const itemNames = map_default()(this.getItems(), item => item.name);
    return collections.giveUniqueName(name, itemNames);
  }

  copyNameAndMakeUnique(name) {
    const nameParts = name.trim().split(' ');

    if (nameParts.length > 1) {
      if (!isNaN(nameParts[nameParts.length - 1])) {
        nameParts.splice(nameParts.length - 1, 1);
        return this.generateUniqueName(nameParts.join(' ').trim());
      }
    }

    return this.generateUniqueName(name);
  }

  updateMultiItemEditBox() {
    if (this.selectedItems.length > 0) {
      this.multiItemEditBox = this.generateMultiItemEditBox(this.selectedItems);
    } else {
      this.multiItemEditBox = null;
    }
  }
  /**
   * This is needed only in case we don't want to reset multi-item edit box
   * but we do need to update its area
   */


  updateMultiItemEditBoxAreaOnly() {
    if (this.multiItemEditBox && this.selectedItems.length > 0) {
      const box = this.generateMultiItemEditBox(this.selectedItems);
      this.multiItemEditBox.area.x = box.area.x;
      this.multiItemEditBox.area.y = box.area.y;
      this.multiItemEditBox.area.w = box.area.w;
      this.multiItemEditBox.area.h = box.area.h;
      this.multiItemEditBox.area.r = box.area.r;
      this.multiItemEditBox.area.sx = box.area.sx;
      this.multiItemEditBox.area.sy = box.area.sy;
    }
  }

  createMultiItemEditBoxAveragedArea(items) {
    let minP = null;
    let maxP = null; // iterating over all corners of items area to calculate the boundary box

    const pointGenerators = [item => {
      return {
        x: 0,
        y: 0
      };
    }, item => {
      return {
        x: item.area.w,
        y: 0
      };
    }, item => {
      return {
        x: item.area.w,
        y: item.area.h
      };
    }, item => {
      return {
        x: 0,
        y: item.area.h
      };
    }];
    forEach_default()(items, item => {
      forEach_default()(pointGenerators, pointGenerator => {
        const localPoint = pointGenerator(item);
        const p = this.worldPointOnItem(localPoint.x, localPoint.y, item);

        if (minP) {
          minP.x = Math.min(minP.x, p.x);
          minP.y = Math.min(minP.y, p.y);
        } else {
          minP = {
            x: p.x,
            y: p.y
          };
        }

        if (maxP) {
          maxP.x = Math.max(maxP.x, p.x);
          maxP.y = Math.max(maxP.y, p.y);
        } else {
          maxP = {
            x: p.x,
            y: p.y
          };
        }
      });
    });
    return {
      x: minP.x,
      y: minP.y,
      w: maxP.x - minP.x,
      h: maxP.y - minP.y,
      r: 0,
      px: 0,
      py: 0,
      sx: 1.0,
      sy: 1.0
    };
  }
  /**
   *
   * @param {Array} items
   * @returns {MultiItemEditBox}
   */


  generateMultiItemEditBox(items) {
    let area = null;
    let locked = true;
    const pivotPoint = {
      x: 0.5,
      y: 0.5
    };

    if (items.length === 1) {
      // we want the item edit box to be aligned with item only if that item was selected
      const p0 = this.worldPointOnItem(0, 0, items[0]),
            p1 = this.worldPointOnItem(items[0].area.w, 0, items[0]),
            p3 = this.worldPointOnItem(0, items[0].area.h, items[0]); // angle has to be calculated with taking width inot account
      // if the width is too small (e.g. vertical path line), then the computed angle will be incorrect

      let angle = 0;

      if (myMath/* default.tooSmall */.Z.tooSmall(items[0].area.w)) {
        angle = myMath/* default.fullAngleForVector */.Z.fullAngleForVector(p3.x - p0.x, p3.y - p0.y) * 180 / Math.PI - 90;
      } else {
        angle = myMath/* default.fullAngleForVector */.Z.fullAngleForVector(p1.x - p0.x, p1.y - p0.y) * 180 / Math.PI;
      }

      area = {
        x: p0.x,
        y: p0.y,
        r: angle,
        w: myMath/* default.distanceBetweenPoints */.Z.distanceBetweenPoints(p0.x, p0.y, p1.x, p1.y),
        h: myMath/* default.distanceBetweenPoints */.Z.distanceBetweenPoints(p0.x, p0.y, p3.x, p3.y),
        px: 0,
        py: 0,
        sx: 1.0,
        sy: 1.0
      };
      pivotPoint.x = items[0].area.px;
      pivotPoint.y = items[0].area.py;
    } else {
      // otherwise item edit box area will be an average of all other items
      area = this.createMultiItemEditBoxAveragedArea(items);
    }

    const itemProjections = {}; // used to store additional information that might be needed when modifying items

    const itemData = {}; //storing ids of all items that are included in the box

    const itemIds = new Set();
    forEach_default()(items, item => {
      itemData[item.id] = {
        originalArea: ui_utils/* default.clone */.Z.clone(item.area)
      };
      itemIds.add(item.id);

      if (!item.locked) {
        locked = false;
      } // caclulating projection of item world coords on the top and left edges of original edit box
      // since some items can be children of other items we need to project only their world location


      const worldTopLeftPoint = this.worldPointOnItem(0, 0, item);
      const worldBottomRightPoint = this.worldPointOnItem(item.area.w, item.area.h, item);

      const projectPoint = (x, y) => {
        const localPoint = myMath/* default.localPointInArea */.Z.localPointInArea(x, y, area);

        if (area.w > 0) {
          localPoint.x = localPoint.x / area.w;
        }

        if (area.h > 0) {
          localPoint.y = localPoint.y / area.h;
        }

        return localPoint;
      };

      itemProjections[item.id] = {
        topLeft: projectPoint(worldTopLeftPoint.x, worldTopLeftPoint.y),
        bottomRight: projectPoint(worldBottomRightPoint.x, worldBottomRightPoint.y),
        // the following angle correction is needed in case only one item is selected,
        // in that case the initial edit box area might have a starting angle that matches item area
        // in all other cases the initial angle will be 0
        r: item.area.r - area.r
      };

      if (item.shape === 'path') {
        // storing original points so that they can be readjusted in case the item is resized
        itemData[item.id].originalCurvePaths = ui_utils/* default.clone */.Z.clone(item.shapeProps.paths);
      }
    });
    return {
      id: shortid_default().generate(),
      locked,
      items,
      itemIds,
      itemData,
      area,
      itemProjections,
      pivotPoint,
      // the sole purpose of this point is for the user to be able to rotate edit box via number textfield in Position panel
      // because there we have to readjust edit box position to make sure its pivot point stays in the same place relatively to the world
      // I tried to rewrite the entire edit box calculation to make it simpler. I tried matching pivot point in edit box area to the ones of the item
      // It turned out a lot better in the beginning, but later I discovered that resizing of edit box becomes wonky and the same problem appears
      // when user  types x, y, width or height in number textfield in Position panel.
      // So thats why I decided to keep it as is and to perform all the trickery only for rotation control.
      worldPivotPoint: myMath/* default.worldPointInArea */.Z.worldPointInArea(pivotPoint.x * area.w, pivotPoint.y * area.h, area)
    };
  }

  generateItemSnappers(item) {
    const shape = Shape/* default.find */.Z.find(item.shape);

    if (!shape) {
      return null;
    }

    return shape.getSnappers(item);
  }
  /**
   * Searches for item that is able to fit item inside it and that has the min area out of all specified items
   * @param {Item} area  - item that it needs to fit into another parent item (should be in world transform)
   * @param {Function} itemConsiderCallback - callback function which should return true for specified item if it should be considered
   * @returns {Item}
   */


  findItemSuitableForParent(item, itemConsiderCallback) {
    const area = this.calculateItemWorldArea(item);
    const items = this.getItems(); // doing backwards search as getItems() returns a list of all items ordered by their layering position on screen

    for (let i = items.length - 1; i >= 0; i--) {
      const item = items[i]; // connectors should not be parent of any other items

      if (item.visible && item.shape !== 'connector' && (!itemConsiderCallback || itemConsiderCallback(item))) {
        const worldArea = this.worldItemAreas.get(item.id);

        if (worldArea && area.w + area.h < worldArea.w + worldArea.h) {
          const overlap = myMath/* default.overlappingArea */.Z.overlappingArea(worldArea, area);
          const A = area.w * area.h;

          if (overlap && !myMath/* default.tooSmall */.Z.tooSmall(A)) {
            if (overlap.w * overlap.h / A >= 0.5) {
              return item;
            }
          }
        }
      }
    }

    return null;
  }

  prepareFrameAnimations() {
    // This function is needed because animations for frame player can be triggered from two places:
    // a) by clicking play button
    // b) by calling "Play Frames" function in behavior actions
    this.prepareFrameAnimationsForItems();
  }

  prepareFrameAnimationsForItems() {
    this.frameAnimations = {};
    forEach_default()(this.framePlayers, item => {
      const compiledAnimations = compileAnimations(item, this);
      this.frameAnimations[item.id] = new FrameAnimation(item.shapeProps.fps, item.shapeProps.totalFrames, compiledAnimations);
    });
  }

  getFrameAnimation(itemId) {
    return this.frameAnimations[itemId];
  }

  getEventBus() {
    return this.eventBus;
  }

  alignItemsHorizontally(items) {
    if (items.length < 2) {
      return;
    }

    let centerSum = 0;
    const worldBoxes = [];
    forEach_default()(items, item => {
      const bbox = this.getBoundingBoxOfItems([item]);
      worldBoxes.push({
        bbox,
        item
      });
      centerSum += bbox.y + bbox.h / 2;
    });
    const center = centerSum / worldBoxes.length;
    worldBoxes.sort((a, b) => {
      return a.bbox.x - b.bbox.x;
    });
    let marginSum = 0;
    let properMarginCount = 0;

    for (let i = 0; i < worldBoxes.length - 1; i++) {
      const margin = worldBoxes[i + 1].bbox.x - (worldBoxes[i].bbox.x + worldBoxes[i].bbox.w);

      if (margin > 0) {
        marginSum += margin;
        properMarginCount++;
      }
    }

    const finalMargin = marginSum / Math.max(1, properMarginCount);
    let prevWorldOffset = worldBoxes[0].bbox.x;

    for (let i = 0; i < worldBoxes.length; i++) {
      const item = worldBoxes[i].item;
      let dx = 0;

      if (i > 0) {
        dx = prevWorldOffset + finalMargin - worldBoxes[i].bbox.x;
      }

      const dy = center - worldBoxes[i].bbox.y - worldBoxes[i].bbox.h / 2;
      let parentTransform = myMath/* default.identityMatrix */.Z.identityMatrix();

      if (item.meta.parentId) {
        const parent = this.findItemById(item.meta.parentId);

        if (parent) {
          parentTransform = itemCompleteTransform(parent);
        }
      }

      const correction = myMath/* default.transformVector */.Z.transformVector(parentTransform, dx, dy);
      prevWorldOffset = dx + worldBoxes[i].bbox.x + worldBoxes[i].bbox.w;
      item.area.x += correction.x;
      item.area.y += correction.y;
      this.eventBus.emitItemChanged(item.id, 'area');
    }

    this.eventBus.emitSchemeChangeCommited();
    this.updateMultiItemEditBox();
  }

  alignItemsVertically(items) {
    if (items.length < 2) {
      return;
    }

    let centerSum = 0;
    const worldBoxes = [];
    forEach_default()(items, item => {
      const bbox = this.getBoundingBoxOfItems([item]);
      worldBoxes.push({
        bbox,
        item
      });
      centerSum += bbox.x + bbox.w / 2;
    });
    const center = centerSum / worldBoxes.length;
    worldBoxes.sort((a, b) => {
      return a.bbox.y - b.bbox.y;
    });
    let marginSum = 0;
    let properMarginCount = 0;

    for (let i = 0; i < worldBoxes.length - 1; i++) {
      const margin = worldBoxes[i + 1].bbox.y - (worldBoxes[i].bbox.y + worldBoxes[i].bbox.h);

      if (margin > 0) {
        marginSum += margin;
        properMarginCount++;
      }
    }

    const finalMargin = marginSum / Math.max(1, properMarginCount);
    let prevWorldOffset = worldBoxes[0].bbox.y;

    for (let i = 0; i < worldBoxes.length; i++) {
      const item = worldBoxes[i].item;
      let dy = 0;

      if (i > 0) {
        dy = prevWorldOffset + finalMargin - worldBoxes[i].bbox.y;
      }

      const dx = center - worldBoxes[i].bbox.x - worldBoxes[i].bbox.w / 2;
      let parentTransform = myMath/* default.identityMatrix */.Z.identityMatrix();

      if (item.meta.parentId) {
        const parent = this.findItemById(item.meta.parentId);

        if (parent) {
          parentTransform = itemCompleteTransform(parent);
        }
      }

      const correction = myMath/* default.transformVector */.Z.transformVector(parentTransform, dx, dy);
      prevWorldOffset = dy + worldBoxes[i].bbox.y + worldBoxes[i].bbox.h;
      item.area.x += correction.x;
      item.area.y += correction.y;
      this.eventBus.emitItemChanged(item.id, 'area');
    }

    this.eventBus.emitSchemeChangeCommited();
    this.updateMultiItemEditBox();
  }

  alignItemsHorizontallyInParent(items) {
    this._alignItemsWith(items, (item, correction) => {
      item.area.x += correction.x;
    });
  }

  alignItemsVerticallyInParent(items) {
    this._alignItemsWith(items, (item, correction) => {
      item.area.y += correction.y;
    });
  }

  alignItemsCenteredInParent(items) {
    this._alignItemsWith(items, (item, correction) => {
      item.area.x += correction.x;
      item.area.y += correction.y;
    });
  }

  _alignItemsWith(items, correctionCallback) {
    const itemsByParent = this._breakItemsByParents(items);

    itemsByParent.forEach((items, parentId) => {
      const correction = this._findCenteringCorrection(items, parentId);

      forEach_default()(items, item => {
        correctionCallback(item, correction);
        this.eventBus.emitItemChanged(item.id, 'area');
      });
    });
    this.eventBus.emitSchemeChangeCommited();
    this.updateMultiItemEditBox();
  }

  _findCenteringCorrection(items, parentId) {
    if (items.length === 0) {
      return {
        x: 0,
        y: 0
      };
    }

    const parentItem = this.findItemById(parentId);

    if (!parentItem) {
      return;
    }

    let minX = items[0].area.x;
    let maxX = items[0].area.x;
    let minY = items[0].area.y;
    let maxY = items[0].area.y;
    forEach_default()(items, item => {
      minX = Math.min(minX, item.area.x);
      maxX = Math.max(maxX, item.area.x + item.area.w);
      minY = Math.min(minY, item.area.y);
      maxY = Math.max(maxY, item.area.y + item.area.h);
    });
    const leftMargin = minX;
    const rightMargin = parentItem.area.w - maxX;
    const topMargin = minY;
    const bottomMargin = parentItem.area.h - maxY;
    return {
      x: (rightMargin - leftMargin) / 2,
      y: (bottomMargin - topMargin) / 2
    };
  }
  /**
   * @param {Array} items
   * @returns {Map}
   */


  _breakItemsByParents(items) {
    const itemsByParent = new Map();
    forEach_default()(items, item => {
      const parentId = item.meta.parentId;

      if (parentId) {
        if (!itemsByParent.has(parentId)) {
          itemsByParent.set(parentId, []);
        }

        itemsByParent.get(parentId).push(item);
      }
    });
    return itemsByParent;
  }

}

/* harmony default export */ const scheme_SchemeContainer = (SchemeContainer);

/***/ }),

/***/ 2672:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ Compiler)
/* harmony export */ });
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4486);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _functions_Functions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3013);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



function enrichFuncArgs(args, funcDef) {
  lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(funcDef.args, (argDef, argName) => {
    if (!args.hasOwnProperty(argName)) {
      args[argName] = argDef.value;
    }
  });
  return args;
}

class Compiler {
  /**
   * 
   * @param {SchemeContainer} schemeContainer 
   * @param {SchemeItem} selfItem 
   * @param {Array} actions 
   */
  compileActions(schemeContainer, selfItem, actions) {
    const funcs = [];
    lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(actions, action => {
      if (_functions_Functions_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].main.hasOwnProperty */ .Z.main.hasOwnProperty(action.method)) {
        if (action.element) {
          const elements = schemeContainer.findElementsBySelector(action.element, selfItem);

          if (elements) {
            const knownFunc = _functions_Functions_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"].main */ .Z.main[action.method];

            if (knownFunc) {
              const args = enrichFuncArgs(action.args, knownFunc);

              if (knownFunc.multiItem) {
                // Means that this function is always expected to get array of items and in cases when it is applied
                // to a group of items - it will only be invoked once with array of those items as a first argument
                funcs.push({
                  func: knownFunc,
                  element: elements,
                  args
                });
              } else {
                lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(elements, element => {
                  funcs.push({
                    func: knownFunc,
                    element,
                    args
                  });
                });
              }
            }
          }
        }
      }
    });
    return (userEventBus, revision, subscribedItemId, eventName) => {
      const subscribedItem = schemeContainer.findItemById(subscribedItemId);

      if (funcs.length < 1) {
        return;
      }

      let index = 0;

      let resultCallback = () => {
        index += 1;

        if (index >= funcs.length) {
          return;
        }

        let f = funcs[index];

        if (userEventBus.isActionAllowed(revision)) {
          f.func.execute(f.element, f.args, schemeContainer, userEventBus, resultCallback, subscribedItem, eventName);
        } else {}
      };

      if (userEventBus.isActionAllowed(revision)) {
        funcs[0].func.execute(funcs[0].element, funcs[0].args, schemeContainer, userEventBus, resultCallback, subscribedItem, eventName);
      }
    };
  }

}

/***/ }),

/***/ 6085:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  standardEvents: {
    mousein: {
      id: 'mousein',
      name: 'Mouse In'
    },
    mouseout: {
      id: 'mouseout',
      name: 'Mouse Out'
    },
    clicked: {
      id: 'clicked',
      name: 'Clicked'
    },
    init: {
      id: 'init',
      name: 'Init'
    }
  }
});

/***/ }),

/***/ 3013:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ Functions)
});

// EXTERNAL MODULE: ./src/ui/utils.js
var utils = __webpack_require__(4691);
// EXTERNAL MODULE: ./src/ui/animations/AnimationRegistry.js
var AnimationRegistry = __webpack_require__(9737);
// EXTERNAL MODULE: ./src/ui/animations/ValueAnimation.js
var ValueAnimation = __webpack_require__(3805);
// EXTERNAL MODULE: ./src/ui/colors.js
var colors = __webpack_require__(6012);
// EXTERNAL MODULE: ./src/ui/components/editor/EventBus.js
var EventBus = __webpack_require__(536);
// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/Shape.js
var Shape = __webpack_require__(3363);
// EXTERNAL MODULE: ./src/ui/scheme/Item.js
var Item = __webpack_require__(7196);
;// CONCATENATED MODULE: ./src/ui/userevents/functions/SetFunction.js
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */








function playAnimation(item, args, resultCallback, updateCallback) {
  AnimationRegistry/* default.play */.Z.play(new ValueAnimation/* default */.ZP({
    durationMillis: args.animationDuration * 1000.0,
    animationType: args.transition,
    update: updateCallback,

    destroy() {
      resultCallback();
    }

  }), item.id, `set-func-${args.field}`);
}

function supportsAnimationForSetFunction(argType) {
  return argType === 'number' || argType === 'color' || argType === 'advanced-color';
}

function animateGradientColor(item, args, resultCallback, startGradient, endGradient) {
  if (startGradient.colors.length !== endGradient.colors.length) {
    return false;
  }

  utils/* default.setObjectProperty */.Z.setObjectProperty(item, args.field, {
    type: 'gradient',
    gradient: _objectSpread(_objectSpread({}, startGradient), {}, {
      type: endGradient.type
    })
  });
  const color = utils/* default.getObjectProperty */.Z.getObjectProperty(item, args.field);
  const originalDirection = startGradient.direction;
  const decodedColors = [];

  for (let i = 0; i < endGradient.colors.length; i++) {
    decodedColors[i] = {
      start: (0,colors/* parseColor */.l)(startGradient.colors[i].c),
      startPos: startGradient.colors[i].p,
      end: (0,colors/* parseColor */.l)(endGradient.colors[i].c),
      endPos: endGradient.colors[i].p
    };
  }

  playAnimation(item, args, resultCallback, t => {
    color.gradient.direction = originalDirection * (1 - t) + endGradient.direction * t;
    color.gradient.colors.forEach((c, i) => {
      c.c = (0,colors/* encodeColor */.N)({
        r: decodedColors[i].start.r * (1 - t) + decodedColors[i].end.r * t,
        g: decodedColors[i].start.g * (1 - t) + decodedColors[i].end.g * t,
        b: decodedColors[i].start.b * (1 - t) + decodedColors[i].end.b * t,
        a: decodedColors[i].start.a * (1 - t) + decodedColors[i].end.a * t
      });
      c.p = decodedColors[i].startPos * (1 - t) + decodedColors[i].endPos * t;
    });
    EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
  });
  return true;
}

function animateAdvancedColor(item, args, resultCallback, startValue) {
  if (typeof args.value !== 'object' || typeof startValue !== 'object') {
    return false;
  }

  if (args.value.type === 'solid' && startValue.type === 'solid') {
    const startColor = (0,colors/* parseColor */.l)(startValue.color);
    const endColor = (0,colors/* parseColor */.l)(args.value.color);
    playAnimation(item, args, resultCallback, t => {
      utils/* default.setObjectProperty */.Z.setObjectProperty(item, args.field, {
        type: 'solid',
        color: (0,colors/* encodeColor */.N)({
          r: startColor.r * (1 - t) + endColor.r * t,
          g: startColor.g * (1 - t) + endColor.g * t,
          b: startColor.b * (1 - t) + endColor.b * t,
          a: startColor.a * (1 - t) + endColor.a * t
        })
      });
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
    });
    return true;
  }

  if (args.value.type === 'gradient' && startValue.type === 'gradient') {
    return animateGradientColor(item, args, resultCallback, startValue.gradient, args.value.gradient);
  }

  return false;
}

function animateValue(property, item, args, resultCallback) {
  const startValue = utils/* default.getObjectProperty */.Z.getObjectProperty(item, args.field);

  if (property.type === 'number') {
    playAnimation(item, args, resultCallback, t => {
      utils/* default.setObjectProperty */.Z.setObjectProperty(item, args.field, startValue * (1 - t) + args.value * t);
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
    });
  } else if (property.type === 'color') {
    const startColor = (0,colors/* parseColor */.l)(startValue);
    const endColor = (0,colors/* parseColor */.l)(args.value);
    playAnimation(item, args, resultCallback, t => {
      utils/* default.setObjectProperty */.Z.setObjectProperty(item, args.field, (0,colors/* encodeColor */.N)({
        r: startColor.r * (1 - t) + endColor.r * t,
        g: startColor.g * (1 - t) + endColor.g * t,
        b: startColor.b * (1 - t) + endColor.b * t,
        a: startColor.a * (1 - t) + endColor.a * t
      }));
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
    });
  } else if (property.type === 'advanced-color') {
    if (!animateAdvancedColor(item, args, resultCallback, startValue)) {
      utils/* default.setObjectProperty */.Z.setObjectProperty(item, args.field, args.value);
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
    }
  }
}

/* harmony default export */ const SetFunction = ({
  name: 'Set',
  args: {
    field: {
      name: 'Field',
      type: 'text',
      value: ''
    },
    value: {
      name: 'Value',
      type: 'object',
      value: null
    },
    animated: {
      name: 'Animated',
      type: 'boolean',
      value: false
    },
    animationDuration: {
      name: 'Animation duration (sec)',
      type: 'number',
      value: 0.5,
      depends: {
        animated: true
      }
    },
    transition: {
      name: 'Transition',
      type: 'choice',
      value: 'ease-out',
      options: ['linear', 'smooth', 'ease-in', 'ease-out', 'ease-in-out', 'bounce'],
      depends: {
        animated: true
      }
    },
    inBackground: {
      name: 'In Background',
      type: 'boolean',
      value: false,
      depends: {
        animated: true
      },
      description: 'Play animation in background without blocking invokation of other actions'
    }
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (!item || !args.hasOwnProperty('field') || !args.hasOwnProperty('value')) {
      resultCallback();
      return;
    }

    const property = (0,Item/* getItemPropertyDescriptionForShape */.u2)(Shape/* default.find */.Z.find(item.shape), args.field);

    if (args.animated && property && supportsAnimationForSetFunction(property.type)) {
      if (args.inBackground) {
        resultCallback();
      }

      animateValue(property, item, args, () => {
        if (!args.inBackground) {
          resultCallback();
        }
      });
    } else {
      utils/* default.setObjectProperty */.Z.setObjectProperty(item, args.field, args.value);
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
      resultCallback();
    }
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/HideFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



/* harmony default export */ const HideFunction = ({
  name: 'Hide',
  description: 'Hides your item from scene. It also allows to animate this and to perform a slow transition',
  args: {
    animated: {
      name: 'Animated',
      type: 'boolean',
      value: true
    },
    animationDuration: {
      name: 'Animation duration (sec)',
      type: 'number',
      value: 0.5,
      depends: {
        animated: true
      }
    },
    transition: {
      name: 'Transition',
      type: 'choice',
      value: 'ease-out',
      options: ['linear', 'smooth', 'ease-in', 'ease-out', 'ease-in-out', 'bounce'],
      depends: {
        animated: true
      }
    },
    inBackground: {
      name: 'In Background',
      type: 'boolean',
      value: false,
      depends: {
        animated: true
      },
      description: 'Play animation in background without blocking invokation of other actions'
    }
  },

  argsToShortString(args) {
    if (args.animated) {
      return `animated, ${args.animationDuration} sec`;
    }

    return 'instant';
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (!item) {
      resultCallback();
      return;
    }

    const initialOpacity = item.opacity;

    if (args.animated) {
      AnimationRegistry/* default.play */.Z.play(new ValueAnimation/* default */.ZP({
        durationMillis: args.animationDuration * 1000.0,
        animationType: args.transition,

        update(t) {
          item.opacity = initialOpacity * (1.0 - t);
          EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
        },

        destroy() {
          item.visible = false;
          EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);

          if (!args.inBackground) {
            resultCallback();
          }
        }

      }), item.id, this.name);

      if (args.inBackground) {
        resultCallback();
      }
    } else {
      item.visible = false;
      resultCallback();
    }
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/ShowFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



/* harmony default export */ const ShowFunction = ({
  name: 'Show',
  description: 'Makes your item visible on scene. You can also make it with a slow transition.',
  args: {
    animated: {
      name: 'Animated',
      type: 'boolean',
      value: true
    },
    animationDuration: {
      name: 'Animation duration (sec)',
      type: 'number',
      value: 0.5,
      depends: {
        animated: true
      }
    },
    transition: {
      name: 'Transition',
      type: 'choice',
      value: 'ease-out',
      options: ['linear', 'smooth', 'ease-in', 'ease-out', 'ease-in-out', 'bounce'],
      depends: {
        animated: true
      }
    },
    inBackground: {
      name: 'In Background',
      type: 'boolean',
      value: false,
      depends: {
        animated: true
      },
      description: 'Play animation in background without blocking invokation of other actions'
    }
  },

  argsToShortString(args) {
    if (args.animated) {
      return `animated, ${args.animationDuration} sec`;
    }

    return 'instant';
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (!item) {
      return;
    }

    if (args.animated) {
      AnimationRegistry/* default.play */.Z.play(new ValueAnimation/* default */.ZP({
        durationMillis: args.animationDuration * 1000.0,
        animationType: args.transition,

        init() {
          item.opacity = 0.0;
          item.visible = true;
          EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
        },

        update(t) {
          item.opacity = 100.0 * t;
          EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
        },

        destroy() {
          item.visible = true;
          item.opacity = 100.0;
          EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);

          if (!args.inBackground) {
            resultCallback();
          }
        }

      }), item.id, this.name);

      if (args.inBackground) {
        resultCallback();
      }
    } else {
      item.visible = true;

      if (item.opacity < 0.5) {
        item.opacity = 100.0;
      }

      resultCallback();
    }
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/SendEventFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/* harmony default export */ const SendEventFunction = ({
  name: 'Send event',
  args: {
    event: {
      name: 'Event',
      type: 'string',
      value: 'Unknown event...'
    }
  },

  argsToShortString(args) {
    return args.event;
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    userEventBus.emitItemEvent(item.id, args.event);
    resultCallback();
  }

});
// EXTERNAL MODULE: ./src/ui/myMath.js
var myMath = __webpack_require__(3590);
// EXTERNAL MODULE: ./node_modules/lodash/forEach.js
var forEach = __webpack_require__(4486);
var forEach_default = /*#__PURE__*/__webpack_require__.n(forEach);
;// CONCATENATED MODULE: ./src/ui/userevents/functions/ZoomToItFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





/**
 * Recreating item transform because in some weird cases when some of ancestors were moved,
 * the transforms in item metas are not properly recalculated.
 */

function createItemTransform(item, schemeContainer) {
  let transform = myMath/* default.identityMatrix */.Z.identityMatrix();

  if (item.meta.ancestorIds) {
    for (let i = 0; i < item.meta.ancestorIds.length; i++) {
      const ancestorItem = schemeContainer.findItemById(item.meta.ancestorIds[i]);

      if (ancestorItem) {
        transform = myMath/* default.standardTransformWithArea */.Z.standardTransformWithArea(transform, ancestorItem.area);
      }
    }
  }

  return transform;
}

function calculateBoundingBox(item, schemeContainer) {
  const points = [{
    x: 0,
    y: 0
  }, {
    x: item.area.w,
    y: 0
  }, {
    x: item.area.w,
    y: item.area.h
  }, {
    x: 0,
    y: item.area.h
  }];
  let minPoint = null;
  let maxPoint = null;
  let transform = createItemTransform(item, schemeContainer);
  forEach_default()(points, point => {
    const localPoint = myMath/* default.worldPointInArea */.Z.worldPointInArea(point.x, point.y, item.area, transform);

    if (!minPoint) {
      minPoint = {
        x: localPoint.x,
        y: localPoint.y
      };
      maxPoint = {
        x: localPoint.x,
        y: localPoint.y
      };
    } else {
      minPoint.x = Math.min(minPoint.x, localPoint.x);
      minPoint.y = Math.min(minPoint.y, localPoint.y);
      maxPoint.x = Math.max(maxPoint.x, localPoint.x);
      maxPoint.y = Math.max(maxPoint.y, localPoint.y);
    }
  });
  return {
    x: minPoint.x,
    y: minPoint.y,
    w: maxPoint.x - minPoint.x,
    h: maxPoint.y - minPoint.y
  };
}
/**
 * This function searches (binary search) for position on screen where the element is visible close enough
 * @param {*} area - are in world which needs to be brought into screen
 * @param {*} width  - screen width
 * @param {*} height  - screen height
 * @param {*} screenOffset - offset in pixels from each side of the screen. This is needed in order to make it visualy more pleasant
 * @param {*} oldX  - old x of screen transform
 * @param {*} oldY  - old y of screen transform
 * @param {*} oldZoom  - old scale of screen transform
 * @param {*} destX - x on screen transform in which area is fully centered and inside the view
 * @param {*} destY - y on screen transform in which area is fully centered and inside the view
 * @param {*} destZoom - scale on screen transform in which area is fully centered and inside the view
 */


function findCloseEnoughTransform(area, width, height, screenOffset, oldX, oldY, oldZoom, destX, destY, destZoom) {
  const distance = Math.sqrt((destX - oldX) * (destX - oldX) + (destY - oldY) * (destY - oldY));

  if (distance < 1) {
    return {
      x: destX,
      y: destY,
      scale: destZoom
    };
  } //testing it in the middle point


  const midX = oldX + (destX - oldX) / 2;
  const midY = oldY + (destY - oldY) / 2;
  const midZoom = (destZoom + oldZoom) / 2;

  if (isAreaInsideScreen(area, width, height, screenOffset, midX, midY, midZoom)) {
    return findCloseEnoughTransform(area, width, height, screenOffset, oldX, oldY, oldZoom, midX, midY, midZoom);
  } else {
    return findCloseEnoughTransform(area, width, height, screenOffset, midX, midY, midZoom, destX, destY, destZoom);
  }
}

function isAreaInsideScreen(area, width, height, screenOffset, screenX, screenY, scale) {
  const x1 = area.x * scale + screenX;
  const y1 = area.y * scale + screenY;
  const x2 = (area.x + area.w) * scale + screenX;
  const y2 = (area.y + area.h) * scale + screenY;
  return x1 >= screenOffset && x1 <= width - screenOffset && x2 >= screenOffset && x2 <= width - screenOffset && y1 >= screenOffset && y1 <= height - screenOffset && y2 >= screenOffset && y2 <= height - screenOffset;
}

function isInsideHUD(item, schemeContainer) {
  if (item.shape === 'hud') {
    return true;
  }

  if (item.meta.parentId) {
    const parentItem = schemeContainer.findItemById(item.meta.parentId);

    if (parentItem) {
      return isInsideHUD(parentItem, schemeContainer);
    }
  }

  return false;
}

/* harmony default export */ const ZoomToItFunction = ({
  name: 'Zoom To It',
  description: 'Moves scene to bring item into view so that it is centered on the screen',
  args: {
    closeEnough: {
      name: 'Close Enough',
      type: 'boolean',
      value: false,
      description: 'If checked, then it will only zoom to item just enough for it to appear fully inside the screen. Otherwise it will bring it to the center of the screen'
    },
    animated: {
      name: 'Animated',
      type: 'boolean',
      value: true
    },
    animationDuration: {
      name: 'Animation duration (sec)',
      type: 'number',
      value: 0.5,
      min: 0,
      depends: {
        animated: true
      }
    },
    minZoom: {
      name: 'Minimum Zoom(%)',
      type: 'number',
      value: 0,
      min: 0
    },
    maxZoom: {
      name: 'Maximum Zoom(%)',
      type: 'number',
      value: 100,
      min: 0
    },
    inBackground: {
      name: 'In Background',
      type: 'boolean',
      value: false,
      depends: {
        animated: true
      },
      description: 'Play animation in background without blocking invokation of other actions'
    }
  },

  argsToShortString(args) {
    if (args.animated) {
      return `animated, ${args.animationDuration} sec`;
    }

    return 'instant';
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    // it doesn't make sense to zoom into HUD items since they are supposed to be rendered in viewport transform
    if (!item || !item.area || isInsideHUD(item, schemeContainer)) {
      resultCallback();
      return;
    }

    const area = calculateBoundingBox(item, schemeContainer);
    let newZoom = 1.0;
    const width = schemeContainer.screenSettings.width;
    const height = schemeContainer.screenSettings.height;

    if (area.w > 0 && area.h > 0 && width > 0 && height > 0) {
      newZoom = Math.min(width / area.w, height / area.h);
      newZoom = Math.max(args.minZoom / 100.0, Math.min(newZoom, args.maxZoom / 100.0));
    }

    let destX = width / 2 - (area.x + area.w / 2) * newZoom;
    let destY = height / 2 - (area.y + area.h / 2) * newZoom;

    if (args.closeEnough) {
      if (isAreaInsideScreen(area, width, height, 0, schemeContainer.screenTransform.x, schemeContainer.screenTransform.y, schemeContainer.screenTransform.scale)) {
        resultCallback();
        return;
      } else {
        const transform = findCloseEnoughTransform(area, width, height, 0, schemeContainer.screenTransform.x, schemeContainer.screenTransform.y, schemeContainer.screenTransform.scale, destX, destY, newZoom);
        destX = transform.x;
        destY = transform.y;
        newZoom = transform.scale;
      }
    }

    if (args.animated) {
      const oldX = schemeContainer.screenTransform.x;
      const oldY = schemeContainer.screenTransform.y;
      const oldZoom = schemeContainer.screenTransform.scale;
      AnimationRegistry/* default.play */.Z.play(new ValueAnimation/* default */.ZP({
        durationMillis: args.animationDuration * 1000.0,
        animationType: 'ease-in-out',
        update: t => {
          schemeContainer.screenTransform.scale = oldZoom * (1.0 - t) + newZoom * t;
          schemeContainer.screenTransform.x = oldX * (1.0 - t) + destX * t;
          schemeContainer.screenTransform.y = oldY * (1.0 - t) + destY * t;
        },
        destroy: () => {
          EventBus/* default.$emit */.Z.$emit(EventBus/* default.SCREEN_TRANSFORM_UPDATED */.Z.SCREEN_TRANSFORM_UPDATED, schemeContainer.screenTransform);

          if (!args.inBackground) {
            resultCallback();
          }
        }
      }), 'screen', 'screen-transform');

      if (args.inBackground) {
        resultCallback();
      }
    } else {
      schemeContainer.screenTransform.scale = newZoom;
      schemeContainer.screenTransform.x = destX;
      schemeContainer.screenTransform.y = destY;
      EventBus/* default.$emit */.Z.$emit(EventBus/* default.SCREEN_TRANSFORM_UPDATED */.Z.SCREEN_TRANSFORM_UPDATED, schemeContainer.screenTransform);
      resultCallback();
    }
  }

});
// EXTERNAL MODULE: ./src/ui/animations/Animation.js
var Animation = __webpack_require__(2217);
;// CONCATENATED MODULE: ./src/ui/userevents/functions/CrawlEffectFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




class CrawlEffectAnimation extends Animation/* default */.Z {
  constructor(item, args, resultCallback) {
    super();
    this.item = item;
    this.args = args;
    this.resultCallback = resultCallback;
    this.domContainer = null;
    this.domPath = null;
    this.time = 0.0;
    this.backupOpacity = 1.0;
    this.domAnimationPath = null;
  }

  init() {
    this.domContainer = document.getElementById(`animation-container-${this.item.id}`);
    const shape = Shape/* default.find */.Z.find(this.item.shape);

    if (shape) {
      const path = shape.computeOutline(this.item);

      if (path) {
        this.domPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
        this.domPath.setAttribute('d', path);
      }
    }

    if (!this.domContainer || !this.domPath) {
      return false;
    }

    this.domAnimationPath = this.svg('path', {
      'd': this.domPath.getAttribute('d'),
      'stroke-dasharray': this.args.length,
      'stroke-dashoffset': 0,
      'stroke-width': this.args.strokeWidth || 1,
      'stroke': this.args.color,
      'fill': 'none',
      'stroke-linejoin': 'round'
    });
    this.domContainer.appendChild(this.domAnimationPath);
    let opacity = window.getComputedStyle(this.domPath).opacity;

    if (opacity && opacity > 0.0) {
      this.backupOpacity = opacity;
    }

    this.domPath.style.opacity = 0.0;
    return true;
  }

  play(dt) {
    this.time += dt;
    this.domAnimationPath.setAttribute('stroke-dashoffset', Math.floor(-this.time * this.args.speed / 1000.0));

    if (this.time > this.args.duration * 1000.0) {
      return false;
    }

    return true;
  }

  destroy() {
    if (!this.args.inBackground) {
      this.resultCallback();
    }

    if (this.domAnimationPath) {
      this.domContainer.removeChild(this.domAnimationPath);
    }

    if (this.domPath) {
      this.domPath.style.opacity = this.backupOpacity;
    }
  }

}

/* harmony default export */ const CrawlEffectFunction = ({
  name: 'Crawl Effect',
  description: 'Animates outline of the item with a dashed stroke',
  args: {
    length: {
      name: 'Length',
      type: 'number',
      value: 10
    },
    color: {
      name: 'Color',
      type: 'color',
      value: 'rgba(255,0,0,1.0)'
    },
    speed: {
      name: 'Speed',
      type: 'number',
      value: 60
    },
    duration: {
      name: 'Duration (sec)',
      type: 'number',
      value: 2.0
    },
    strokeWidth: {
      name: 'Stroke Width',
      type: 'number',
      value: 3
    },
    inBackground: {
      name: 'In Background',
      type: 'boolean',
      value: false,
      description: 'Play animation in background without blocking invokation of other actions'
    }
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (item) {
      AnimationRegistry/* default.play */.Z.play(new CrawlEffectAnimation(item, args, resultCallback), item.id, this.name);
    }

    if (args.inBackground) {
      resultCallback();
    }
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/StopAllAnimationsFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

/* harmony default export */ const StopAllAnimationsFunction = ({
  name: 'Stop All Animations',
  description: 'Stops all animations that were either created in the background or generated by another event',
  args: {},

  execute(entity, args, schemeContainer, userEventBus, resultCallback) {
    //TODO figure out a way to stop all invocations for specified item
    if (entity && entity.id) {
      AnimationRegistry/* default.stopAllAnimationsForEntity */.Z.stopAllAnimationsForEntity(entity.id);
    }

    resultCallback();
  }

});
// EXTERNAL MODULE: ./src/ui/scheme/SchemeContainer.js + 6 modules
var SchemeContainer = __webpack_require__(8566);
;// CONCATENATED MODULE: ./src/ui/userevents/functions/ItemParticleEffectFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */







const PI_2 = Math.PI * 2.0;

function calculateCenterOfPath(svgPath) {
  const totalPathLength = svgPath.getTotalLength();
  let x = 0,
      y = 0;

  for (let i = 0; i < 10; i++) {
    const p = svgPath.getPointAtLength(totalPathLength * i / 10);
    x += p.x;
    y += p.y;
  }

  return {
    x: x / 10,
    y: y / 10
  };
}

class Particle {
  constructor() {
    this.lifeTime = 0;
    this.position = {
      x: 0,
      y: 0
    };
    this.angle = 0;
    this.scale = 1;
    this.opacity = 0;
    this.direction = {
      x: 0,
      y: 0
    };
    this.floatAngle = 0;
    this.floatAngleDirection = 0;
  }

  update() {}

  destroy() {}

}

class DomParticle extends Particle {
  constructor(domContainer, domParticle) {
    super();
    this.domParticle = domParticle;
    this.domContainer = domContainer;
    domContainer.appendChild(domParticle);
  }

  update() {
    this.domParticle.setAttribute('style', `opacity: ${this.opacity}`);
    this.domParticle.setAttribute('transform', `translate(${this.position.x} ${this.position.y}) rotate(${this.angle}) scale(${this.scale} ${this.scale})`);
  }

  destroy() {
    this.domContainer.removeChild(this.domParticle);
  }

} // since item destroying is a very expensive operation, it's better to destroy all items in bulk at the end of the animation


class ItemRecycler {
  constructor(schemeContainer) {
    this.items = [];
    this.schemeContainer = schemeContainer;
    this.recycledItems = [];
  }

  recycleItem(item) {
    this.recycledItems.push(item);
  }

  destroy() {
    //TODO fix this. it forces to reindex all items and components which completely resets user behaviors and they stop working in component items
    this.schemeContainer.deleteNonIndexableItems(this.items);
  }

  borrowItem(elementSelector) {
    if (this.recycledItems.length > 0) {
      return this.recycledItems.pop();
    }

    const particleReferenceItem = this.schemeContainer.findFirstElementBySelector(elementSelector);

    if (particleReferenceItem) {
      const [clonedItem] = this.schemeContainer.cloneItems([particleReferenceItem]);
      this.schemeContainer.addNonIndexableItem(clonedItem);
      this.items.push(clonedItem);
      return clonedItem;
    }

    return null;
  }

}

class ItemParticle extends Particle {
  constructor(schemeContainer, elementSelector, item, itemRecycler) {
    super();
    this.item = item;
    this.particleItem = null;
    this.schemeContainer = schemeContainer;
    this.itemRecycler = itemRecycler;
    this.particleItem = this.itemRecycler.borrowItem(elementSelector);
  }

  update() {
    if (!this.particleItem) {
      return;
    }

    const worldPoint = (0,SchemeContainer/* worldPointOnItem */.rs)(this.position.x, this.position.y, this.item);
    this.particleItem.visible = true;
    this.particleItem.area.x = worldPoint.x - this.particleItem.area.px * this.particleItem.area.w;
    this.particleItem.area.y = worldPoint.y - this.particleItem.area.py * this.particleItem.area.h;
    this.particleItem.area.sx = this.scale;
    this.particleItem.area.sy = this.scale;
    this.particleItem.area.r = this.angle;
    this.particleItem.opacity = this.opacity * 100;
    EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.particleItem.id);
  }

  destroy() {
    if (this.particleItem) {
      this.itemRecycler.recycleItem(this.particleItem);
    }
  }

}

class ItemParticleEffectAnimation extends Animation/* default */.Z {
  constructor(item, args, schemeContainer, resultCallback) {
    super();
    this.item = item;
    this.args = args;
    this.resultCallback = resultCallback;
    this.domContainer = null;
    this.domItemPath = null;
    this.particles = [];
    this.schemeContainer = schemeContainer;
    this.itemRecycler = new ItemRecycler(schemeContainer);
    this.generatorCounter = 0.0;
    this.particlesLeft = this.args.particlesCount;
    this.cleanupDomElements = [];
    this.totalPathLength = 0.0;
    this.singleParticleBirthTime = this.args.birthTime / Math.max(1, this.args.particlesCount);
  }

  init() {
    this.domContainer = document.getElementById(`animation-container-${this.item.id}`);
    const shape = Shape/* default.find */.Z.find(this.item.shape);

    if (!shape) {
      return false;
    }

    this.domItemPath = this.schemeContainer.getSvgOutlineOfItem(this.item);

    if (!this.domContainer || !this.domItemPath) {
      return false;
    }

    this.totalPathLength = this.domItemPath.getTotalLength();
    this.center = calculateCenterOfPath(this.domItemPath);
    const graidentDefs = this.svg('defs', {});
    graidentDefs.innerHTML = `
            <radialGradient id="animation-particle-effect-gradient-${this.id}" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
            <stop offset="0%" style="stop-color:${this.args.color};stop-opacity:1" />
            <stop offset="25%" style="stop-color:${this.args.color};stop-opacity:1" />
            <stop offset="100%" style="stop-color:${this.args.color};stop-opacity:0" />
            </radialGradient>
        `;
    this.domContainer.appendChild(graidentDefs);
    this.cleanupDomElements.push(graidentDefs);
    return true;
  }

  play(dt) {
    if (this.particles.length === 0 && this.particlesLeft <= 0) {
      return false;
    }

    if (this.particlesLeft > 0) {
      if (this.singleParticleBirthTime > 0.0001) {
        this.generatorCounter += dt / (this.singleParticleBirthTime * 1000.0);

        if (this.generatorCounter >= 1.0) {
          const roundedCounter = Math.floor(this.generatorCounter);
          const toGenerate = Math.min(this.particlesLeft, roundedCounter);

          for (let i = 0; i < toGenerate; i++) {
            this.createParticle();
          }

          this.generatorCounter -= roundedCounter;
        }
      } else {
        while (this.particlesLeft > 0) {
          this.createParticle();
        }
      }
    }

    for (let i = 0; i < this.particles.length; i++) {
      if (this.particles[i].lifeTime > this.args.lifeTime) {
        this.particles[i].destroy();
        this.particles.splice(i, 1);
        i = i - 1;
      } else {
        this.playParticle(this.particles[i], dt);
      }
    }

    return true;
  }

  createParticle() {
    let pathPosition = 0;

    if (!this.args.travelAlongPath) {
      pathPosition = Math.random() * this.totalPathLength;
    }

    const position = this.domItemPath.getPointAtLength(pathPosition);
    let particle = null;

    if (this.args.particleType === 'item') {
      particle = new ItemParticle(this.schemeContainer, this.args.item, this.item, this.itemRecycler);
    } else {
      particle = new DomParticle(this.domContainer, this.createParticleDom(this.args.particleType, this.args.particleSize, this.args.color));
    }

    particle.position = position;

    if (this.args.travelAlongPath) {
      if (this.args.travelFloatRadius > 0) {
        particle.floatAngle = Math.random() * PI_2;
      }

      let floatAngleDirection = 1;

      if (Math.random() >= 0.5) {
        floatAngleDirection = -1;
      }

      particle.floatAngleDirection = floatAngleDirection;
    } else {
      const direction = {
        x: 0,
        y: 0
      };
      direction.x = position.x - this.center.x;
      direction.y = position.y - this.center.y;
      const d = Math.sqrt(direction.x * direction.x + direction.y * direction.y);

      if (d > 0.0001) {
        direction.x = direction.x / d;
        direction.y = direction.y / d;
      }

      particle.direction = direction;
    }

    this.particles.push(particle);
    particle.update();
    this.particlesLeft -= 1;
  }

  playParticle(particle, dt) {
    particle.lifeTime += dt / 1000.0;

    if (this.args.travelAlongPath) {
      let maxLifeTime = this.args.lifeTime;

      if (maxLifeTime < 0.1) {
        maxLifeTime = 1.0;
      }

      let pathLength = 0;

      if (this.args.backwards) {
        pathLength = this.totalPathLength * Math.max(0, 1.0 - particle.lifeTime / maxLifeTime);
      } else {
        pathLength = this.totalPathLength * particle.lifeTime / maxLifeTime;
      }

      const point = this.domItemPath.getPointAtLength(pathLength);
      let x = point.x;
      let y = point.y;

      if (this.args.travelFloatRadius > 0) {
        particle.floatAngle += particle.floatAngleDirection * this.args.travelFloatSpeed * dt / (1000 * this.args.lifeTime);

        if (particle.floatAngle > PI_2) {
          particle.floatAngle -= PI_2;
        }

        x = point.x + this.args.travelFloatRadius * Math.cos(particle.floatAngle);
        y = point.y + this.args.travelFloatRadius * Math.sin(particle.floatAngle);
      }

      particle.position.x = x;
      particle.position.y = y;

      if (this.args.adjustRotation) {
        const nextPoint = this.domItemPath.getPointAtLength(pathLength + 2);
        const Vx = nextPoint.x - point.x;
        const Vy = nextPoint.y - point.y;
        const dSquared = Vx * Vx + Vy * Vy;

        if (!myMath/* default.tooSmall */.Z.tooSmall(dSquared)) {
          const d = Math.sqrt(dSquared);
          const vx = Vx / d;
          const vy = Vy / d;
          const angle = myMath/* default.fullAngleForNormalizedVector */.Z.fullAngleForNormalizedVector(vx, vy) * 180 / Math.PI;
          particle.angle = angle;

          if (isFinite(this.args.rotationOffset)) {
            particle.angle += this.args.rotationOffset;
          }

          ;
        }
      }
    } else {
      particle.position.x += particle.direction.x * this.args.speed * dt / 1000.0;
      particle.position.y += particle.direction.y * this.args.speed * dt / 1000.0;
    }

    let scale = 1.0;
    let opacity = 1;

    if (this.args.lifeTime > 0.0) {
      const lifeTimePercent = 100.0 * particle.lifeTime / this.args.lifeTime;

      if (lifeTimePercent < this.args.fadeIn) {
        opacity = lifeTimePercent / this.args.fadeIn;
      } else if (lifeTimePercent > this.args.fadeOut && this.args.fadeOut < 99.999) {
        opacity = (100 - lifeTimePercent) / (100 - this.args.fadeOut);
      }

      if (lifeTimePercent < this.args.growth) {
        scale = lifeTimePercent / this.args.growth;
      } else if (lifeTimePercent > this.args.decline && this.args.decline < 99.999) {
        scale = (100 - lifeTimePercent) / (100 - this.args.decline);
      }
    }

    particle.scale = scale;
    particle.opacity = opacity;
    particle.update();
  }

  destroy() {
    if (!this.args.inBackground) {
      this.resultCallback();
    }

    forEach_default()(this.particles, particle => {
      particle.destroy();
    });
    this.itemRecycler.destroy();
    forEach_default()(this.cleanupDomElements, domElement => {
      this.domContainer.removeChild(domElement);
    });
    this.cleanupDomElements = [];
  }

  createParticleDom(type, size, color) {
    if (type === 'circle') {
      return this.svg('circle', {
        cx: 0,
        cy: 0,
        r: size / 2,
        fill: color
      });
    } else if (type === 'rect') {
      return this.svg('rect', {
        x: -size / 2,
        y: -size / 2,
        width: size,
        height: size,
        fill: color,
        stroke: 'none'
      });
    } else {
      return this.svg('circle', {
        cx: 0,
        cy: 0,
        r: size / 2,
        fill: `url(#animation-particle-effect-gradient-${this.id})`
      });
    }
  }

}

/* harmony default export */ const ItemParticleEffectFunction = ({
  name: 'Particle Effect',
  description: 'Generates particles on the outline of the item',
  args: {
    particleType: {
      name: 'Particle Type',
      type: 'choice',
      value: 'spot',
      options: ['spot', 'circle', 'rect', 'item']
    },
    item: {
      name: 'Item',
      type: 'element',
      value: null,
      depends: {
        particleType: 'item'
      }
    },
    particlesCount: {
      name: 'Particles',
      type: 'number',
      value: 20
    },
    particleSize: {
      name: 'Particle size',
      type: 'number',
      value: 20
    },
    color: {
      name: 'Color',
      type: 'color',
      value: 'rgba(255,0,0,1.0)'
    },
    speed: {
      name: 'Speed',
      type: 'number',
      value: 60,
      depends: {
        travelAlongPath: false
      }
    },
    lifeTime: {
      name: 'Life time (sec)',
      type: 'number',
      value: 2.0
    },
    birthTime: {
      name: 'Birth time (sec)',
      type: 'number',
      value: 0.5,
      description: 'Time in which it should generate all particles'
    },
    growth: {
      name: 'Growth to (%)',
      type: 'number',
      value: 10
    },
    decline: {
      name: 'Decline from (%)',
      type: 'number',
      value: 90
    },
    fadeIn: {
      name: 'Fade in (%)',
      type: 'number',
      value: 5
    },
    fadeOut: {
      name: 'Fade out (%)',
      type: 'number',
      value: 95
    },
    travelAlongPath: {
      name: 'Travel along path',
      type: 'boolean',
      value: true,
      description: 'The particle emits in the beggining of the path and travels along the path'
    },
    backwards: {
      name: 'Travel backwards',
      type: 'boolean',
      value: false,
      depends: {
        travelAlongPath: true
      }
    },
    adjustRotation: {
      name: 'Adjust rotation',
      type: 'boolean',
      value: true,
      description: 'Adjust rotation of particles to path',
      depends: {
        travelAlongPath: true
      }
    },
    rotationOffset: {
      name: 'Rotation offset',
      type: 'number',
      value: 0,
      description: 'Rotation angle offset',
      depends: {
        adjustRotation: true,
        travelAlongPath: true
      }
    },
    travelFloatRadius: {
      name: 'Travel float radius',
      type: 'number',
      value: 5,
      depends: {
        travelAlongPath: true
      }
    },
    travelFloatSpeed: {
      name: 'Travel float speed',
      type: 'number',
      value: 10,
      depends: {
        travelAlongPath: true
      }
    },
    inBackground: {
      name: 'In background',
      type: 'boolean',
      value: false,
      description: 'Play animation in background without blocking invokation of other actions'
    }
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (item) {
      AnimationRegistry/* default.play */.Z.play(new ItemParticleEffectAnimation(item, args, schemeContainer, resultCallback), item.id, this.name);
    }

    if (args.inBackground) {
      resultCallback();
    }
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/BlinkEffectFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





class BlinkEffectAnimation extends Animation/* default */.Z {
  constructor(item, args, resultCallback) {
    super();
    this.item = item;
    this.args = args;
    this.resultCallback = resultCallback;
    this.elapsedTime = 0.0;
    this.domContainer = null;
    this.domBlinker = null;
    this.opacity = 0;
    this.itemOriginalOpacity = 100;
    this.phase = 0; // 0 - fade in, 1 - pulsate, 2 - fade out

    this.pulsatingTime = 0;
    this.phaseOffset = 0;
  }

  init() {
    this.domContainer = document.getElementById(`animation-container-${this.item.id}`);
    const shape = Shape/* default.find */.Z.find(this.item.shape);

    if (!shape) {
      return false;
    }

    if (this.args.fade) {
      const delta = this.args.maxOpacity - this.args.minOpacity;
      this.phase = 1;

      if (delta > 0.001) {
        this.phaseOffset = Math.asin(2 * (this.item.opacity - this.args.minOpacity) / delta - 2);
      }
    } else {
      this.domBlinker = this.svg('path', {
        'd': shape.computeOutline(this.item),
        'stroke-width': 3,
        'stroke': this.args.color,
        'fill': this.args.color,
        'style': `opacity: ${this.args.minOpacity}`
      });
      this.domContainer.appendChild(this.domBlinker);
    }

    return true;
  }

  play(dt) {
    this.elapsedTime += dt;
    this.t += this.args.speed * dt / 10000;

    if (this.args.fade) {
      return this.playFade(dt);
    } else {
      return this.playBlinker(dt);
    }
  }

  playFade(dt) {
    const speedRatio = 100;

    if (this.phase === 1) {
      this.pulsatingTime += dt;
      const t = Math.sin(this.pulsatingTime * this.args.speed / (speedRatio * 100.0) + this.phaseOffset) / 2 + 0.5;
      this.item.opacity = this.args.minOpacity * (1 - t) + this.args.maxOpacity * t;

      if (this.args.duration * 1000 - this.elapsedTime < Math.min(500, this.args.duration * 1000 / 20)) {
        this.phase = 2;
      }
    }

    if (this.phase === 2) {
      this.item.opacity += this.args.speed * dt / speedRatio;

      if (this.item.opacity >= this.itemOriginalOpacity) {
        this.item.opacity = this.itemOriginalOpacity;
        return false;
      }
    }

    EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.item.id);
    return this.elapsedTime < this.args.duration * 1000.0;
  }

  playBlinker(dt) {
    if (this.phase === 0) {
      if (this.opacity < this.args.minOpacity / 100) {
        this.opacity += this.args.speed * dt / 10000;
      } else {
        this.opacity = this.args.minOpacity / 100;
        this.phase = 1;
      }
    } else if (this.phase === 1) {
      this.pulsatingTime += dt;
      this.opacity = ((Math.sin(this.pulsatingTime * this.args.speed / 10000.0) / 2 + 0.5) * (this.args.maxOpacity - this.args.minOpacity) + this.args.minOpacity) / 100.0;

      if (this.args.duration * 1000 - this.elapsedTime < Math.min(500, this.args.duration * 1000 / 20)) {
        this.phase = 2;
      }
    } else {
      this.opacity -= this.args.speed * dt / 10000;

      if (this.opacity < 0) {
        return false;
      }
    }

    this.domBlinker.setAttribute('style', `opacity: ${this.opacity}`);
    return this.elapsedTime < this.args.duration * 1000.0;
  }

  destroy() {
    this.item.opacity = this.itemOriginalOpacity;

    if (!this.args.inBackground) {
      this.resultCallback();
    }

    if (this.domBlinker) {
      this.domContainer.removeChild(this.domBlinker);
    }
  }

}

/* harmony default export */ const BlinkEffectFunction = ({
  name: 'Blink Effect',
  description: 'Generates a pulsating effect in which item fades in and out or glows with specified color',
  args: {
    fade: {
      name: 'Fade in/out',
      type: 'boolean',
      value: true
    },
    color: {
      name: 'Color',
      type: 'color',
      value: 'rgba(255,0,0,1.0)',
      depends: {
        fade: false
      }
    },
    speed: {
      name: 'Speed',
      type: 'number',
      value: 50
    },
    duration: {
      name: 'Duration (sec)',
      type: 'number',
      value: 5.0
    },
    minOpacity: {
      name: 'Min Opacity (%)',
      type: 'number',
      value: 5
    },
    maxOpacity: {
      name: 'Max Opacity (%)',
      type: 'number',
      value: 80
    },
    inBackground: {
      name: 'In Background',
      type: 'boolean',
      value: false,
      description: 'Play animation in background without blocking invokation of other acctions'
    }
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (item) {
      AnimationRegistry/* default.play */.Z.play(new BlinkEffectAnimation(item, args, resultCallback), item.id, this.name);

      if (args.inBackground) {
        resultCallback();
      }
    }
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/MoveFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





class MoveAnimation extends Animation/* default */.Z {
  constructor(item, args, schemeContainer, resultCallback) {
    super();
    this.item = item;
    this.args = args;
    this.schemeContainer = schemeContainer;
    this.resultCallback = resultCallback;
    this.elapsedTime = 0.0;
    this.originalPosition = {
      x: this.item.area.x,
      y: this.item.area.y
    };
    this.destinationPosition = {
      x: parseFloat(args.x),
      y: parseFloat(args.y)
    };
  }

  init() {
    return true;
  }

  play(dt) {
    if (this.args.animate && this.args.duration > 0.00001) {
      this.elapsedTime += dt;
      const t = Math.min(1.0, this.elapsedTime / (this.args.duration * 1000));

      if (t >= 1.0) {
        this.item.area.x = this.destinationPosition.x;
        this.item.area.y = this.destinationPosition.y;
        this.schemeContainer.reindexItemTransforms(this.item);
        return false;
      }

      const convertedT = (0,ValueAnimation/* convertTime */.rJ)(t, this.args.movement);
      this.item.area.x = this.originalPosition.x * (1.0 - convertedT) + this.destinationPosition.x * convertedT;
      this.item.area.y = this.originalPosition.y * (1.0 - convertedT) + this.destinationPosition.y * convertedT;
      this.schemeContainer.reindexItemTransforms(this.item);
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.item.id);
      return true;
    } else {
      this.item.area.x = this.destinationPosition.x;
      this.item.area.y = this.destinationPosition.y;
      this.schemeContainer.reindexItemTransforms(this.item);
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.item.id);
    }

    return false;
  }

  destroy() {
    if (!this.args.inBackground) {
      this.resultCallback();
    }
  }

}

/* harmony default export */ const MoveFunction = ({
  name: 'Move',
  description: 'Moves item to specified location in local coords',
  args: {
    x: {
      name: 'X',
      type: 'number',
      value: 50
    },
    y: {
      name: 'Y',
      type: 'number',
      value: 50
    },
    animate: {
      name: 'Animate',
      type: 'boolean',
      value: false
    },
    duration: {
      name: 'Duration (sec)',
      type: 'number',
      value: 2.0,
      depends: {
        animate: true
      }
    },
    movement: {
      name: 'Movement',
      type: 'choice',
      value: 'linear',
      options: ['linear', 'smooth', 'ease-in', 'ease-out', 'ease-in-out', 'bounce'],
      depends: {
        animate: true
      }
    },
    inBackground: {
      name: 'In Background',
      type: 'boolean',
      value: false,
      description: 'Play animation in background without blocking invokation of other actions',
      depends: {
        animate: true
      }
    }
  },

  argsToShortString(args) {
    return `x: ${args.x}, y: ${args.y} ` + (args.animate ? 'animated' : '');
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (item) {
      if (args.animate) {
        AnimationRegistry/* default.play */.Z.play(new MoveAnimation(item, args, schemeContainer, resultCallback), item.id, this.name);

        if (args.inBackground) {
          resultCallback();
        }

        return;
      } else {
        item.area.x = args.x;
        item.area.y = args.y;
        schemeContainer.reindexItemTransforms(item);
      }
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/MoveToItemFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */







function calculateItemPositionToMatchAnotherItem(item, destinationItem, matchPointType) {
  const dstLocalPoint = {
    x: 0,
    y: 0
  };
  const srcLocalPoint = {
    x: 0,
    y: 0
  };

  if (matchPointType === 'pivot') {
    dstLocalPoint.x = destinationItem.area.px * destinationItem.area.w;
    dstLocalPoint.y = destinationItem.area.py * destinationItem.area.h;
    srcLocalPoint.x = item.area.px * item.area.w;
    srcLocalPoint.y = item.area.py * item.area.h;
  } else if (matchPointType === 'top-right') {
    dstLocalPoint.x = destinationItem.area.w;
    srcLocalPoint.x = item.area.w;
  } else if (matchPointType === 'bottom-left') {
    dstLocalPoint.y = destinationItem.area.h;
    srcLocalPoint.y = item.area.h;
  } else if (matchPointType === 'bottom-right') {
    dstLocalPoint.x = destinationItem.area.w;
    srcLocalPoint.x = item.area.w;
    dstLocalPoint.y = destinationItem.area.h;
    srcLocalPoint.y = item.area.h;
  } else if (matchPointType === 'center') {
    dstLocalPoint.x = destinationItem.area.w / 2;
    srcLocalPoint.x = item.area.w / 2;
    dstLocalPoint.y = destinationItem.area.h / 2;
    srcLocalPoint.y = item.area.h / 2;
  }

  const worldPoint = (0,SchemeContainer/* worldPointOnItem */.rs)(dstLocalPoint.x, dstLocalPoint.y, destinationItem);
  const p = myMath/* default.findTranslationMatchingWorldPoint */.Z.findTranslationMatchingWorldPoint(worldPoint.x, worldPoint.y, srcLocalPoint.x, srcLocalPoint.y, item.area, item.meta.transformMatrix);

  if (p) {
    return p;
  } // fallback if for some reason could not calculate translation point


  return (0,SchemeContainer/* relativePointForItem */.Ym)(worldPoint.x, worldPoint.y, item);
}

class MoveToItemAnimation extends Animation/* default */.Z {
  constructor(item, args, destinationPosition, destinationAngle, destinationWidth, destinationHeight, schemeContainer, resultCallback) {
    super();
    this.item = item;
    this.args = args;
    this.schemeContainer = schemeContainer;
    this.resultCallback = resultCallback;
    this.elapsedTime = 0.0;
    this.originalPosition = {
      x: this.item.area.x,
      y: this.item.area.y
    };
    this.destinationPosition = destinationPosition;
    this.originalAngle = item.area.r;
    this.destinationAngle = destinationAngle;
    this.originalWidth = item.area.w;
    this.destinationWidth = destinationWidth;
    this.originalHeight = item.area.h;
    this.destinationHeight = destinationHeight;
  }

  init() {
    return true;
  }

  play(dt) {
    if (this.args.animate && this.args.duration > 0.00001) {
      this.elapsedTime += dt;
      const t = Math.min(1.0, this.elapsedTime / (this.args.duration * 1000));
      let shouldProceedAnimating = true;
      let convertedT = (0,ValueAnimation/* convertTime */.rJ)(t, this.args.movement);

      if (t >= 1.0) {
        convertedT = 1.0;
        shouldProceedAnimating = false;
      }

      this.item.area.x = this.originalPosition.x * (1.0 - convertedT) + this.destinationPosition.x * convertedT;
      this.item.area.y = this.originalPosition.y * (1.0 - convertedT) + this.destinationPosition.y * convertedT;

      if (this.args.rotate) {
        this.item.area.r = this.originalAngle * (1.0 - convertedT) + this.destinationAngle * convertedT;
      }

      if (this.args.alignWidth) {
        this.item.area.w = this.originalWidth * (1.0 - convertedT) + this.destinationWidth * convertedT;
      }

      if (this.args.alignHeight) {
        this.item.area.h = this.originalHeight * (1.0 - convertedT) + this.destinationHeight * convertedT;
      }

      EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.item.id);
      this.schemeContainer.reindexItemTransforms(this.item);
      return shouldProceedAnimating;
    } else {
      this.item.area.x = this.destinationPosition.x;
      this.item.area.y = this.destinationPosition.y;
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.item.id);
      this.schemeContainer.reindexItemTransforms(this.item);
    }

    return false;
  }

  destroy() {
    if (!this.args.inBackground) {
      this.resultCallback();
    }
  }

}

/* harmony default export */ const MoveToItemFunction = ({
  name: 'Move to Item',
  description: 'Moves item into another item. It also lets rotation and scale align to the destination item with a smooth transition',
  args: {
    destinationItem: {
      name: 'Destination Item',
      type: 'element',
      value: null,
      description: 'Other item to which this item should be moved'
    },
    matchPoint: {
      name: 'Match point',
      type: 'choice',
      value: 'center',
      description: 'Match items points',
      options: ['center', 'pivot', 'top-left', 'top-right', 'bottom-left', 'bottom-right']
    },
    animate: {
      name: 'Animate',
      type: 'boolean',
      value: false
    },
    duration: {
      name: 'Duration (sec)',
      type: 'number',
      value: 2.0,
      depends: {
        animate: true
      }
    },
    movement: {
      name: 'Movement',
      type: 'choice',
      value: 'ease-in-out',
      options: ['linear', 'smooth', 'ease-in', 'ease-out', 'ease-in-out', 'bounce'],
      depends: {
        animate: true
      }
    },
    rotate: {
      name: 'Rotate',
      type: 'boolean',
      value: false,
      description: 'Align rotation of items'
    },
    rotationOffset: {
      name: 'Rotation Offset',
      type: 'number',
      value: 0.0,
      depends: {
        rotate: true
      },
      description: 'Rotation angle offset'
    },
    alignWidth: {
      name: 'Align Width',
      type: 'boolean',
      value: false,
      description: 'Adjust items width so that it fits to the width of its destination item'
    },
    alignHeight: {
      name: 'Align Height',
      type: 'boolean',
      value: false,
      description: 'Adjust items height so that it fits to the height of its destination item'
    },
    inBackground: {
      name: 'In Background',
      type: 'boolean',
      value: false,
      description: 'Play animation in background without blocking invokation of other actions',
      depends: {
        animate: true
      }
    }
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (item) {
      const destinationItem = schemeContainer.findFirstElementBySelector(args.destinationItem, item);
      let destinationAngle = item.area.r;
      let destinationPosition = null;
      let destinationWidth = item.area.w;
      let destinationHeight = item.area.h;

      if (destinationItem && destinationItem.id !== item.id) {
        destinationPosition = calculateItemPositionToMatchAnotherItem(item, destinationItem, args.matchPoint);
        const v1 = (0,SchemeContainer/* worldVectorOnItem */.uI)(item.area.w, 0, item);
        const v2 = (0,SchemeContainer/* worldVectorOnItem */.uI)(destinationItem.area.w, 0, destinationItem);
        const a1 = myMath/* default.fullAngleForVector */.Z.fullAngleForVector(v1.x, v1.y);
        const a2 = myMath/* default.fullAngleForVector */.Z.fullAngleForVector(v2.x, v2.y);
        destinationAngle += (a2 - a1) * 180 / Math.PI;
        destinationWidth = destinationItem.area.w;
        destinationHeight = destinationItem.area.h;
      }

      if (destinationPosition) {
        if (args.animate) {
          AnimationRegistry/* default.play */.Z.play(new MoveToItemAnimation(item, args, destinationPosition, destinationAngle, destinationWidth, destinationHeight, schemeContainer, resultCallback), item.id, this.name);

          if (args.inBackground) {
            resultCallback();
          }

          return;
        } else {
          item.area.x = destinationPosition.x;
          item.area.y = destinationPosition.y;

          if (args.rotate) {
            item.area.r = destinationAngle + args.rotationOffset;
          }

          if (args.alignWidth) {
            item.area.w = destinationWidth;
          }

          if (args.alignHeight) {
            item.area.h = destinationHeight;
          }

          EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
          schemeContainer.reindexItemTransforms(item);
        }
      }
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/ReplaceItemFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
function ReplaceItemFunction_calculateItemPositionToMatchAnotherItem(item, destinationItem, schemeContainer) {
  const worldPoint = schemeContainer.worldPointOnItem(0, 0, destinationItem);
  return schemeContainer.relativePointForItem(worldPoint.x, worldPoint.y, item);
}

/* harmony default export */ const ReplaceItemFunction = ({
  name: 'Replace Item',
  description: 'Hides destination item and moves your item to it. This is usefull in case you want to design mocked interface',
  args: {
    destinationItem: {
      name: 'Destination Item',
      type: 'element',
      value: null,
      description: 'Other item which this item should replace'
    }
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (item) {
      const destinationItem = schemeContainer.findFirstElementBySelector(args.destinationItem, item);
      let destinationPosition = null;

      if (destinationItem && destinationItem.id !== item.id) {
        destinationPosition = ReplaceItemFunction_calculateItemPositionToMatchAnotherItem(item, destinationItem, schemeContainer);
        destinationItem.visible = false;
        item.visible = true;
        item.area.x = destinationPosition.x;
        item.area.y = destinationPosition.y;
        schemeContainer.reindexItemTransforms(item);
      }
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/RotateFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





class RotateAnimation extends Animation/* default */.Z {
  constructor(item, args, schemeContainer, resultCallback) {
    super();
    this.item = item;
    this.args = args;
    this.schemeContainer = schemeContainer;
    this.resultCallback = resultCallback;
    this.elapsedTime = 0.0;
    this.originalAngle = this.item.area.r;
    this.destinationAngle = parseFloat(args.angle);
  }

  init() {
    return true;
  }

  play(dt) {
    if (this.args.animate && this.args.duration > 0.00001) {
      this.elapsedTime += dt;
      const t = Math.min(1.0, this.elapsedTime / (this.args.duration * 1000));
      let convertedT = (0,ValueAnimation/* convertTime */.rJ)(t, this.args.movement);
      let proceed = true;

      if (t >= 1.0) {
        proceed = false;
        convertedT = 1.0;
        return false;
      }

      this.item.area.r = this.originalAngle * (1.0 - convertedT) + this.destinationAngle * convertedT;
      this.schemeContainer.reindexItemTransforms(this.item);
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.item.id);
      return proceed;
    } else {
      this.item.area.r = this.destinationAngle;
      this.schemeContainer.reindexItemTransforms(this.item);
    }

    EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.item.id);
    return false;
  }

  destroy() {
    if (!this.args.inBackground) {
      this.resultCallback();
    }
  }

}

/* harmony default export */ const RotateFunction = ({
  name: 'Rotate',
  description: 'Rotates item by specified angle',
  args: {
    angle: {
      name: 'Angle',
      type: 'number',
      value: 0
    },
    animate: {
      name: 'Animate',
      type: 'boolean',
      value: false
    },
    duration: {
      name: 'Duration (sec)',
      type: 'number',
      value: 2.0,
      depends: {
        animate: true
      }
    },
    movement: {
      name: 'Movement',
      type: 'choice',
      value: 'ease-out',
      options: ['linear', 'smooth', 'ease-in', 'ease-out', 'ease-in-out', 'bounce'],
      depends: {
        animate: true
      }
    },
    inBackground: {
      name: 'In Background',
      type: 'boolean',
      value: false,
      description: 'Play animation in background without blocking invokation of other actions',
      depends: {
        animate: true
      }
    }
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (item) {
      if (args.animate) {
        AnimationRegistry/* default.play */.Z.play(new RotateAnimation(item, args, schemeContainer, resultCallback), item.id, this.name);

        if (args.inBackground) {
          resultCallback();
        }

        return;
      } else {
        item.area.r = parseFloat(args.angle);
        schemeContainer.reindexItemTransforms(item);
      }
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/ScaleFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */






class ScaleAnimation extends Animation/* default */.Z {
  constructor(item, args, schemeContainer, resultCallback) {
    super();
    this.item = item;
    this.args = args;
    this.schemeContainer = schemeContainer;
    this.resultCallback = resultCallback;
    this.elapsedTime = 0.0;
    this.originalArea = utils/* default.clone */.Z.clone(item.area);
    this.destinationScale = {
      sx: parseFloat(args.scaleX),
      sy: parseFloat(args.scaleY)
    };
  }

  init() {
    return true;
  }

  play(dt) {
    if (this.args.animate && this.args.duration > 0.00001) {
      this.elapsedTime += dt;
      const t = Math.min(1.0, this.elapsedTime / (this.args.duration * 1000));
      let convertedT = (0,ValueAnimation/* convertTime */.rJ)(t, this.args.movement);
      let proceed = true;

      if (t >= 1.0) {
        proceed = false;
        convertedT = 1.0;
      }

      this.item.area.sx = this.originalArea.sx * (1.0 - convertedT) + this.destinationScale.sx * convertedT;
      this.item.area.sy = this.originalArea.sy * (1.0 - convertedT) + this.destinationScale.sy * convertedT;
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.item.id);
      this.schemeContainer.reindexItemTransforms(this.item);
      return proceed;
    } else {
      this.item.area.sx = this.destinationScale.sx;
      this.item.area.sy = this.destinationScale.sy;
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.item.id);
      this.schemeContainer.reindexItemTransforms(this.item);
    }

    return false;
  }

  destroy() {
    if (!this.args.inBackground) {
      this.resultCallback();
    }
  }

}

/* harmony default export */ const ScaleFunction = ({
  name: 'Scale',
  description: 'Changes width and height of the item',
  args: {
    scaleX: {
      name: 'Scale X',
      type: 'number',
      value: 1.5
    },
    scaleY: {
      name: 'Scale Y',
      type: 'number',
      value: 1.5
    },
    animate: {
      name: 'Animate',
      type: 'boolean',
      value: true
    },
    duration: {
      name: 'Duration (sec)',
      type: 'number',
      value: 2.0,
      depends: {
        animate: true
      }
    },
    movement: {
      name: 'Movement',
      type: 'choice',
      value: 'ease-out',
      options: ['linear', 'smooth', 'ease-in', 'ease-out', 'ease-in-out', 'bounce'],
      depends: {
        animate: true
      }
    },
    inBackground: {
      name: 'In Background',
      type: 'boolean',
      value: false,
      description: 'Play animation in background without blocking invokation of other actions',
      depends: {
        animate: true
      }
    }
  },

  argsToShortString(args) {
    return `x: ${args.scaleX}, y: ${args.scaleY}` + (args.animate ? ', animated' : '');
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (item) {
      if (args.animate) {
        AnimationRegistry/* default.play */.Z.play(new ScaleAnimation(item, args, schemeContainer, resultCallback), item.id, this.name);

        if (args.inBackground) {
          resultCallback();
        }

        return;
      } else {
        item.area.sx = parseFloat(args.scaleX);
        item.area.sy = parseFloat(args.scaleY);
        EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
        schemeContainer.reindexItemTransforms(item);
      }
    }

    resultCallback();
  }

});
// EXTERNAL MODULE: ./src/ui/animations/functions/MoveAlongPathAnimationFunction.js
var MoveAlongPathAnimationFunction = __webpack_require__(3277);
;// CONCATENATED MODULE: ./src/ui/userevents/functions/MoveAlongPathFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */







class MoveAlongPathAnimation extends Animation/* default */.Z {
  constructor(item, args, schemeContainer, resultCallback) {
    super();
    this.item = item;
    this.args = args;
    this.schemeContainer = schemeContainer;
    this.resultCallback = resultCallback;
    this.elapsedTime = 0.0;
    this.originalPosition = {
      x: this.item.area.x,
      y: this.item.area.y
    };
    this.domPath = null;
    this.pathItem = null;
    this.pathTotalLength = 1.0;
  }

  init() {
    if (this.args.path) {
      const element = this.schemeContainer.findFirstElementBySelector(this.args.path, this.item);

      if (element) {
        const shape = Shape/* default.find */.Z.find(element.shape);

        if (shape) {
          const path = shape.computeOutline(element);

          if (path) {
            this.domPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
            this.domPath.setAttribute('d', path);
            this.pathItem = element;
          }
        }
      }

      if (this.domPath) {
        this.pathTotalLength = this.domPath.getTotalLength();
      }
    }

    return true;
  }

  play(dt) {
    if (this.domPath && this.args.duration > 0.00001) {
      this.elapsedTime += dt;
      const t = Math.min(1.0, this.elapsedTime / (this.args.duration * 1000));

      if (t >= 1.0) {
        this.moveToPathLength(this.pathTotalLength * this.args.endPosition / 100.0);
        return false;
      }

      const convertedT = (0,ValueAnimation/* convertTime */.rJ)(t, this.args.movement);
      this.moveToPathLength(this.pathTotalLength * (this.args.startPosition * (1.0 - convertedT) + this.args.endPosition * convertedT) / 100.0);
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.item.id);
      return true;
    }

    return false;
  }

  moveToPathLength(length) {
    MoveAlongPathAnimationFunction/* default.execute */.Z.execute({
      path: this.domPath,
      item: this.item,
      pathItem: this.pathItem,
      schemeContainer: this.schemeContainer,
      totalLength: this.pathTotalLength,
      rotateItem: this.args.rotateItem,
      rotationOffset: this.args.rotationOffset
    }, {
      distance: 100 * length / Math.max(1, this.pathTotalLength),
      rotation: 0
    });
  }

  destroy() {
    if (!this.args.inBackground) {
      this.resultCallback();
    }
  }

}

/* harmony default export */ const MoveAlongPathFunction = ({
  name: 'Move Along Path',
  description: 'Moves item along the outline of the other item. It is best to use this effect when moving item along the custom curve',
  args: {
    path: {
      name: 'Path',
      type: 'element',
      value: null
    },
    movement: {
      name: 'Movement',
      type: 'choice',
      value: 'ease-in-out',
      options: ['linear', 'smooth', 'ease-in', 'ease-out', 'ease-in-out', 'bounce']
    },
    duration: {
      name: 'Duration (sec)',
      type: 'number',
      value: 2.0,
      min: 0
    },
    startPosition: {
      name: 'Start position (%)',
      type: 'number',
      value: 0,
      description: 'Initial position on the path in percentage to its total length'
    },
    endPosition: {
      name: 'End position (%)',
      type: 'number',
      value: 100,
      description: 'Final position on the path in percentage to its total length'
    },
    rotateItem: {
      name: 'Rotate item',
      type: 'boolean',
      value: false,
      description: 'Adjust rotation of the item to path'
    },
    rotationOffset: {
      name: 'Rotation offset',
      type: 'number',
      value: 0,
      description: 'Rotation angle offset',
      depends: {
        rotateItem: true
      }
    },
    inBackground: {
      name: 'In Background',
      type: 'boolean',
      value: false,
      description: 'Play animation in background without blocking invokation of other actions'
    }
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (item) {
      AnimationRegistry/* default.play */.Z.play(new MoveAlongPathAnimation(item, args, schemeContainer, resultCallback), item.id, this.name);

      if (args.inBackground) {
        resultCallback();
      }

      return;
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/MoveRandomlyFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */






class MoveRandomlyAnimation extends Animation/* default */.Z {
  constructor(item, args, schemeContainer, resultCallback) {
    super();
    this.item = item;
    this.args = args;
    this.schemeContainer = schemeContainer;
    this.resultCallback = resultCallback;
    this.elapsedTime = 0.0;
    this.itemInitialPosition = {
      x: this.item.area.x,
      y: this.item.area.y
    };
    this.point1 = {
      x: this.item.area.x,
      y: this.item.area.y
    };
    this.point2 = this.pickRandomPosition();
    this.point3 = this.pickRandomPosition();
    this._t = 0;
  }

  init() {
    return true;
  }

  pickRandomPosition() {
    const angle = Math.random() * Math.PI * 2;
    const R = Math.random() * this.args.radius;
    return {
      x: R * Math.cos(angle) + this.itemInitialPosition.x,
      y: R * Math.sin(angle) + this.itemInitialPosition.y
    };
  }

  play(dt) {
    if (this.args.duration > 0.00001 && this.elapsedTime < this.args.duration * 1000) {
      this.elapsedTime += dt;
      this._t += dt * this.args.speed / 1000;

      if (this._t >= 1.0) {
        this._t = 0;
        this.point1 = {
          x: this.item.area.x,
          y: this.item.area.y
        };
        this.point2 = this.pickRandomPosition();
        this.point3 = this.pickRandomPosition();
      }

      const t = (0,ValueAnimation/* convertTime */.rJ)(this._t, 'ease-in-out');
      this.item.area.x = Math.pow(1 - t, 2) * this.point1.x + 2 * (1 - t) * t * this.point2.x + t * t * this.point3.x;
      this.item.area.y = Math.pow(1 - t, 2) * this.point1.y + 2 * (1 - t) * t * this.point2.y + t * t * this.point3.y;
      this.schemeContainer.reindexItemTransforms(this.item);
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.item.id);
      return true;
    } else {
      this.item.area.x = this.itemInitialPosition.x;
      this.item.area.y = this.itemInitialPosition.y;
      this.schemeContainer.reindexItemTransforms(this.item);
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(this.item.id);
    }

    return false;
  }

  destroy() {
    this.item.area.x = this.itemInitialPosition.x;
    this.item.area.y = this.itemInitialPosition.y;
    this.schemeContainer.reindexItemTransforms(this.item);

    if (!this.args.inBackground) {
      this.resultCallback();
    }
  }

}

/* harmony default export */ const MoveRandomlyFunction = ({
  name: 'Move Randomly',
  description: 'Moves item in a chaotic manner around its original location',
  args: {
    radius: {
      name: 'Moving Radius',
      type: 'number',
      value: 20,
      description: 'Radius within which it will perform random movements'
    },
    speed: {
      name: 'Moving Speed',
      type: 'number',
      value: 1.0,
      description: 'Speed of each random movements'
    },
    duration: {
      name: 'Duration (sec)',
      type: 'number',
      value: 2.0
    },
    inBackground: {
      name: 'In Background',
      type: 'boolean',
      value: false,
      description: 'Play animation in background without blocking invokation of other actions'
    }
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (item) {
      AnimationRegistry/* default.play */.Z.play(new MoveRandomlyAnimation(item, args, schemeContainer, resultCallback), item.id, this.name);

      if (args.inBackground) {
        resultCallback();
      }

      return;
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/WaitFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/* harmony default export */ const WaitFunction = ({
  name: 'Wait',
  description: 'Waits for specified amount of time until the next function',
  args: {
    time: {
      type: 'number',
      value: 0.1,
      name: 'Time (s)',
      description: 'Number of seconds for which it should wait until executing next action in the list'
    }
  },

  argsToShortString(args) {
    return '' + args.time;
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    setTimeout(resultCallback, args.time * 1000.0);
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/ToggleFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



 // Stack of visiblity states for all top-level items

const visibilitiesStack = [];
function popPreviousVisibilites() {
  if (visibilitiesStack.length > 0) {
    return visibilitiesStack.pop();
  }

  return null;
}
/* harmony default export */ const ToggleFunction = ({
  name: 'Toggle',
  description: 'Hides all other items on screen, leaving only the selected item visible',
  args: {},

  /**
   * 
   * @param {Item} item 
   * @param {Object} args 
   * @param {SchemeContainer} schemeContainer 
   * @param {*} userEventBus 
   * @param {*} resultCallback 
   */
  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    const visibilities = {
      itemId: item.id,
      allItems: {}
    };
    forEach_default()(schemeContainer.getTopLevelItems(), topLevelItem => {
      visibilities.allItems[topLevelItem.id] = topLevelItem.visible;

      if (topLevelItem.id !== item.id) {
        topLevelItem.visible = false;
        EventBus/* default.emitItemChanged */.Z.emitItemChanged(topLevelItem.id);
      }
    }); // checking whether the item was toggled already

    if (visibilitiesStack.length === 0 || visibilitiesStack[visibilitiesStack.length - 1].itemId !== item.id) {
      visibilitiesStack.push(visibilities);
    }

    item.visible = true;
    EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/UntoggleFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





/* harmony default export */ const UntoggleFunction = ({
  name: 'Untoggle',
  description: 'Restores previous state of items before using "Toggle" function',
  args: {},

  /**
   * 
   * @param {Item} item 
   * @param {Object} args 
   * @param {SchemeContainer} schemeContainer 
   * @param {*} userEventBus 
   * @param {*} resultCallback 
   */
  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    const visibilities = popPreviousVisibilites();

    if (visibilities) {
      forEach_default()(schemeContainer.getTopLevelItems(), topLevelItem => {
        topLevelItem.visible = visibilities.allItems[topLevelItem.id];
        EventBus/* default.emitItemChanged */.Z.emitItemChanged(topLevelItem.id);
      });
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/PlayFramesFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

/* harmony default export */ const PlayFramesFunction = ({
  name: 'Play Frames',
  description: 'Triggers animations in specified frame player',
  supportedShapes: ['frame_player'],
  args: {
    startFrame: {
      type: 'number',
      value: 1,
      min: 1,
      name: 'Starting frame'
    },
    partial: {
      type: 'boolean',
      value: false,
      name: 'Play partial',
      description: 'Play only until specified stop frame'
    },
    stopFrame: {
      type: 'number',
      value: 1,
      min: 1,
      name: 'Stop frame',
      depends: {
        partial: true
      }
    }
  },

  argsToShortString(args) {
    return `from ${args.startFrame} ` + (args.partial ? `till ${args.stopFrame}` : 'till end');
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (!item) {
      resultCallback();
      return;
    }

    const frameAnimation = schemeContainer.getFrameAnimation(item.id);

    if (!frameAnimation) {
      resultCallback();
      return;
    }

    frameAnimation.setFrame(args.startFrame);

    if (args.partial) {
      frameAnimation.setStopFrame(args.stopFrame);
    } else {
      frameAnimation.setStopFrame(-1);
    }

    AnimationRegistry/* default.play */.Z.play(frameAnimation, item.id, 'frame-player');
    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/StopFramePlayerFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/* harmony default export */ const StopFramePlayerFunction = ({
  name: 'Stop Frame Player',
  description: 'Stops currently running animation in specified frame player',
  supportedShapes: ['frame_player'],

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (!item) {
      resultCallback();
      return;
    }

    const frameAnimation = schemeContainer.getFrameAnimation(item.id);

    if (!frameAnimation) {
      resultCallback();
      return;
    }

    frameAnimation.enabled = false;
    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/LoadComponentFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/* harmony default export */ const LoadComponentFunction = ({
  name: 'Load component',
  description: 'Triggers loading of component. Applicable to "component" shapes only',
  args: {},
  supportedShapes: ['component'],

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    // Have to use this setTimeout trick to make sure that any previous changes to the item get rendered first
    // e.g. it is common to hide component and show it right before loading it.
    // when component item is hidden its vue component is not yet loaded and does not register handlers in EventBus
    // If user wants the progress bar to be shown in the component which was previously hidden, this is the only way to go
    // as we need to make sure this code gets executed in the next event loop cycle.
    setTimeout(() => {
      if (!item || !item.shape === 'component') {
        resultCallback();
        return;
      }

      const eventBus = schemeContainer.getEventBus();

      if (!eventBus) {
        resultCallback();
        return;
      }

      eventBus.emitComponentLoadRequested(item);
      resultCallback();
    });
  }

});
// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/Component.vue + 4 modules
var Component = __webpack_require__(332);
;// CONCATENATED MODULE: ./src/ui/userevents/functions/DestroyComponentFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


/* harmony default export */ const DestroyComponentFunction = ({
  name: 'Destroy component',
  description: 'Removes all the loaded items of the component. Applicable to "component" shapes only',
  args: {},
  supportedShapes: ['component'],

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    try {
      item._childItems = {};
      schemeContainer.reindexItems();
      userEventBus.emitItemEvent(item.id, Component/* COMPONENT_DESTROYED */.YL);
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
    } catch (err) {
      console.error(err);
    }

    resultCallback();
  }

});
// EXTERNAL MODULE: ./node_modules/lodash/find.js
var find = __webpack_require__(3311);
var find_default = /*#__PURE__*/__webpack_require__.n(find);
;// CONCATENATED MODULE: ./src/ui/userevents/functions/ToggleGroupFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





/* harmony default export */ const ToggleGroupFunction = ({
  name: 'Toggle in group',
  description: 'Hides all other items of by specified tag, leaving only the specified item visible',
  args: {
    group: {
      name: 'Tag',
      type: 'element',
      description: 'Tag representing a group of items that will be hidden instead of the toggled item'
    }
  },

  argsToShortString(args) {
    if (args.group) {
      return args.group;
    } else {
      return '...';
    }
  },

  // Means that this function is always expected to get array of items and in cases when it is applied
  // to a group of items - it will only be invoked once with array of those items as a first argument
  multiItem: true,

  /**
   * 
   * @param {Array} items
   * @param {Object} args 
   * @param {SchemeContainer} schemeContainer 
   * @param {*} userEventBus 
   * @param {*} resultCallback 
   */
  execute(items, args, schemeContainer, userEventBus, resultCallback) {
    const groupItems = schemeContainer.findElementsBySelector(args.group);
    forEach_default()(groupItems, groupItem => {
      if (!find_default()(items, item => item.id === groupItem.id)) {
        groupItem.visible = false;
        EventBus/* default.emitItemChanged */.Z.emitItemChanged(groupItem.id);
      }
    });
    forEach_default()(items, item => {
      item.visible = true;
      EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
    });
    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/SendEventToParentFuction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/* harmony default export */ const SendEventToParentFuction = ({
  name: 'Send to parent',
  description: `Sends custom events to parent of this item.
It can be used for cross-component communication`,
  args: {
    event: {
      name: 'Event',
      type: 'string',
      value: 'Unknown event...'
    }
  },

  argsToShortString(args) {
    return args.event;
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (item.meta && item.meta.parentId) {
      userEventBus.emitItemEvent(item.meta.parentId, args.event);
      const parent = schemeContainer.findItemById(item.meta.parentId);

      if (!parent) {
        return;
      } // retransmitting event to component holder


      if (parent.meta.isComponentContainer && parent.meta.parentId) {
        userEventBus.emitItemEvent(parent.meta.parentId, args.event);
      }
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/SendEventToChildrenFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/* harmony default export */ const SendEventToChildrenFunction = ({
  name: 'Send event to children',
  description: `Sends specified event to all children of an item.
This can be used for cross-component communication.
Using this function you can send event into dynamic component`,
  args: {
    event: {
      name: 'Event',
      type: 'string',
      value: 'Unknown event...'
    }
  },

  argsToShortString(args) {
    return args.event;
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (item.shape === 'component') {
      if (Array.isArray(item._childItems)) {
        item._childItems.forEach(childItem => {
          if (childItem.meta.isComponentContainer) {
            sendEventToItems(childItem.childItems, args.event, userEventBus);
            sendEventToItems(childItem._childItems, args.event, userEventBus);
          }
        });
      }
    }

    sendEventToItems(item.childItems, args.event, userEventBus);
    sendEventToItems(item._childItems, args.event, userEventBus);
    resultCallback();
  }

});

function sendEventToItems(items, event, userEventBus) {
  if (!Array.isArray(items)) {
    return;
  }

  items.forEach(item => {
    userEventBus.emitItemEvent(item.id, event);
  });
}
// EXTERNAL MODULE: ./src/ui/userevents/Events.js
var Events = __webpack_require__(6085);
// EXTERNAL MODULE: ./src/ui/userevents/Compiler.js
var Compiler = __webpack_require__(2672);
;// CONCATENATED MODULE: ./src/ui/userevents/functions/CopyEventsFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


const behaviorCompiler = new Compiler/* default */.Z();
/* harmony default export */ const CopyEventsFunction = ({
  name: 'Copy events',
  description: 'Copies all events except init from the source item to destination items',
  args: {
    destination: {
      name: 'Destination',
      type: 'element',
      value: null,
      description: 'Other item or an item group to which you want to copy events from the source'
    }
  },

  argsToShortString(args) {
    if (args.destination) {
      return `${args.destination}`;
    }

    return '...';
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (!item) {
      resultCallback();
      return;
    }

    try {
      const dstItems = schemeContainer.findElementsBySelector(args.destination);

      if (item.behavior && Array.isArray(item.behavior.events)) {
        dstItems.forEach(dstItem => {
          item.behavior.events.forEach(event => {
            if (event.event !== Events/* default.standardEvents.init.id */.Z.standardEvents.init.id) {
              const eventCallback = behaviorCompiler.compileActions(schemeContainer, dstItem, event.actions);
              userEventBus.subscribeItemEvent(dstItem.id, event.event, eventCallback);
            }
          });
        });
      }
    } catch (err) {
      console.error(err);
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/RepeaterFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/* harmony default export */ const RepeaterFunction = ({
  name: 'Repeat',
  args: {
    name: {
      name: 'Name',
      type: 'string',
      value: '',
      description: 'Unique name of the repeater, with which it can be identified in the "Stop repeater" function'
    },
    forever: {
      name: 'Run forever',
      type: 'boolean',
      value: true
    },
    count: {
      name: 'Number of repeatitions',
      type: 'number',
      value: 10,
      min: 0,
      depends: {
        forever: false
      }
    }
  },

  argsToShortString(args) {
    return args.forever ? 'forever' : `${args.count} times`;
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback, subscribedItem, eventName) {
    const suffix = args.name ? args.name : eventName;
    const startedField = `repeaterStarted_${suffix}`;
    const stoppedField = `repeaterStopped_${suffix}`;
    const counterField = `repeaterCounter_${suffix}`;
    const timeField = `repeaterStartTime_${suffix}`;

    const reset = () => {
      delete subscribedItem.meta[counterField];
      delete subscribedItem.meta[timeField];
      delete subscribedItem.meta[startedField];
      delete subscribedItem.meta[stoppedField];
    };

    if (!subscribedItem.meta.hasOwnProperty(counterField)) {
      if (args.forever) {
        subscribedItem.meta[counterField] = -1;
      } else {
        subscribedItem.meta[counterField] = args.count;
      }

      subscribedItem.meta[timeField] = Date.now();
    }

    if (subscribedItem.meta[counterField] === 0 || subscribedItem.meta[stoppedField]) {
      reset();
    } else {
      const invocationCount = args.forever ? Math.abs(subscribedItem.meta[counterField]) : Math.abs(args.count - subscribedItem.meta[counterField]); // protection from useless eternal loop, checking if it is running more than 30 times a second

      const timeEllapsed = Date.now() - subscribedItem.meta[timeField];

      if (timeEllapsed > 0 && invocationCount * 1000 / timeEllapsed > 30) {
        reset();
        resultCallback();
        return;
      }

      subscribedItem.meta[counterField] -= 1;
      subscribedItem.meta[startedField] = true;
      setTimeout(() => {
        userEventBus.emitItemEvent(subscribedItem.id, eventName);
      });
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/StopRepeaterFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/* harmony default export */ const StopRepeaterFunction = ({
  name: 'Stop repeater',
  args: {
    name: {
      name: 'Name',
      type: 'string',
      value: '',
      description: 'Unique name of the repeater, which should be stopped'
    }
  },

  argsToShortString(args) {
    return args.name ? args.name : '...';
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback, subscribedItem, eventName) {
    const suffix = args.name ? args.name : eventName;
    const startedField = `repeaterStarted_${suffix}`;
    const stoppedField = `repeaterStopped_${suffix}`;

    if (item.meta[startedField]) {
      item.meta[stoppedField] = true;
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/CopyLinksFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/* harmony default export */ const CopyLinksFunction = ({
  name: 'Copy links',
  description: 'Copies all links from the source item to destination items. It does not replace exsiting links, but adds new links from the source item',
  args: {
    destination: {
      name: 'Destination',
      type: 'element',
      value: null,
      description: 'Other item or an item group to which you want to copy links from the source'
    }
  },

  argsToShortString(args) {
    if (args.destination) {
      return `${args.destination}`;
    }

    return '...';
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (!item) {
      resultCallback();
      return;
    }

    try {
      const dstItems = schemeContainer.findElementsBySelector(args.destination);

      if (!Array.isArray(item.links) || item.links.length === 0) {
        resultCallback();
        return;
      }

      dstItems.forEach(dstItem => {
        if (!Array.isArray(dstItem.links)) {
          dstItem.links = [];
        }

        dstItem.links = dstItem.links.concat(item.links);
      });
    } catch (err) {
      console.error(err);
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/CopyDescriptionFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
/* harmony default export */ const CopyDescriptionFunction = ({
  name: 'Copy description',
  description: 'Copies description from the source item to destination items. It does not replace exsiting description, but adds to the existing one',
  args: {
    destination: {
      name: 'Destination',
      type: 'element',
      value: null,
      description: 'Other item or an item group to which you want to copy description from the source'
    }
  },

  argsToShortString(args) {
    if (args.destination) {
      return `${args.destination}`;
    }

    return '...';
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    if (!item) {
      resultCallback();
      return;
    }

    try {
      const dstItems = schemeContainer.findElementsBySelector(args.destination);

      if (!item.description) {
        resultCallback();
        return;
      }

      dstItems.forEach(dstItem => {
        dstItem.description += item.description;
      });
    } catch (err) {
      console.error(err);
    }

    resultCallback();
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/TransformScreenFunction.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



/* harmony default export */ const TransformScreenFunction = ({
  name: 'Transform Screen (Hidden)',
  description: 'Animates changing screen transform',
  args: {
    x: {
      name: 'x',
      type: 'number',
      value: 0
    },
    y: {
      name: 'y',
      type: 'number',
      value: 0
    },
    scale: {
      name: 'scale',
      type: 'number',
      value: 0
    }
  },

  argsToShortString(args) {
    if (args.animated) {
      return `animated, ${args.animationDuration} sec`;
    }

    return 'instant';
  },

  execute(item, args, schemeContainer, userEventBus, resultCallback) {
    const oldX = schemeContainer.screenTransform.x;
    const oldY = schemeContainer.screenTransform.y;
    const oldZoom = schemeContainer.screenTransform.scale;
    AnimationRegistry/* default.play */.Z.play(new ValueAnimation/* default */.ZP({
      durationMillis: 500.0,
      animationType: 'ease-in-out',
      update: t => {
        schemeContainer.screenTransform.scale = oldZoom * (1.0 - t) + args.scale * t;
        schemeContainer.screenTransform.x = oldX * (1.0 - t) + args.x * t;
        schemeContainer.screenTransform.y = oldY * (1.0 - t) + args.y * t;
      },
      destroy: () => {
        EventBus/* default.$emit */.Z.$emit(EventBus/* default.SCREEN_TRANSFORM_UPDATED */.Z.SCREEN_TRANSFORM_UPDATED, schemeContainer.screenTransform);
        resultCallback();
      }
    }), 'screen', 'screen-transform');
  }

});
;// CONCATENATED MODULE: ./src/ui/userevents/functions/Functions.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
































/* harmony default export */ const Functions = ({
  main: {
    hide: HideFunction,
    show: ShowFunction,
    set: SetFunction,
    zoomToIt: ZoomToItFunction,
    _transformScreen: TransformScreenFunction,
    particleEffect: ItemParticleEffectFunction,
    crawlEffect: CrawlEffectFunction,
    blinkEffect: BlinkEffectFunction,
    loadComponent: LoadComponentFunction,
    destroyComponent: DestroyComponentFunction,
    move: MoveFunction,
    moveAlongPath: MoveAlongPathFunction,
    moveToItem: MoveToItemFunction,
    moveRandomly: MoveRandomlyFunction,
    playFrames: PlayFramesFunction,
    rotate: RotateFunction,
    scale: ScaleFunction,
    replaceItem: ReplaceItemFunction,
    stopFramePlayer: StopFramePlayerFunction,
    stopAllAnimations: StopAllAnimationsFunction,
    sendEvent: SendEventFunction,
    sendEventToParent: SendEventToParentFuction,
    sendEventToChildren: SendEventToChildrenFunction,
    wait: WaitFunction,
    toggle: ToggleFunction,
    untoggle: UntoggleFunction,
    toggleGroup: ToggleGroupFunction,
    copyEvents: CopyEventsFunction,
    copyLinks: CopyLinksFunction,
    copyDescription: CopyDescriptionFunction,
    repeater: RepeaterFunction,
    stopRepeater: StopRepeaterFunction
  },
  scheme: {}
});

/***/ }),

/***/ 4691:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4486);
/* harmony import */ var lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_forEach__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5161);
/* harmony import */ var lodash_map__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_map__WEBPACK_IMPORTED_MODULE_1__);
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



function leadingZero(number) {
  if (number < 10) {
    return '0' + number;
  } else {
    return '' + number;
  }
}

function sanitizeItem(oldItem) {
  let item = {};
  lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(oldItem, (value, field) => {
    if (field === 'childItems') {
      item[field] = lodash_map__WEBPACK_IMPORTED_MODULE_1___default()(value, sanitizeItem);
    } else if (field !== 'meta' && field !== '_childItems') {
      item[field] = value;
    }
  });
  return item;
}

function sanitizeScheme(scheme) {
  const items = lodash_map__WEBPACK_IMPORTED_MODULE_1___default()(scheme.items, sanitizeItem);
  return {
    id: scheme.id,
    name: scheme.name,
    description: scheme.description,
    tags: scheme.tags,
    modifiedTime: scheme.modifiedTime,
    items: items,
    style: scheme.style || {}
  };
}

function formatDateAndTime(dateInMillis) {
  var d = new Date(dateInMillis);
  return `${leadingZero(d.getFullYear())}.${leadingZero(d.getMonth())}.${leadingZero(d.getDate())} ${leadingZero(d.getHours())}:${leadingZero(d.getMinutes())}`;
}

function clone(obj) {
  if (typeof obj === 'undefined' || obj === null) {
    return null;
  }

  return JSON.parse(JSON.stringify(obj));
}

function extendObject(originalObject, overrideObject) {
  lodash_forEach__WEBPACK_IMPORTED_MODULE_0___default()(overrideObject, (value, key) => {
    if (!originalObject.hasOwnProperty(key)) {
      originalObject[key] = clone(value);
    } else {
      if (typeof value === 'object') {
        extendObject(originalObject[key], value);
      }
    }
  });
  return originalObject;
}
/**
 * 
 * @param {object} obj 
 * @param {string|Array} propertyPath - a dot separated path to a property inside a given object
 */


function getObjectProperty(item, propertyPath) {
  if (item) {
    let objectPath = null;

    if (Array.isArray(propertyPath)) {
      objectPath = propertyPath;
    } else {
      objectPath = propertyPath.split('.');
    }

    let field = item;
    let i = 0;

    while (i < objectPath.length) {
      const fieldName = objectPath[i].trim();

      if (fieldName) {
        if (i < objectPath.length - 1) {
          field = field[fieldName];

          if (typeof field !== 'object') {
            // not doing anything since there is a conflict
            return undefined;
          }
        } else {
          // this is the lowest nested property
          if (field.hasOwnProperty(fieldName)) {
            return field[fieldName];
          }
        }
      } else {
        //Probably an error
        return undefined;
      }

      i += 1;
    }
  }

  return undefined;
}
/**
 * 
 * @param {Object} obj 
 * @param {String|Array} propertyPath either encoded property path in string or an array of fields
 * @param {*} value 
 * @returns 
 */


function setObjectProperty(obj, propertyPath, value) {
  let objectPath = null;

  if (Array.isArray(propertyPath)) {
    objectPath = propertyPath;
  } else {
    objectPath = propertyPath.split('.');
  }

  let field = obj;
  let i = 0;

  while (i < objectPath.length) {
    const fieldName = objectPath[i].trim();

    if (fieldName) {
      if (i < objectPath.length - 1) {
        if (!field.hasOwnProperty(fieldName)) {
          field[fieldName] = {};
        }

        field = field[fieldName];

        if (typeof field !== 'object') {
          // not doing anything since there is a conflict
          return;
        }
      } else {
        // this is the lowest nested property
        field[fieldName] = value;
        return;
      }
    } else {
      //Probably an error, so return and don't do anything.
      return;
    }

    i += 1;
  }
}

function rotatePointAroundCenter(px, py, angle, cx, cy) {
  const vx = px - cx;
  const vy = py - cy;
  const rotated = rotateVector(vx, vy, angle);
  return {
    x: cx + rotated.x,
    y: cy + rotated.y
  };
}

function rotateVector(x, y, angle) {
  const cs = Math.cos(angle * Math.PI / 180);
  const sn = Math.sin(angle * Math.PI / 180);
  return {
    x: x * cs - y * sn,
    y: x * sn + y * cs
  };
}

function enumerateConstants(obj) {
  const props = [];

  for (let key in obj) {
    // checking if property is all uppercase
    if (obj.hasOwnProperty(key) && key === key.toUpperCase()) {
      props.push(obj[key]);
    }
  }

  return props;
}

function domHasParentNode(domElement, callbackCheck) {
  if (callbackCheck(domElement)) {
    return true;
  }

  ;

  if (domElement.parentElement) {
    return domHasParentNode(domElement.parentElement, callbackCheck);
  }

  return false;
}

function domFindAncestorByClassUntil(domElement, cssClass, stopCallback) {
  if (domElement.classList.contains(cssClass)) {
    return domElement;
  }

  if (stopCallback) {
    if (stopCallback(domElement)) {
      return null;
    }
  }

  if (domElement.parentElement) {
    return domFindAncestorByClassUntil(domElement.parentElement, cssClass, stopCallback);
  }

  return null;
}

function forceDownload(fileName, contentType, content) {
  const dataUrl = `data:${contentType};base64,${btoa(content)}`;
  const link = document.createElement('a');
  document.body.appendChild(link);

  try {
    link.href = dataUrl;
    link.download = fileName;
    link.click();
  } catch (e) {
    console.error(e);
  }

  setTimeout(() => document.body.removeChild(link), 100);
}
/**
 * Compares two objects for deep equality
 * @param {*} v1 
 * @param {*} v2 
 */


function equals(v1, v2) {
  const t1 = typeof v1;
  const t2 = typeof v2;

  if (t1 !== t2) {
    return false;
  }

  if (Array.isArray(v1)) {
    if (v1.length !== v2.length) {
      return false;
    }

    for (let i = 0; i < v1.length; i++) {
      if (!equals(v1[i], v2[i])) {
        return false;
      }
    }

    return true;
  } else if (t1 === 'object') {
    for (let key in v1) {
      if (v1.hasOwnProperty(key)) {
        if (!equals(v1[key], v2[key])) {
          return false;
        }
      }
    }

    for (let key in v2) {
      if (!v1.hasOwnProperty(key)) {
        return false;
      }
    }

    return true;
  }

  return v1 === v2;
}

function hashString(text) {
  let hash = 0;

  if (text.length == 0) {
    return hash;
  }

  for (let i = 0; i < text.length; i++) {
    let symbol = text.charCodeAt(i);
    hash = (hash << 5) - hash + symbol;
    hash = hash & hash;
  }

  return hash;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  formatDateAndTime,
  clone,
  extendObject,
  sanitizeScheme,
  getObjectProperty,
  setObjectProperty,
  rotateVector,
  rotatePointAroundCenter,
  enumerateConstants,
  domHasParentNode,
  domFindAncestorByClassUntil,
  forceDownload,
  equals,
  hashString
});

/***/ }),

/***/ 9996:
/***/ ((module) => {

"use strict";


var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),

/***/ 7837:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.attributeNames = exports.elementNames = void 0;
exports.elementNames = new Map([
    ["altglyph", "altGlyph"],
    ["altglyphdef", "altGlyphDef"],
    ["altglyphitem", "altGlyphItem"],
    ["animatecolor", "animateColor"],
    ["animatemotion", "animateMotion"],
    ["animatetransform", "animateTransform"],
    ["clippath", "clipPath"],
    ["feblend", "feBlend"],
    ["fecolormatrix", "feColorMatrix"],
    ["fecomponenttransfer", "feComponentTransfer"],
    ["fecomposite", "feComposite"],
    ["feconvolvematrix", "feConvolveMatrix"],
    ["fediffuselighting", "feDiffuseLighting"],
    ["fedisplacementmap", "feDisplacementMap"],
    ["fedistantlight", "feDistantLight"],
    ["fedropshadow", "feDropShadow"],
    ["feflood", "feFlood"],
    ["fefunca", "feFuncA"],
    ["fefuncb", "feFuncB"],
    ["fefuncg", "feFuncG"],
    ["fefuncr", "feFuncR"],
    ["fegaussianblur", "feGaussianBlur"],
    ["feimage", "feImage"],
    ["femerge", "feMerge"],
    ["femergenode", "feMergeNode"],
    ["femorphology", "feMorphology"],
    ["feoffset", "feOffset"],
    ["fepointlight", "fePointLight"],
    ["fespecularlighting", "feSpecularLighting"],
    ["fespotlight", "feSpotLight"],
    ["fetile", "feTile"],
    ["feturbulence", "feTurbulence"],
    ["foreignobject", "foreignObject"],
    ["glyphref", "glyphRef"],
    ["lineargradient", "linearGradient"],
    ["radialgradient", "radialGradient"],
    ["textpath", "textPath"],
]);
exports.attributeNames = new Map([
    ["definitionurl", "definitionURL"],
    ["attributename", "attributeName"],
    ["attributetype", "attributeType"],
    ["basefrequency", "baseFrequency"],
    ["baseprofile", "baseProfile"],
    ["calcmode", "calcMode"],
    ["clippathunits", "clipPathUnits"],
    ["diffuseconstant", "diffuseConstant"],
    ["edgemode", "edgeMode"],
    ["filterunits", "filterUnits"],
    ["glyphref", "glyphRef"],
    ["gradienttransform", "gradientTransform"],
    ["gradientunits", "gradientUnits"],
    ["kernelmatrix", "kernelMatrix"],
    ["kernelunitlength", "kernelUnitLength"],
    ["keypoints", "keyPoints"],
    ["keysplines", "keySplines"],
    ["keytimes", "keyTimes"],
    ["lengthadjust", "lengthAdjust"],
    ["limitingconeangle", "limitingConeAngle"],
    ["markerheight", "markerHeight"],
    ["markerunits", "markerUnits"],
    ["markerwidth", "markerWidth"],
    ["maskcontentunits", "maskContentUnits"],
    ["maskunits", "maskUnits"],
    ["numoctaves", "numOctaves"],
    ["pathlength", "pathLength"],
    ["patterncontentunits", "patternContentUnits"],
    ["patterntransform", "patternTransform"],
    ["patternunits", "patternUnits"],
    ["pointsatx", "pointsAtX"],
    ["pointsaty", "pointsAtY"],
    ["pointsatz", "pointsAtZ"],
    ["preservealpha", "preserveAlpha"],
    ["preserveaspectratio", "preserveAspectRatio"],
    ["primitiveunits", "primitiveUnits"],
    ["refx", "refX"],
    ["refy", "refY"],
    ["repeatcount", "repeatCount"],
    ["repeatdur", "repeatDur"],
    ["requiredextensions", "requiredExtensions"],
    ["requiredfeatures", "requiredFeatures"],
    ["specularconstant", "specularConstant"],
    ["specularexponent", "specularExponent"],
    ["spreadmethod", "spreadMethod"],
    ["startoffset", "startOffset"],
    ["stddeviation", "stdDeviation"],
    ["stitchtiles", "stitchTiles"],
    ["surfacescale", "surfaceScale"],
    ["systemlanguage", "systemLanguage"],
    ["tablevalues", "tableValues"],
    ["targetx", "targetX"],
    ["targety", "targetY"],
    ["textlength", "textLength"],
    ["viewbox", "viewBox"],
    ["viewtarget", "viewTarget"],
    ["xchannelselector", "xChannelSelector"],
    ["ychannelselector", "yChannelSelector"],
    ["zoomandpan", "zoomAndPan"],
]);


/***/ }),

/***/ 7220:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * Module dependencies
 */
var ElementType = __importStar(__webpack_require__(9960));
var entities_1 = __webpack_require__(5863);
/**
 * Mixed-case SVG and MathML tags & attributes
 * recognized by the HTML parser.
 *
 * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign
 */
var foreignNames_1 = __webpack_require__(7837);
var unencodedElements = new Set([
    "style",
    "script",
    "xmp",
    "iframe",
    "noembed",
    "noframes",
    "plaintext",
    "noscript",
]);
/**
 * Format attributes
 */
function formatAttributes(attributes, opts) {
    if (!attributes)
        return;
    return Object.keys(attributes)
        .map(function (key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
            /* Fix up mixed-case attribute names */
            key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
        }
        return key + "=\"" + (opts.decodeEntities !== false
            ? entities_1.encodeXML(value)
            : value.replace(/"/g, "&quot;")) + "\"";
    })
        .join(" ");
}
/**
 * Self-enclosing tags
 */
var singleTag = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
/**
 * Renders a DOM node or an array of DOM nodes to a string.
 *
 * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).
 *
 * @param node Node to be rendered.
 * @param options Changes serialization behavior
 */
function render(node, options) {
    if (options === void 0) { options = {}; }
    var nodes = "length" in node ? node : [node];
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
    }
    return output;
}
exports["default"] = render;
function renderNode(node, options) {
    switch (node.type) {
        case ElementType.Root:
            return render(node.children, options);
        case ElementType.Directive:
        case ElementType.Doctype:
            return renderDirective(node);
        case ElementType.Comment:
            return renderComment(node);
        case ElementType.CDATA:
            return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
            return renderTag(node, options);
        case ElementType.Text:
            return renderText(node, options);
    }
}
var foreignModeIntegrationPoints = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
var foreignElements = new Set(["svg", "math"]);
function renderTag(elem, opts) {
    var _a;
    // Handle SVG / MathML in HTML
    if (opts.xmlMode === "foreign") {
        /* Fix up mixed-case element names */
        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        /* Exit foreign mode at integration points */
        if (elem.parent &&
            foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign(__assign({}, opts), { xmlMode: false });
        }
    }
    if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
    }
    var tag = "<" + elem.name;
    var attribs = formatAttributes(elem.attribs, opts);
    if (attribs) {
        tag += " " + attribs;
    }
    if (elem.children.length === 0 &&
        (opts.xmlMode
            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
                opts.selfClosingTags !== false
            : // User explicitly asked for self-closing tags, even in HTML mode
                opts.selfClosingTags && singleTag.has(elem.name))) {
        if (!opts.xmlMode)
            tag += " ";
        tag += "/>";
    }
    else {
        tag += ">";
        if (elem.children.length > 0) {
            tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</" + elem.name + ">";
        }
    }
    return tag;
}
function renderDirective(elem) {
    return "<" + elem.data + ">";
}
function renderText(elem, opts) {
    var data = elem.data || "";
    // If entities weren't decoded, no need to encode them back
    if (opts.decodeEntities !== false &&
        !(!opts.xmlMode &&
            elem.parent &&
            unencodedElements.has(elem.parent.name))) {
        data = entities_1.encodeXML(data);
    }
    return data;
}
function renderCdata(elem) {
    return "<![CDATA[" + elem.children[0].data + "]]>";
}
function renderComment(elem) {
    return "<!--" + elem.data + "-->";
}


/***/ }),

/***/ 9960:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;
/** Types of elements found in htmlparser2's DOM */
var ElementType;
(function (ElementType) {
    /** Type for the root element of a document */
    ElementType["Root"] = "root";
    /** Type for Text */
    ElementType["Text"] = "text";
    /** Type for <? ... ?> */
    ElementType["Directive"] = "directive";
    /** Type for <!-- ... --> */
    ElementType["Comment"] = "comment";
    /** Type for <script> tags */
    ElementType["Script"] = "script";
    /** Type for <style> tags */
    ElementType["Style"] = "style";
    /** Type for Any tag */
    ElementType["Tag"] = "tag";
    /** Type for <![CDATA[ ... ]]> */
    ElementType["CDATA"] = "cdata";
    /** Type for <!doctype ...> */
    ElementType["Doctype"] = "doctype";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
/**
 * Tests whether an element is a tag or not.
 *
 * @param elem Element to test
 */
function isTag(elem) {
    return (elem.type === ElementType.Tag ||
        elem.type === ElementType.Script ||
        elem.type === ElementType.Style);
}
exports.isTag = isTag;
// Exports for backwards compatibility
/** Type for the root element of a document */
exports.Root = ElementType.Root;
/** Type for Text */
exports.Text = ElementType.Text;
/** Type for <? ... ?> */
exports.Directive = ElementType.Directive;
/** Type for <!-- ... --> */
exports.Comment = ElementType.Comment;
/** Type for <script> tags */
exports.Script = ElementType.Script;
/** Type for <style> tags */
exports.Style = ElementType.Style;
/** Type for Any tag */
exports.Tag = ElementType.Tag;
/** Type for <![CDATA[ ... ]]> */
exports.CDATA = ElementType.CDATA;
/** Type for <!doctype ...> */
exports.Doctype = ElementType.Doctype;


/***/ }),

/***/ 7915:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DomHandler = void 0;
var domelementtype_1 = __webpack_require__(9960);
var node_1 = __webpack_require__(7790);
__exportStar(__webpack_require__(7790), exports);
var reWhitespace = /\s+/g;
// Default options
var defaultOpts = {
    normalizeWhitespace: false,
    withStartIndices: false,
    withEndIndices: false,
    xmlMode: false,
};
var DomHandler = /** @class */ (function () {
    /**
     * @param callback Called once parsing has completed.
     * @param options Settings for the handler.
     * @param elementCB Callback whenever a tag is closed.
     */
    function DomHandler(callback, options, elementCB) {
        /** The elements of the DOM */
        this.dom = [];
        /** The root element for the DOM */
        this.root = new node_1.Document(this.dom);
        /** Indicated whether parsing has been completed. */
        this.done = false;
        /** Stack of open tags. */
        this.tagStack = [this.root];
        /** A data node that is still being written to. */
        this.lastNode = null;
        /** Reference to the parser instance. Used for location information. */
        this.parser = null;
        // Make it possible to skip arguments, for backwards-compatibility
        if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
        }
        if (typeof callback === "object") {
            options = callback;
            callback = undefined;
        }
        this.callback = callback !== null && callback !== void 0 ? callback : null;
        this.options = options !== null && options !== void 0 ? options : defaultOpts;
        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
    }
    DomHandler.prototype.onparserinit = function (parser) {
        this.parser = parser;
    };
    // Resets the handler back to starting state
    DomHandler.prototype.onreset = function () {
        this.dom = [];
        this.root = new node_1.Document(this.dom);
        this.done = false;
        this.tagStack = [this.root];
        this.lastNode = null;
        this.parser = null;
    };
    // Signals the handler that parsing is done
    DomHandler.prototype.onend = function () {
        if (this.done)
            return;
        this.done = true;
        this.parser = null;
        this.handleCallback(null);
    };
    DomHandler.prototype.onerror = function (error) {
        this.handleCallback(error);
    };
    DomHandler.prototype.onclosetag = function () {
        this.lastNode = null;
        var elem = this.tagStack.pop();
        if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
        }
        if (this.elementCB)
            this.elementCB(elem);
    };
    DomHandler.prototype.onopentag = function (name, attribs) {
        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
        var element = new node_1.Element(name, attribs, undefined, type);
        this.addNode(element);
        this.tagStack.push(element);
    };
    DomHandler.prototype.ontext = function (data) {
        var normalizeWhitespace = this.options.normalizeWhitespace;
        var lastNode = this.lastNode;
        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            if (normalizeWhitespace) {
                lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
            }
            else {
                lastNode.data += data;
            }
            if (this.options.withEndIndices) {
                lastNode.endIndex = this.parser.endIndex;
            }
        }
        else {
            if (normalizeWhitespace) {
                data = data.replace(reWhitespace, " ");
            }
            var node = new node_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
        }
    };
    DomHandler.prototype.oncomment = function (data) {
        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
        }
        var node = new node_1.Comment(data);
        this.addNode(node);
        this.lastNode = node;
    };
    DomHandler.prototype.oncommentend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.oncdatastart = function () {
        var text = new node_1.Text("");
        var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
        this.addNode(node);
        text.parent = node;
        this.lastNode = text;
    };
    DomHandler.prototype.oncdataend = function () {
        this.lastNode = null;
    };
    DomHandler.prototype.onprocessinginstruction = function (name, data) {
        var node = new node_1.ProcessingInstruction(name, data);
        this.addNode(node);
    };
    DomHandler.prototype.handleCallback = function (error) {
        if (typeof this.callback === "function") {
            this.callback(error, this.dom);
        }
        else if (error) {
            throw error;
        }
    };
    DomHandler.prototype.addNode = function (node) {
        var parent = this.tagStack[this.tagStack.length - 1];
        var previousSibling = parent.children[parent.children.length - 1];
        if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
        }
        if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
        }
        parent.children.push(node);
        if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
        }
        node.parent = parent;
        this.lastNode = null;
    };
    return DomHandler;
}());
exports.DomHandler = DomHandler;
exports["default"] = DomHandler;


/***/ }),

/***/ 7790:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;
var domelementtype_1 = __webpack_require__(9960);
var nodeTypes = new Map([
    [domelementtype_1.ElementType.Tag, 1],
    [domelementtype_1.ElementType.Script, 1],
    [domelementtype_1.ElementType.Style, 1],
    [domelementtype_1.ElementType.Directive, 1],
    [domelementtype_1.ElementType.Text, 3],
    [domelementtype_1.ElementType.CDATA, 4],
    [domelementtype_1.ElementType.Comment, 8],
    [domelementtype_1.ElementType.Root, 9],
]);
/**
 * This object will be used as the prototype for Nodes when creating a
 * DOM-Level-1-compliant structure.
 */
var Node = /** @class */ (function () {
    /**
     *
     * @param type The type of the node.
     */
    function Node(type) {
        this.type = type;
        /** Parent of the node */
        this.parent = null;
        /** Previous sibling */
        this.prev = null;
        /** Next sibling */
        this.next = null;
        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */
        this.startIndex = null;
        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */
        this.endIndex = null;
    }
    Object.defineProperty(Node.prototype, "nodeType", {
        // Read-only aliases
        get: function () {
            var _a;
            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "parentNode", {
        // Read-write aliases for properties
        get: function () {
            return this.parent;
        },
        set: function (parent) {
            this.parent = parent;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        get: function () {
            return this.prev;
        },
        set: function (prev) {
            this.prev = prev;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        get: function () {
            return this.next;
        },
        set: function (next) {
            this.next = next;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Clone this node, and optionally its children.
     *
     * @param recursive Clone child nodes as well.
     * @returns A clone of the node.
     */
    Node.prototype.cloneNode = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        return cloneNode(this, recursive);
    };
    return Node;
}());
exports.Node = Node;
/**
 * A node that contains some data.
 */
var DataNode = /** @class */ (function (_super) {
    __extends(DataNode, _super);
    /**
     * @param type The type of the node
     * @param data The content of the data node
     */
    function DataNode(type, data) {
        var _this = _super.call(this, type) || this;
        _this.data = data;
        return _this;
    }
    Object.defineProperty(DataNode.prototype, "nodeValue", {
        get: function () {
            return this.data;
        },
        set: function (data) {
            this.data = data;
        },
        enumerable: false,
        configurable: true
    });
    return DataNode;
}(Node));
exports.DataNode = DataNode;
/**
 * Text within the document.
 */
var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text(data) {
        return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
    }
    return Text;
}(DataNode));
exports.Text = Text;
/**
 * Comments within the document.
 */
var Comment = /** @class */ (function (_super) {
    __extends(Comment, _super);
    function Comment(data) {
        return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
    }
    return Comment;
}(DataNode));
exports.Comment = Comment;
/**
 * Processing instructions, including doc types.
 */
var ProcessingInstruction = /** @class */ (function (_super) {
    __extends(ProcessingInstruction, _super);
    function ProcessingInstruction(name, data) {
        var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
        _this.name = name;
        return _this;
    }
    return ProcessingInstruction;
}(DataNode));
exports.ProcessingInstruction = ProcessingInstruction;
/**
 * A `Node` that can have children.
 */
var NodeWithChildren = /** @class */ (function (_super) {
    __extends(NodeWithChildren, _super);
    /**
     * @param type Type of the node.
     * @param children Children of the node. Only certain node types can have children.
     */
    function NodeWithChildren(type, children) {
        var _this = _super.call(this, type) || this;
        _this.children = children;
        return _this;
    }
    Object.defineProperty(NodeWithChildren.prototype, "firstChild", {
        // Aliases
        get: function () {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "lastChild", {
        get: function () {
            return this.children.length > 0
                ? this.children[this.children.length - 1]
                : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(NodeWithChildren.prototype, "childNodes", {
        get: function () {
            return this.children;
        },
        set: function (children) {
            this.children = children;
        },
        enumerable: false,
        configurable: true
    });
    return NodeWithChildren;
}(Node));
exports.NodeWithChildren = NodeWithChildren;
/**
 * The root node of the document.
 */
var Document = /** @class */ (function (_super) {
    __extends(Document, _super);
    function Document(children) {
        return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
    }
    return Document;
}(NodeWithChildren));
exports.Document = Document;
/**
 * An element within the DOM.
 */
var Element = /** @class */ (function (_super) {
    __extends(Element, _super);
    /**
     * @param name Name of the tag, eg. `div`, `span`.
     * @param attribs Object mapping attribute names to attribute values.
     * @param children Children of the node.
     */
    function Element(name, attribs, children, type) {
        if (children === void 0) { children = []; }
        if (type === void 0) { type = name === "script"
            ? domelementtype_1.ElementType.Script
            : name === "style"
                ? domelementtype_1.ElementType.Style
                : domelementtype_1.ElementType.Tag; }
        var _this = _super.call(this, type, children) || this;
        _this.name = name;
        _this.attribs = attribs;
        return _this;
    }
    Object.defineProperty(Element.prototype, "tagName", {
        // DOM Level 1 aliases
        get: function () {
            return this.name;
        },
        set: function (name) {
            this.name = name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Element.prototype, "attributes", {
        get: function () {
            var _this = this;
            return Object.keys(this.attribs).map(function (name) {
                var _a, _b;
                return ({
                    name: name,
                    value: _this.attribs[name],
                    namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                    prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name],
                });
            });
        },
        enumerable: false,
        configurable: true
    });
    return Element;
}(NodeWithChildren));
exports.Element = Element;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `Element`, `false` otherwise.
 */
function isTag(node) {
    return (0, domelementtype_1.isTag)(node);
}
exports.isTag = isTag;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `CDATA`, `false` otherwise.
 */
function isCDATA(node) {
    return node.type === domelementtype_1.ElementType.CDATA;
}
exports.isCDATA = isCDATA;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Text`, `false` otherwise.
 */
function isText(node) {
    return node.type === domelementtype_1.ElementType.Text;
}
exports.isText = isText;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `Comment`, `false` otherwise.
 */
function isComment(node) {
    return node.type === domelementtype_1.ElementType.Comment;
}
exports.isComment = isComment;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDirective(node) {
    return node.type === domelementtype_1.ElementType.Directive;
}
exports.isDirective = isDirective;
/**
 * @param node Node to check.
 * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.
 */
function isDocument(node) {
    return node.type === domelementtype_1.ElementType.Root;
}
exports.isDocument = isDocument;
/**
 * @param node Node to check.
 * @returns `true` if the node is a `NodeWithChildren` (has children), `false` otherwise.
 */
function hasChildren(node) {
    return Object.prototype.hasOwnProperty.call(node, "children");
}
exports.hasChildren = hasChildren;
/**
 * Clone a node, and optionally its children.
 *
 * @param recursive Clone child nodes as well.
 * @returns A clone of the node.
 */
function cloneNode(node, recursive) {
    if (recursive === void 0) { recursive = false; }
    var result;
    if (isText(node)) {
        result = new Text(node.data);
    }
    else if (isComment(node)) {
        result = new Comment(node.data);
    }
    else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function (child) { return (child.parent = clone_1); });
        if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
    }
    else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
        children.forEach(function (child) { return (child.parent = clone_2); });
        result = clone_2;
    }
    else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function (child) { return (child.parent = clone_3); });
        if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
    }
    else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
    }
    else {
        throw new Error("Not implemented yet: " + node.type);
    }
    result.startIndex = node.startIndex;
    result.endIndex = node.endIndex;
    return result;
}
exports.cloneNode = cloneNode;
function cloneChildren(childs) {
    var children = childs.map(function (child) { return cloneNode(child, true); });
    for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
    }
    return children;
}


/***/ }),

/***/ 6996:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFeed = void 0;
var stringify_1 = __webpack_require__(3346);
var legacy_1 = __webpack_require__(3905);
/**
 * Get the feed object from the root of a DOM tree.
 *
 * @param doc - The DOM to to extract the feed from.
 * @returns The feed.
 */
function getFeed(doc) {
    var feedRoot = getOneElement(isValidFeed, doc);
    return !feedRoot
        ? null
        : feedRoot.name === "feed"
            ? getAtomFeed(feedRoot)
            : getRssFeed(feedRoot);
}
exports.getFeed = getFeed;
/**
 * Parse an Atom feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getAtomFeed(feedRoot) {
    var _a;
    var childs = feedRoot.children;
    var feed = {
        type: "atom",
        items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function (item) {
            var _a;
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            var href = (_a = getOneElement("link", children)) === null || _a === void 0 ? void 0 : _a.attribs.href;
            if (href) {
                entry.link = href;
            }
            var description = fetch("summary", children) || fetch("content", children);
            if (description) {
                entry.description = description;
            }
            var pubDate = fetch("updated", children);
            if (pubDate) {
                entry.pubDate = new Date(pubDate);
            }
            return entry;
        }),
    };
    addConditionally(feed, "id", "id", childs);
    addConditionally(feed, "title", "title", childs);
    var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs.href;
    if (href) {
        feed.link = href;
    }
    addConditionally(feed, "description", "subtitle", childs);
    var updated = fetch("updated", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "email", childs, true);
    return feed;
}
/**
 * Parse a RSS feed.
 *
 * @param feedRoot The root of the feed.
 * @returns The parsed feed.
 */
function getRssFeed(feedRoot) {
    var _a, _b;
    var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
    var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function (item) {
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate = fetch("pubDate", children);
            if (pubDate)
                entry.pubDate = new Date(pubDate);
            return entry;
        }),
    };
    addConditionally(feed, "title", "title", childs);
    addConditionally(feed, "link", "link", childs);
    addConditionally(feed, "description", "description", childs);
    var updated = fetch("lastBuildDate", childs);
    if (updated) {
        feed.updated = new Date(updated);
    }
    addConditionally(feed, "author", "managingEditor", childs, true);
    return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
    "fileSize",
    "bitrate",
    "framerate",
    "samplingrate",
    "channels",
    "duration",
    "height",
    "width",
];
/**
 * Get all media elements of a feed item.
 *
 * @param where Nodes to search in.
 * @returns Media elements.
 */
function getMediaElements(where) {
    return (0, legacy_1.getElementsByTagName)("media:content", where).map(function (elem) {
        var attribs = elem.attribs;
        var media = {
            medium: attribs.medium,
            isDefault: !!attribs.isDefault,
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
                media[attrib] = attribs[attrib];
            }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
            var attrib = MEDIA_KEYS_INT_1[_a];
            if (attribs[attrib]) {
                media[attrib] = parseInt(attribs[attrib], 10);
            }
        }
        if (attribs.expression) {
            media.expression =
                attribs.expression;
        }
        return media;
    });
}
/**
 * Get one element by tag name.
 *
 * @param tagName Tag name to look for
 * @param node Node to search in
 * @returns The element or null
 */
function getOneElement(tagName, node) {
    return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
}
/**
 * Get the text content of an element with a certain tag name.
 *
 * @param tagName Tag name to look for.
 * @param where  Node to search in.
 * @param recurse Whether to recurse into child nodes.
 * @returns The text content of the element.
 */
function fetch(tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
}
/**
 * Adds a property to an object if it has a value.
 *
 * @param obj Object to be extended
 * @param prop Property name
 * @param tagName Tag name that contains the conditionally added property
 * @param where Element to search for the property
 * @param recurse Whether to recurse into child nodes.
 */
function addConditionally(obj, prop, tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    var val = fetch(tagName, where, recurse);
    if (val)
        obj[prop] = val;
}
/**
 * Checks if an element is a feed root node.
 *
 * @param value The name of the element to check.
 * @returns Whether an element is a feed root node.
 */
function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
}


/***/ }),

/***/ 4975:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;
var domhandler_1 = __webpack_require__(7915);
/**
 * Given an array of nodes, remove any member that is contained by another.
 *
 * @param nodes Nodes to filter.
 * @returns Remaining nodes that aren't subtrees of each other.
 */
function removeSubsets(nodes) {
    var idx = nodes.length;
    /*
     * Check if each node (or one of its ancestors) is already contained in the
     * array.
     */
    while (--idx >= 0) {
        var node = nodes[idx];
        /*
         * Remove the node if it is not unique.
         * We are going through the array from the end, so we only
         * have to check nodes that preceed the node under consideration in the array.
         */
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
                nodes.splice(idx, 1);
                break;
            }
        }
    }
    return nodes;
}
exports.removeSubsets = removeSubsets;
/**
 * Compare the position of one node against another node in any other document.
 * The return value is a bitmask with the following values:
 *
 * Document order:
 * > There is an ordering, document order, defined on all the nodes in the
 * > document corresponding to the order in which the first character of the
 * > XML representation of each node occurs in the XML representation of the
 * > document after expansion of general entities. Thus, the document element
 * > node will be the first node. Element nodes occur before their children.
 * > Thus, document order orders element nodes in order of the occurrence of
 * > their start-tag in the XML (after expansion of entities). The attribute
 * > nodes of an element occur after the element and before its children. The
 * > relative order of attribute nodes is implementation-dependent./
 *
 * Source:
 * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order
 *
 * @param nodeA The first node to use in the comparison
 * @param nodeB The second node to use in the comparison
 * @returns A bitmask describing the input nodes' relative position.
 *
 * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for
 * a description of these values.
 */
function compareDocumentPosition(nodeA, nodeB) {
    var aParents = [];
    var bParents = [];
    if (nodeA === nodeB) {
        return 0;
    }
    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
    while (current) {
        aParents.unshift(current);
        current = current.parent;
    }
    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
    while (current) {
        bParents.unshift(current);
        current = current.parent;
    }
    var maxIdx = Math.min(aParents.length, bParents.length);
    var idx = 0;
    while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
    }
    if (idx === 0) {
        return 1 /* DISCONNECTED */;
    }
    var sharedParent = aParents[idx - 1];
    var siblings = sharedParent.children;
    var aSibling = aParents[idx];
    var bSibling = bParents[idx];
    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;
        }
        return 4 /* FOLLOWING */;
    }
    if (sharedParent === nodeA) {
        return 2 /* PRECEDING */ | 8 /* CONTAINS */;
    }
    return 2 /* PRECEDING */;
}
exports.compareDocumentPosition = compareDocumentPosition;
/**
 * Sort an array of nodes based on their relative position in the document and
 * remove any duplicate nodes. If the array contains nodes that do not belong
 * to the same document, sort order is unspecified.
 *
 * @param nodes Array of DOM nodes.
 * @returns Collection of unique nodes, sorted in document order.
 */
function uniqueSort(nodes) {
    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });
    nodes.sort(function (a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & 2 /* PRECEDING */) {
            return -1;
        }
        else if (relative & 4 /* FOLLOWING */) {
            return 1;
        }
        return 0;
    });
    return nodes;
}
exports.uniqueSort = uniqueSort;


/***/ }),

/***/ 9432:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;
__exportStar(__webpack_require__(3346), exports);
__exportStar(__webpack_require__(5010), exports);
__exportStar(__webpack_require__(6765), exports);
__exportStar(__webpack_require__(8043), exports);
__exportStar(__webpack_require__(3905), exports);
__exportStar(__webpack_require__(4975), exports);
__exportStar(__webpack_require__(6996), exports);
/** @deprecated Use these methods from `domhandler` directly. */
var domhandler_1 = __webpack_require__(7915);
Object.defineProperty(exports, "isTag", ({ enumerable: true, get: function () { return domhandler_1.isTag; } }));
Object.defineProperty(exports, "isCDATA", ({ enumerable: true, get: function () { return domhandler_1.isCDATA; } }));
Object.defineProperty(exports, "isText", ({ enumerable: true, get: function () { return domhandler_1.isText; } }));
Object.defineProperty(exports, "isComment", ({ enumerable: true, get: function () { return domhandler_1.isComment; } }));
Object.defineProperty(exports, "isDocument", ({ enumerable: true, get: function () { return domhandler_1.isDocument; } }));
Object.defineProperty(exports, "hasChildren", ({ enumerable: true, get: function () { return domhandler_1.hasChildren; } }));


/***/ }),

/***/ 3905:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;
var domhandler_1 = __webpack_require__(7915);
var querying_1 = __webpack_require__(8043);
var Checks = {
    tag_name: function (name) {
        if (typeof name === "function") {
            return function (elem) { return (0, domhandler_1.isTag)(elem) && name(elem.name); };
        }
        else if (name === "*") {
            return domhandler_1.isTag;
        }
        return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.name === name; };
    },
    tag_type: function (type) {
        if (typeof type === "function") {
            return function (elem) { return type(elem.type); };
        }
        return function (elem) { return elem.type === type; };
    },
    tag_contains: function (data) {
        if (typeof data === "function") {
            return function (elem) { return (0, domhandler_1.isText)(elem) && data(elem.data); };
        }
        return function (elem) { return (0, domhandler_1.isText)(elem) && elem.data === data; };
    },
};
/**
 * @param attrib Attribute to check.
 * @param value Attribute value to look for.
 * @returns A function to check whether the a node has an attribute with a particular value.
 */
function getAttribCheck(attrib, value) {
    if (typeof value === "function") {
        return function (elem) { return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]); };
    }
    return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value; };
}
/**
 * @param a First function to combine.
 * @param b Second function to combine.
 * @returns A function taking a node and returning `true` if either
 * of the input functions returns `true` for the node.
 */
function combineFuncs(a, b) {
    return function (elem) { return a(elem) || b(elem); };
}
/**
 * @param options An object describing nodes to look for.
 * @returns A function executing all checks in `options` and returning `true`
 * if any of them match a node.
 */
function compileTest(options) {
    var funcs = Object.keys(options).map(function (key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key)
            ? Checks[key](value)
            : getAttribCheck(key, value);
    });
    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
/**
 * @param options An object describing nodes to look for.
 * @param node The element to test.
 * @returns Whether the element matches the description in `options`.
 */
function testElement(options, node) {
    var test = compileTest(options);
    return test ? test(node) : true;
}
exports.testElement = testElement;
/**
 * @param options An object describing nodes to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes that match `options`.
 */
function getElements(options, nodes, recurse, limit) {
    if (limit === void 0) { limit = Infinity; }
    var test = compileTest(options);
    return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
}
exports.getElements = getElements;
/**
 * @param id The unique ID attribute value to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @returns The node with the supplied ID.
 */
function getElementById(id, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    if (!Array.isArray(nodes))
        nodes = [nodes];
    return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
}
exports.getElementById = getElementById;
/**
 * @param tagName Tag name to search for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `tagName`.
 */
function getElementsByTagName(tagName, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
}
exports.getElementsByTagName = getElementsByTagName;
/**
 * @param type Element type to look for.
 * @param nodes Nodes to search through.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes with the supplied `type`.
 */
function getElementsByTagType(type, nodes, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit);
}
exports.getElementsByTagType = getElementsByTagType;


/***/ }),

/***/ 6765:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;
/**
 * Remove an element from the dom
 *
 * @param elem The element to be removed
 */
function removeElement(elem) {
    if (elem.prev)
        elem.prev.next = elem.next;
    if (elem.next)
        elem.next.prev = elem.prev;
    if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
    }
}
exports.removeElement = removeElement;
/**
 * Replace an element in the dom
 *
 * @param elem The element to be replaced
 * @param replacement The element to be added
 */
function replaceElement(elem, replacement) {
    var prev = (replacement.prev = elem.prev);
    if (prev) {
        prev.next = replacement;
    }
    var next = (replacement.next = elem.next);
    if (next) {
        next.prev = replacement;
    }
    var parent = (replacement.parent = elem.parent);
    if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
    }
}
exports.replaceElement = replaceElement;
/**
 * Append a child to an element.
 *
 * @param elem The element to append to.
 * @param child The element to be added as a child.
 */
function appendChild(elem, child) {
    removeElement(child);
    child.next = null;
    child.parent = elem;
    if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
    }
    else {
        child.prev = null;
    }
}
exports.appendChild = appendChild;
/**
 * Append an element after another.
 *
 * @param elem The element to append after.
 * @param next The element be added.
 */
function append(elem, next) {
    removeElement(next);
    var parent = elem.parent;
    var currNext = elem.next;
    next.next = currNext;
    next.prev = elem;
    elem.next = next;
    next.parent = parent;
    if (currNext) {
        currNext.prev = next;
        if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
    }
    else if (parent) {
        parent.children.push(next);
    }
}
exports.append = append;
/**
 * Prepend a child to an element.
 *
 * @param elem The element to prepend before.
 * @param child The element to be added as a child.
 */
function prependChild(elem, child) {
    removeElement(child);
    child.parent = elem;
    child.prev = null;
    if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
    }
    else {
        child.next = null;
    }
}
exports.prependChild = prependChild;
/**
 * Prepend an element before another.
 *
 * @param elem The element to prepend before.
 * @param prev The element be added.
 */
function prepend(elem, prev) {
    removeElement(prev);
    var parent = elem.parent;
    if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
    }
    if (elem.prev) {
        elem.prev.next = prev;
    }
    prev.parent = parent;
    prev.prev = elem.prev;
    prev.next = elem;
    elem.prev = prev;
}
exports.prepend = prepend;


/***/ }),

/***/ 8043:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;
var domhandler_1 = __webpack_require__(7915);
/**
 * Search a node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param node Node to search. Will be included in the result set if it matches.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function filter(test, node, recurse, limit) {
    if (recurse === void 0) { recurse = true; }
    if (limit === void 0) { limit = Infinity; }
    if (!Array.isArray(node))
        node = [node];
    return find(test, node, recurse, limit);
}
exports.filter = filter;
/**
 * Search an array of node and its children for nodes passing a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @param limit Maximum number of nodes to return.
 * @returns All nodes passing `test`.
 */
function find(test, nodes, recurse, limit) {
    var result = [];
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
                break;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
            var children = find(test, elem.children, recurse, limit);
            result.push.apply(result, children);
            limit -= children.length;
            if (limit <= 0)
                break;
        }
    }
    return result;
}
exports.find = find;
/**
 * Finds the first element inside of an array that matches a test function.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns The first node in the array that passes `test`.
 */
function findOneChild(test, nodes) {
    return nodes.find(test);
}
exports.findOneChild = findOneChild;
/**
 * Finds one element in a tree that passes a test.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @param recurse Also consider child nodes.
 * @returns The first child node that passes `test`.
 */
function findOne(test, nodes, recurse) {
    if (recurse === void 0) { recurse = true; }
    var elem = null;
    for (var i = 0; i < nodes.length && !elem; i++) {
        var checked = nodes[i];
        if (!(0, domhandler_1.isTag)(checked)) {
            continue;
        }
        else if (test(checked)) {
            elem = checked;
        }
        else if (recurse && checked.children.length > 0) {
            elem = findOne(test, checked.children);
        }
    }
    return elem;
}
exports.findOne = findOne;
/**
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns Whether a tree of nodes contains at least one node passing a test.
 */
function existsOne(test, nodes) {
    return nodes.some(function (checked) {
        return (0, domhandler_1.isTag)(checked) &&
            (test(checked) ||
                (checked.children.length > 0 &&
                    existsOne(test, checked.children)));
    });
}
exports.existsOne = existsOne;
/**
 * Search and array of nodes and its children for nodes passing a test function.
 *
 * Same as `find`, only with less options, leading to reduced complexity.
 *
 * @param test Function to test nodes on.
 * @param nodes Array of nodes to search.
 * @returns All nodes passing `test`.
 */
function findAll(test, nodes) {
    var _a;
    var result = [];
    var stack = nodes.filter(domhandler_1.isTag);
    var elem;
    while ((elem = stack.shift())) {
        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
        if (children && children.length > 0) {
            stack.unshift.apply(stack, children);
        }
        if (test(elem))
            result.push(elem);
    }
    return result;
}
exports.findAll = findAll;


/***/ }),

/***/ 3346:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;
var domhandler_1 = __webpack_require__(7915);
var dom_serializer_1 = __importDefault(__webpack_require__(7220));
var domelementtype_1 = __webpack_require__(9960);
/**
 * @param node Node to get the outer HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s outer HTML.
 */
function getOuterHTML(node, options) {
    return (0, dom_serializer_1.default)(node, options);
}
exports.getOuterHTML = getOuterHTML;
/**
 * @param node Node to get the inner HTML of.
 * @param options Options for serialization.
 * @deprecated Use the `dom-serializer` module directly.
 * @returns `node`'s inner HTML.
 */
function getInnerHTML(node, options) {
    return (0, domhandler_1.hasChildren)(node)
        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join("")
        : "";
}
exports.getInnerHTML = getInnerHTML;
/**
 * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags.
 *
 * @deprecated Use `textContent` instead.
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 */
function getText(node) {
    if (Array.isArray(node))
        return node.map(getText).join("");
    if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
    if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
    if ((0, domhandler_1.isText)(node))
        return node.data;
    return "";
}
exports.getText = getText;
/**
 * Get a node's text content.
 *
 * @param node Node to get the text content of.
 * @returns `node`'s text content.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}
 */
function textContent(node) {
    if (Array.isArray(node))
        return node.map(textContent).join("");
    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
    }
    if ((0, domhandler_1.isText)(node))
        return node.data;
    return "";
}
exports.textContent = textContent;
/**
 * Get a node's inner text.
 *
 * @param node Node to get the inner text of.
 * @returns `node`'s inner text.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}
 */
function innerText(node) {
    if (Array.isArray(node))
        return node.map(innerText).join("");
    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
    }
    if ((0, domhandler_1.isText)(node))
        return node.data;
    return "";
}
exports.innerText = innerText;


/***/ }),

/***/ 5010:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;
var domhandler_1 = __webpack_require__(7915);
var emptyArray = [];
/**
 * Get a node's children.
 *
 * @param elem Node to get the children of.
 * @returns `elem`'s children, or an empty array.
 */
function getChildren(elem) {
    var _a;
    return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
}
exports.getChildren = getChildren;
/**
 * Get a node's parent.
 *
 * @param elem Node to get the parent of.
 * @returns `elem`'s parent node.
 */
function getParent(elem) {
    return elem.parent || null;
}
exports.getParent = getParent;
/**
 * Gets an elements siblings, including the element itself.
 *
 * Attempts to get the children through the element's parent first.
 * If we don't have a parent (the element is a root node),
 * we walk the element's `prev` & `next` to get all remaining nodes.
 *
 * @param elem Element to get the siblings of.
 * @returns `elem`'s siblings.
 */
function getSiblings(elem) {
    var _a, _b;
    var parent = getParent(elem);
    if (parent != null)
        return getChildren(parent);
    var siblings = [elem];
    var prev = elem.prev, next = elem.next;
    while (prev != null) {
        siblings.unshift(prev);
        (_a = prev, prev = _a.prev);
    }
    while (next != null) {
        siblings.push(next);
        (_b = next, next = _b.next);
    }
    return siblings;
}
exports.getSiblings = getSiblings;
/**
 * Gets an attribute from an element.
 *
 * @param elem Element to check.
 * @param name Attribute name to retrieve.
 * @returns The element's attribute value, or `undefined`.
 */
function getAttributeValue(elem, name) {
    var _a;
    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
}
exports.getAttributeValue = getAttributeValue;
/**
 * Checks whether an element has an attribute.
 *
 * @param elem Element to check.
 * @param name Attribute name to look for.
 * @returns Returns whether `elem` has the attribute `name`.
 */
function hasAttrib(elem, name) {
    return (elem.attribs != null &&
        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
        elem.attribs[name] != null);
}
exports.hasAttrib = hasAttrib;
/**
 * Get the tag name of an element.
 *
 * @param elem The element to get the name for.
 * @returns The tag name of `elem`.
 */
function getName(elem) {
    return elem.name;
}
exports.getName = getName;
/**
 * Returns the next element sibling of a node.
 *
 * @param elem The element to get the next sibling of.
 * @returns `elem`'s next sibling that is a tag.
 */
function nextElementSibling(elem) {
    var _a;
    var next = elem.next;
    while (next !== null && !(0, domhandler_1.isTag)(next))
        (_a = next, next = _a.next);
    return next;
}
exports.nextElementSibling = nextElementSibling;
/**
 * Returns the previous element sibling of a node.
 *
 * @param elem The element to get the previous sibling of.
 * @returns `elem`'s previous sibling that is a tag.
 */
function prevElementSibling(elem) {
    var _a;
    var prev = elem.prev;
    while (prev !== null && !(0, domhandler_1.isTag)(prev))
        (_a = prev, prev = _a.prev);
    return prev;
}
exports.prevElementSibling = prevElementSibling;


/***/ }),

/***/ 4076:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
var entities_json_1 = __importDefault(__webpack_require__(9323));
var legacy_json_1 = __importDefault(__webpack_require__(9591));
var xml_json_1 = __importDefault(__webpack_require__(2586));
var decode_codepoint_1 = __importDefault(__webpack_require__(26));
var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
exports.decodeXML = getStrictDecoder(xml_json_1.default);
exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
function getStrictDecoder(map) {
    var replace = getReplacer(map);
    return function (str) { return String(str).replace(strictEntityRe, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
exports.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    // TODO consider creating a merged map
    return function (str) { return String(str).replace(re, replacer); };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        return map[str.slice(1, -1)] || str;
    };
}


/***/ }),

/***/ 26:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var decode_json_1 = __importDefault(__webpack_require__(3600));
// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
var fromCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.fromCodePoint ||
    function (codePoint) {
        var output = "";
        if (codePoint > 0xffff) {
            codePoint -= 0x10000;
            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
            codePoint = 0xdc00 | (codePoint & 0x3ff);
        }
        output += String.fromCharCode(codePoint);
        return output;
    };
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint(codePoint);
}
exports["default"] = decodeCodePoint;


/***/ }),

/***/ 7322:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;
var xml_json_1 = __importDefault(__webpack_require__(2586));
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = __importDefault(__webpack_require__(9323));
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
/**
 * Encodes all entities and non-ASCII characters in the input.
 *
 * This includes characters that are valid ASCII characters in HTML documents.
 * For example `#` will be encoded as `&num;`. To get a more compact output,
 * consider using the `encodeNonAsciiHTML` function.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
exports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
            // Add value to single array
            single.push("\\" + k);
        }
        else {
            // Add value to multiple array
            multiple.push(k);
        }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;
        while (end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
        }
        var count = 1 + end - start;
        // We want to replace at least three characters
        if (count < 3)
            continue;
        single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
// /[^\0-\x7F]/gu
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
var getCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null
    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        function (str) { return str.codePointAt(0); }
    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function (c) {
            return (c.charCodeAt(0) - 0xd800) * 0x400 +
                c.charCodeAt(1) -
                0xdc00 +
                0x10000;
        };
function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
        .toString(16)
        .toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reNonASCII, singleCharReplacer);
    };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
function escape(data) {
    return data.replace(reEscapeChars, singleCharReplacer);
}
exports.escape = escape;
/**
 * Encodes all characters not valid in XML documents using numeric hexadecimal
 * reference (eg. `&#xfc;`).
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
}
exports.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(obj) {
    return function (data) {
        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });
    };
}


/***/ }),

/***/ 5863:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
var decode_1 = __webpack_require__(4076);
var encode_1 = __webpack_require__(7322);
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeXML` or `decodeHTML` directly.
 */
function decode(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
 */
function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
 */
function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode;
var encode_2 = __webpack_require__(7322);
Object.defineProperty(exports, "encodeXML", ({ enumerable: true, get: function () { return encode_2.encodeXML; } }));
Object.defineProperty(exports, "encodeHTML", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));
Object.defineProperty(exports, "encodeNonAsciiHTML", ({ enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } }));
Object.defineProperty(exports, "escape", ({ enumerable: true, get: function () { return encode_2.escape; } }));
Object.defineProperty(exports, "escapeUTF8", ({ enumerable: true, get: function () { return encode_2.escapeUTF8; } }));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "encodeHTML4", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));
Object.defineProperty(exports, "encodeHTML5", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));
var decode_2 = __webpack_require__(4076);
Object.defineProperty(exports, "decodeXML", ({ enumerable: true, get: function () { return decode_2.decodeXML; } }));
Object.defineProperty(exports, "decodeHTML", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTMLStrict", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));
// Legacy aliases (deprecated)
Object.defineProperty(exports, "decodeHTML4", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTML5", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));
Object.defineProperty(exports, "decodeHTML4Strict", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));
Object.defineProperty(exports, "decodeHTML5Strict", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));
Object.defineProperty(exports, "decodeXMLStrict", ({ enumerable: true, get: function () { return decode_2.decodeXML; } }));


/***/ }),

/***/ 3870:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseFeed = exports.FeedHandler = void 0;
var domhandler_1 = __importDefault(__webpack_require__(7915));
var DomUtils = __importStar(__webpack_require__(9432));
var Parser_1 = __webpack_require__(763);
var FeedItemMediaMedium;
(function (FeedItemMediaMedium) {
    FeedItemMediaMedium[FeedItemMediaMedium["image"] = 0] = "image";
    FeedItemMediaMedium[FeedItemMediaMedium["audio"] = 1] = "audio";
    FeedItemMediaMedium[FeedItemMediaMedium["video"] = 2] = "video";
    FeedItemMediaMedium[FeedItemMediaMedium["document"] = 3] = "document";
    FeedItemMediaMedium[FeedItemMediaMedium["executable"] = 4] = "executable";
})(FeedItemMediaMedium || (FeedItemMediaMedium = {}));
var FeedItemMediaExpression;
(function (FeedItemMediaExpression) {
    FeedItemMediaExpression[FeedItemMediaExpression["sample"] = 0] = "sample";
    FeedItemMediaExpression[FeedItemMediaExpression["full"] = 1] = "full";
    FeedItemMediaExpression[FeedItemMediaExpression["nonstop"] = 2] = "nonstop";
})(FeedItemMediaExpression || (FeedItemMediaExpression = {}));
// TODO: Consume data as it is coming in
var FeedHandler = /** @class */ (function (_super) {
    __extends(FeedHandler, _super);
    /**
     *
     * @param callback
     * @param options
     */
    function FeedHandler(callback, options) {
        var _this = this;
        if (typeof callback === "object") {
            callback = undefined;
            options = callback;
        }
        _this = _super.call(this, callback, options) || this;
        return _this;
    }
    FeedHandler.prototype.onend = function () {
        var _a, _b;
        var feedRoot = getOneElement(isValidFeed, this.dom);
        if (!feedRoot) {
            this.handleCallback(new Error("couldn't find root of feed"));
            return;
        }
        var feed = {};
        if (feedRoot.name === "feed") {
            var childs = feedRoot.children;
            feed.type = "atom";
            addConditionally(feed, "id", "id", childs);
            addConditionally(feed, "title", "title", childs);
            var href = getAttribute("href", getOneElement("link", childs));
            if (href) {
                feed.link = href;
            }
            addConditionally(feed, "description", "subtitle", childs);
            var updated = fetch("updated", childs);
            if (updated) {
                feed.updated = new Date(updated);
            }
            addConditionally(feed, "author", "email", childs, true);
            feed.items = getElements("entry", childs).map(function (item) {
                var entry = {};
                var children = item.children;
                addConditionally(entry, "id", "id", children);
                addConditionally(entry, "title", "title", children);
                var href = getAttribute("href", getOneElement("link", children));
                if (href) {
                    entry.link = href;
                }
                var description = fetch("summary", children) || fetch("content", children);
                if (description) {
                    entry.description = description;
                }
                var pubDate = fetch("updated", children);
                if (pubDate) {
                    entry.pubDate = new Date(pubDate);
                }
                entry.media = getMediaElements(children);
                return entry;
            });
        }
        else {
            var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
            feed.type = feedRoot.name.substr(0, 3);
            feed.id = "";
            addConditionally(feed, "title", "title", childs);
            addConditionally(feed, "link", "link", childs);
            addConditionally(feed, "description", "description", childs);
            var updated = fetch("lastBuildDate", childs);
            if (updated) {
                feed.updated = new Date(updated);
            }
            addConditionally(feed, "author", "managingEditor", childs, true);
            feed.items = getElements("item", feedRoot.children).map(function (item) {
                var entry = {};
                var children = item.children;
                addConditionally(entry, "id", "guid", children);
                addConditionally(entry, "title", "title", children);
                addConditionally(entry, "link", "link", children);
                addConditionally(entry, "description", "description", children);
                var pubDate = fetch("pubDate", children);
                if (pubDate)
                    entry.pubDate = new Date(pubDate);
                entry.media = getMediaElements(children);
                return entry;
            });
        }
        this.feed = feed;
        this.handleCallback(null);
    };
    return FeedHandler;
}(domhandler_1.default));
exports.FeedHandler = FeedHandler;
function getMediaElements(where) {
    return getElements("media:content", where).map(function (elem) {
        var media = {
            medium: elem.attribs.medium,
            isDefault: !!elem.attribs.isDefault,
        };
        if (elem.attribs.url) {
            media.url = elem.attribs.url;
        }
        if (elem.attribs.fileSize) {
            media.fileSize = parseInt(elem.attribs.fileSize, 10);
        }
        if (elem.attribs.type) {
            media.type = elem.attribs.type;
        }
        if (elem.attribs.expression) {
            media.expression = elem.attribs
                .expression;
        }
        if (elem.attribs.bitrate) {
            media.bitrate = parseInt(elem.attribs.bitrate, 10);
        }
        if (elem.attribs.framerate) {
            media.framerate = parseInt(elem.attribs.framerate, 10);
        }
        if (elem.attribs.samplingrate) {
            media.samplingrate = parseInt(elem.attribs.samplingrate, 10);
        }
        if (elem.attribs.channels) {
            media.channels = parseInt(elem.attribs.channels, 10);
        }
        if (elem.attribs.duration) {
            media.duration = parseInt(elem.attribs.duration, 10);
        }
        if (elem.attribs.height) {
            media.height = parseInt(elem.attribs.height, 10);
        }
        if (elem.attribs.width) {
            media.width = parseInt(elem.attribs.width, 10);
        }
        if (elem.attribs.lang) {
            media.lang = elem.attribs.lang;
        }
        return media;
    });
}
function getElements(tagName, where) {
    return DomUtils.getElementsByTagName(tagName, where, true);
}
function getOneElement(tagName, node) {
    return DomUtils.getElementsByTagName(tagName, node, true, 1)[0];
}
function fetch(tagName, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function getAttribute(name, elem) {
    if (!elem) {
        return null;
    }
    var attribs = elem.attribs;
    return attribs[name];
}
function addConditionally(obj, prop, what, where, recurse) {
    if (recurse === void 0) { recurse = false; }
    var tmp = fetch(what, where, recurse);
    if (tmp)
        obj[prop] = tmp;
}
function isValidFeed(value) {
    return value === "rss" || value === "feed" || value === "rdf:RDF";
}
/**
 * Parse a feed.
 *
 * @param feed The feed that should be parsed, as a string.
 * @param options Optionally, options for parsing. When using this option, you should set `xmlMode` to `true`.
 */
function parseFeed(feed, options) {
    if (options === void 0) { options = { xmlMode: true }; }
    var handler = new FeedHandler(options);
    new Parser_1.Parser(handler, options).end(feed);
    return handler.feed;
}
exports.parseFeed = parseFeed;


/***/ }),

/***/ 763:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parser = void 0;
var Tokenizer_1 = __importDefault(__webpack_require__(9889));
var formTags = new Set([
    "input",
    "option",
    "optgroup",
    "select",
    "button",
    "datalist",
    "textarea",
]);
var pTag = new Set(["p"]);
var openImpliesClose = {
    tr: new Set(["tr", "th", "td"]),
    th: new Set(["th"]),
    td: new Set(["thead", "th", "td"]),
    body: new Set(["head", "link", "script"]),
    li: new Set(["li"]),
    p: pTag,
    h1: pTag,
    h2: pTag,
    h3: pTag,
    h4: pTag,
    h5: pTag,
    h6: pTag,
    select: formTags,
    input: formTags,
    output: formTags,
    button: formTags,
    datalist: formTags,
    textarea: formTags,
    option: new Set(["option"]),
    optgroup: new Set(["optgroup", "option"]),
    dd: new Set(["dt", "dd"]),
    dt: new Set(["dt", "dd"]),
    address: pTag,
    article: pTag,
    aside: pTag,
    blockquote: pTag,
    details: pTag,
    div: pTag,
    dl: pTag,
    fieldset: pTag,
    figcaption: pTag,
    figure: pTag,
    footer: pTag,
    form: pTag,
    header: pTag,
    hr: pTag,
    main: pTag,
    nav: pTag,
    ol: pTag,
    pre: pTag,
    section: pTag,
    table: pTag,
    ul: pTag,
    rt: new Set(["rt", "rp"]),
    rp: new Set(["rt", "rp"]),
    tbody: new Set(["thead", "tbody"]),
    tfoot: new Set(["thead", "tbody"]),
};
var voidElements = new Set([
    "area",
    "base",
    "basefont",
    "br",
    "col",
    "command",
    "embed",
    "frame",
    "hr",
    "img",
    "input",
    "isindex",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr",
]);
var foreignContextElements = new Set(["math", "svg"]);
var htmlIntegrationElements = new Set([
    "mi",
    "mo",
    "mn",
    "ms",
    "mtext",
    "annotation-xml",
    "foreignObject",
    "desc",
    "title",
]);
var reNameEnd = /\s|\//;
var Parser = /** @class */ (function () {
    function Parser(cbs, options) {
        if (options === void 0) { options = {}; }
        var _a, _b, _c, _d, _e;
        /** The start index of the last event. */
        this.startIndex = 0;
        /** The end index of the last event. */
        this.endIndex = null;
        this.tagname = "";
        this.attribname = "";
        this.attribvalue = "";
        this.attribs = null;
        this.stack = [];
        this.foreignContext = [];
        this.options = options;
        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
        this.lowerCaseAttributeNames =
            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);
        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
    }
    Parser.prototype.updatePosition = function (initialOffset) {
        if (this.endIndex === null) {
            if (this.tokenizer.sectionStart <= initialOffset) {
                this.startIndex = 0;
            }
            else {
                this.startIndex = this.tokenizer.sectionStart - initialOffset;
            }
        }
        else {
            this.startIndex = this.endIndex + 1;
        }
        this.endIndex = this.tokenizer.getAbsoluteIndex();
    };
    // Tokenizer event handlers
    Parser.prototype.ontext = function (data) {
        var _a, _b;
        this.updatePosition(1);
        this.endIndex--;
        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
    };
    Parser.prototype.onopentagname = function (name) {
        var _a, _b;
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        this.tagname = name;
        if (!this.options.xmlMode &&
            Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
            var el = void 0;
            while (this.stack.length > 0 &&
                openImpliesClose[name].has((el = this.stack[this.stack.length - 1]))) {
                this.onclosetag(el);
            }
        }
        if (this.options.xmlMode || !voidElements.has(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
                this.foreignContext.push(true);
            }
            else if (htmlIntegrationElements.has(name)) {
                this.foreignContext.push(false);
            }
        }
        (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, name);
        if (this.cbs.onopentag)
            this.attribs = {};
    };
    Parser.prototype.onopentagend = function () {
        var _a, _b;
        this.updatePosition(1);
        if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs);
            this.attribs = null;
        }
        if (!this.options.xmlMode &&
            this.cbs.onclosetag &&
            voidElements.has(this.tagname)) {
            this.cbs.onclosetag(this.tagname);
        }
        this.tagname = "";
    };
    Parser.prototype.onclosetag = function (name) {
        this.updatePosition(1);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        if (foreignContextElements.has(name) ||
            htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
        }
        if (this.stack.length &&
            (this.options.xmlMode || !voidElements.has(name))) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
                if (this.cbs.onclosetag) {
                    pos = this.stack.length - pos;
                    while (pos--) {
                        // We know the stack has sufficient elements.
                        this.cbs.onclosetag(this.stack.pop());
                    }
                }
                else
                    this.stack.length = pos;
            }
            else if (name === "p" && !this.options.xmlMode) {
                this.onopentagname(name);
                this.closeCurrentTag();
            }
        }
        else if (!this.options.xmlMode && (name === "br" || name === "p")) {
            this.onopentagname(name);
            this.closeCurrentTag();
        }
    };
    Parser.prototype.onselfclosingtag = function () {
        if (this.options.xmlMode ||
            this.options.recognizeSelfClosing ||
            this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag();
        }
        else {
            this.onopentagend();
        }
    };
    Parser.prototype.closeCurrentTag = function () {
        var _a, _b;
        var name = this.tagname;
        this.onopentagend();
        /*
         * Self-closing tags will be on the top of the stack
         * (cheaper check than in onclosetag)
         */
        if (this.stack[this.stack.length - 1] === name) {
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name);
            this.stack.pop();
        }
    };
    Parser.prototype.onattribname = function (name) {
        if (this.lowerCaseAttributeNames) {
            name = name.toLowerCase();
        }
        this.attribname = name;
    };
    Parser.prototype.onattribdata = function (value) {
        this.attribvalue += value;
    };
    Parser.prototype.onattribend = function (quote) {
        var _a, _b;
        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote);
        if (this.attribs &&
            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
        }
        this.attribname = "";
        this.attribvalue = "";
    };
    Parser.prototype.getInstructionName = function (value) {
        var idx = value.search(reNameEnd);
        var name = idx < 0 ? value : value.substr(0, idx);
        if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
        }
        return name;
    };
    Parser.prototype.ondeclaration = function (value) {
        if (this.cbs.onprocessinginstruction) {
            var name_1 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
        }
    };
    Parser.prototype.onprocessinginstruction = function (value) {
        if (this.cbs.onprocessinginstruction) {
            var name_2 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
        }
    };
    Parser.prototype.oncomment = function (value) {
        var _a, _b, _c, _d;
        this.updatePosition(4);
        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
    };
    Parser.prototype.oncdata = function (value) {
        var _a, _b, _c, _d, _e, _f;
        this.updatePosition(1);
        if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
        }
        else {
            this.oncomment("[CDATA[" + value + "]]");
        }
    };
    Parser.prototype.onerror = function (err) {
        var _a, _b;
        (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };
    Parser.prototype.onend = function () {
        var _a, _b;
        if (this.cbs.onclosetag) {
            for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i]))
                ;
        }
        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    /**
     * Resets the parser to a blank state, ready to parse a new HTML document
     */
    Parser.prototype.reset = function () {
        var _a, _b, _c, _d;
        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.tokenizer.reset();
        this.tagname = "";
        this.attribname = "";
        this.attribs = null;
        this.stack = [];
        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
    };
    /**
     * Resets the parser, then parses a complete document and
     * pushes it to the handler.
     *
     * @param data Document to parse.
     */
    Parser.prototype.parseComplete = function (data) {
        this.reset();
        this.end(data);
    };
    /**
     * Parses a chunk of data and calls the corresponding callbacks.
     *
     * @param chunk Chunk to parse.
     */
    Parser.prototype.write = function (chunk) {
        this.tokenizer.write(chunk);
    };
    /**
     * Parses the end of the buffer and clears the stack, calls onend.
     *
     * @param chunk Optional final chunk to parse.
     */
    Parser.prototype.end = function (chunk) {
        this.tokenizer.end(chunk);
    };
    /**
     * Pauses parsing. The parser won't emit events until `resume` is called.
     */
    Parser.prototype.pause = function () {
        this.tokenizer.pause();
    };
    /**
     * Resumes parsing after `pause` was called.
     */
    Parser.prototype.resume = function () {
        this.tokenizer.resume();
    };
    /**
     * Alias of `write`, for backwards compatibility.
     *
     * @param chunk Chunk to parse.
     * @deprecated
     */
    Parser.prototype.parseChunk = function (chunk) {
        this.write(chunk);
    };
    /**
     * Alias of `end`, for backwards compatibility.
     *
     * @param chunk Optional final chunk to parse.
     * @deprecated
     */
    Parser.prototype.done = function (chunk) {
        this.end(chunk);
    };
    return Parser;
}());
exports.Parser = Parser;


/***/ }),

/***/ 9889:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var decode_codepoint_1 = __importDefault(__webpack_require__(26));
var entities_json_1 = __importDefault(__webpack_require__(9323));
var legacy_json_1 = __importDefault(__webpack_require__(9591));
var xml_json_1 = __importDefault(__webpack_require__(2586));
function whitespace(c) {
    return c === " " || c === "\n" || c === "\t" || c === "\f" || c === "\r";
}
function isASCIIAlpha(c) {
    return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z");
}
function ifElseState(upper, SUCCESS, FAILURE) {
    var lower = upper.toLowerCase();
    if (upper === lower) {
        return function (t, c) {
            if (c === lower) {
                t._state = SUCCESS;
            }
            else {
                t._state = FAILURE;
                t._index--;
            }
        };
    }
    return function (t, c) {
        if (c === lower || c === upper) {
            t._state = SUCCESS;
        }
        else {
            t._state = FAILURE;
            t._index--;
        }
    };
}
function consumeSpecialNameChar(upper, NEXT_STATE) {
    var lower = upper.toLowerCase();
    return function (t, c) {
        if (c === lower || c === upper) {
            t._state = NEXT_STATE;
        }
        else {
            t._state = 3 /* InTagName */;
            t._index--; // Consume the token again
        }
    };
}
var stateBeforeCdata1 = ifElseState("C", 24 /* BeforeCdata2 */, 16 /* InDeclaration */);
var stateBeforeCdata2 = ifElseState("D", 25 /* BeforeCdata3 */, 16 /* InDeclaration */);
var stateBeforeCdata3 = ifElseState("A", 26 /* BeforeCdata4 */, 16 /* InDeclaration */);
var stateBeforeCdata4 = ifElseState("T", 27 /* BeforeCdata5 */, 16 /* InDeclaration */);
var stateBeforeCdata5 = ifElseState("A", 28 /* BeforeCdata6 */, 16 /* InDeclaration */);
var stateBeforeScript1 = consumeSpecialNameChar("R", 35 /* BeforeScript2 */);
var stateBeforeScript2 = consumeSpecialNameChar("I", 36 /* BeforeScript3 */);
var stateBeforeScript3 = consumeSpecialNameChar("P", 37 /* BeforeScript4 */);
var stateBeforeScript4 = consumeSpecialNameChar("T", 38 /* BeforeScript5 */);
var stateAfterScript1 = ifElseState("R", 40 /* AfterScript2 */, 1 /* Text */);
var stateAfterScript2 = ifElseState("I", 41 /* AfterScript3 */, 1 /* Text */);
var stateAfterScript3 = ifElseState("P", 42 /* AfterScript4 */, 1 /* Text */);
var stateAfterScript4 = ifElseState("T", 43 /* AfterScript5 */, 1 /* Text */);
var stateBeforeStyle1 = consumeSpecialNameChar("Y", 45 /* BeforeStyle2 */);
var stateBeforeStyle2 = consumeSpecialNameChar("L", 46 /* BeforeStyle3 */);
var stateBeforeStyle3 = consumeSpecialNameChar("E", 47 /* BeforeStyle4 */);
var stateAfterStyle1 = ifElseState("Y", 49 /* AfterStyle2 */, 1 /* Text */);
var stateAfterStyle2 = ifElseState("L", 50 /* AfterStyle3 */, 1 /* Text */);
var stateAfterStyle3 = ifElseState("E", 51 /* AfterStyle4 */, 1 /* Text */);
var stateBeforeSpecialT = consumeSpecialNameChar("I", 54 /* BeforeTitle1 */);
var stateBeforeTitle1 = consumeSpecialNameChar("T", 55 /* BeforeTitle2 */);
var stateBeforeTitle2 = consumeSpecialNameChar("L", 56 /* BeforeTitle3 */);
var stateBeforeTitle3 = consumeSpecialNameChar("E", 57 /* BeforeTitle4 */);
var stateAfterSpecialTEnd = ifElseState("I", 58 /* AfterTitle1 */, 1 /* Text */);
var stateAfterTitle1 = ifElseState("T", 59 /* AfterTitle2 */, 1 /* Text */);
var stateAfterTitle2 = ifElseState("L", 60 /* AfterTitle3 */, 1 /* Text */);
var stateAfterTitle3 = ifElseState("E", 61 /* AfterTitle4 */, 1 /* Text */);
var stateBeforeEntity = ifElseState("#", 63 /* BeforeNumericEntity */, 64 /* InNamedEntity */);
var stateBeforeNumericEntity = ifElseState("X", 66 /* InHexEntity */, 65 /* InNumericEntity */);
var Tokenizer = /** @class */ (function () {
    function Tokenizer(options, cbs) {
        var _a;
        /** The current state the tokenizer is in. */
        this._state = 1 /* Text */;
        /** The read buffer. */
        this.buffer = "";
        /** The beginning of the section that is currently being read. */
        this.sectionStart = 0;
        /** The index within the buffer that we are currently looking at. */
        this._index = 0;
        /**
         * Data that has already been processed will be removed from the buffer occasionally.
         * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.
         */
        this.bufferOffset = 0;
        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */
        this.baseState = 1 /* Text */;
        /** For special parsing behavior inside of script and style tags. */
        this.special = 1 /* None */;
        /** Indicates whether the tokenizer has been paused. */
        this.running = true;
        /** Indicates whether the tokenizer has finished running / `.end` has been called. */
        this.ended = false;
        this.cbs = cbs;
        this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);
        this.decodeEntities = (_a = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a !== void 0 ? _a : true;
    }
    Tokenizer.prototype.reset = function () {
        this._state = 1 /* Text */;
        this.buffer = "";
        this.sectionStart = 0;
        this._index = 0;
        this.bufferOffset = 0;
        this.baseState = 1 /* Text */;
        this.special = 1 /* None */;
        this.running = true;
        this.ended = false;
    };
    Tokenizer.prototype.write = function (chunk) {
        if (this.ended)
            this.cbs.onerror(Error(".write() after done!"));
        this.buffer += chunk;
        this.parse();
    };
    Tokenizer.prototype.end = function (chunk) {
        if (this.ended)
            this.cbs.onerror(Error(".end() after done!"));
        if (chunk)
            this.write(chunk);
        this.ended = true;
        if (this.running)
            this.finish();
    };
    Tokenizer.prototype.pause = function () {
        this.running = false;
    };
    Tokenizer.prototype.resume = function () {
        this.running = true;
        if (this._index < this.buffer.length) {
            this.parse();
        }
        if (this.ended) {
            this.finish();
        }
    };
    /**
     * The current index within all of the written data.
     */
    Tokenizer.prototype.getAbsoluteIndex = function () {
        return this.bufferOffset + this._index;
    };
    Tokenizer.prototype.stateText = function (c) {
        if (c === "<") {
            if (this._index > this.sectionStart) {
                this.cbs.ontext(this.getSection());
            }
            this._state = 2 /* BeforeTagName */;
            this.sectionStart = this._index;
        }
        else if (this.decodeEntities &&
            c === "&" &&
            (this.special === 1 /* None */ || this.special === 4 /* Title */)) {
            if (this._index > this.sectionStart) {
                this.cbs.ontext(this.getSection());
            }
            this.baseState = 1 /* Text */;
            this._state = 62 /* BeforeEntity */;
            this.sectionStart = this._index;
        }
    };
    /**
     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
     *
     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
     * We allow anything that wouldn't end the tag.
     */
    Tokenizer.prototype.isTagStartChar = function (c) {
        return (isASCIIAlpha(c) ||
            (this.xmlMode && !whitespace(c) && c !== "/" && c !== ">"));
    };
    Tokenizer.prototype.stateBeforeTagName = function (c) {
        if (c === "/") {
            this._state = 5 /* BeforeClosingTagName */;
        }
        else if (c === "<") {
            this.cbs.ontext(this.getSection());
            this.sectionStart = this._index;
        }
        else if (c === ">" ||
            this.special !== 1 /* None */ ||
            whitespace(c)) {
            this._state = 1 /* Text */;
        }
        else if (c === "!") {
            this._state = 15 /* BeforeDeclaration */;
            this.sectionStart = this._index + 1;
        }
        else if (c === "?") {
            this._state = 17 /* InProcessingInstruction */;
            this.sectionStart = this._index + 1;
        }
        else if (!this.isTagStartChar(c)) {
            this._state = 1 /* Text */;
        }
        else {
            this._state =
                !this.xmlMode && (c === "s" || c === "S")
                    ? 32 /* BeforeSpecialS */
                    : !this.xmlMode && (c === "t" || c === "T")
                        ? 52 /* BeforeSpecialT */
                        : 3 /* InTagName */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateInTagName = function (c) {
        if (c === "/" || c === ">" || whitespace(c)) {
            this.emitToken("onopentagname");
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateBeforeClosingTagName = function (c) {
        if (whitespace(c)) {
            // Ignore
        }
        else if (c === ">") {
            this._state = 1 /* Text */;
        }
        else if (this.special !== 1 /* None */) {
            if (this.special !== 4 /* Title */ && (c === "s" || c === "S")) {
                this._state = 33 /* BeforeSpecialSEnd */;
            }
            else if (this.special === 4 /* Title */ &&
                (c === "t" || c === "T")) {
                this._state = 53 /* BeforeSpecialTEnd */;
            }
            else {
                this._state = 1 /* Text */;
                this._index--;
            }
        }
        else if (!this.isTagStartChar(c)) {
            this._state = 20 /* InSpecialComment */;
            this.sectionStart = this._index;
        }
        else {
            this._state = 6 /* InClosingTagName */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateInClosingTagName = function (c) {
        if (c === ">" || whitespace(c)) {
            this.emitToken("onclosetag");
            this._state = 7 /* AfterClosingTagName */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateAfterClosingTagName = function (c) {
        // Skip everything until ">"
        if (c === ">") {
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeName = function (c) {
        if (c === ">") {
            this.cbs.onopentagend();
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
        else if (c === "/") {
            this._state = 4 /* InSelfClosingTag */;
        }
        else if (!whitespace(c)) {
            this._state = 9 /* InAttributeName */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateInSelfClosingTag = function (c) {
        if (c === ">") {
            this.cbs.onselfclosingtag();
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
            this.special = 1 /* None */; // Reset special state, in case of self-closing special tags
        }
        else if (!whitespace(c)) {
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateInAttributeName = function (c) {
        if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
            this.cbs.onattribname(this.getSection());
            this.sectionStart = -1;
            this._state = 10 /* AfterAttributeName */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateAfterAttributeName = function (c) {
        if (c === "=") {
            this._state = 11 /* BeforeAttributeValue */;
        }
        else if (c === "/" || c === ">") {
            this.cbs.onattribend(undefined);
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
        else if (!whitespace(c)) {
            this.cbs.onattribend(undefined);
            this._state = 9 /* InAttributeName */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateBeforeAttributeValue = function (c) {
        if (c === '"') {
            this._state = 12 /* InAttributeValueDq */;
            this.sectionStart = this._index + 1;
        }
        else if (c === "'") {
            this._state = 13 /* InAttributeValueSq */;
            this.sectionStart = this._index + 1;
        }
        else if (!whitespace(c)) {
            this._state = 14 /* InAttributeValueNq */;
            this.sectionStart = this._index;
            this._index--; // Reconsume token
        }
    };
    Tokenizer.prototype.handleInAttributeValue = function (c, quote) {
        if (c === quote) {
            this.emitToken("onattribdata");
            this.cbs.onattribend(quote);
            this._state = 8 /* BeforeAttributeName */;
        }
        else if (this.decodeEntities && c === "&") {
            this.emitToken("onattribdata");
            this.baseState = this._state;
            this._state = 62 /* BeforeEntity */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {
        this.handleInAttributeValue(c, '"');
    };
    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {
        this.handleInAttributeValue(c, "'");
    };
    Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {
        if (whitespace(c) || c === ">") {
            this.emitToken("onattribdata");
            this.cbs.onattribend(null);
            this._state = 8 /* BeforeAttributeName */;
            this._index--;
        }
        else if (this.decodeEntities && c === "&") {
            this.emitToken("onattribdata");
            this.baseState = this._state;
            this._state = 62 /* BeforeEntity */;
            this.sectionStart = this._index;
        }
    };
    Tokenizer.prototype.stateBeforeDeclaration = function (c) {
        this._state =
            c === "["
                ? 23 /* BeforeCdata1 */
                : c === "-"
                    ? 18 /* BeforeComment */
                    : 16 /* InDeclaration */;
    };
    Tokenizer.prototype.stateInDeclaration = function (c) {
        if (c === ">") {
            this.cbs.ondeclaration(this.getSection());
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype.stateInProcessingInstruction = function (c) {
        if (c === ">") {
            this.cbs.onprocessinginstruction(this.getSection());
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype.stateBeforeComment = function (c) {
        if (c === "-") {
            this._state = 19 /* InComment */;
            this.sectionStart = this._index + 1;
        }
        else {
            this._state = 16 /* InDeclaration */;
        }
    };
    Tokenizer.prototype.stateInComment = function (c) {
        if (c === "-")
            this._state = 21 /* AfterComment1 */;
    };
    Tokenizer.prototype.stateInSpecialComment = function (c) {
        if (c === ">") {
            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
    };
    Tokenizer.prototype.stateAfterComment1 = function (c) {
        if (c === "-") {
            this._state = 22 /* AfterComment2 */;
        }
        else {
            this._state = 19 /* InComment */;
        }
    };
    Tokenizer.prototype.stateAfterComment2 = function (c) {
        if (c === ">") {
            // Remove 2 trailing chars
            this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
        else if (c !== "-") {
            this._state = 19 /* InComment */;
        }
        // Else: stay in AFTER_COMMENT_2 (`--->`)
    };
    Tokenizer.prototype.stateBeforeCdata6 = function (c) {
        if (c === "[") {
            this._state = 29 /* InCdata */;
            this.sectionStart = this._index + 1;
        }
        else {
            this._state = 16 /* InDeclaration */;
            this._index--;
        }
    };
    Tokenizer.prototype.stateInCdata = function (c) {
        if (c === "]")
            this._state = 30 /* AfterCdata1 */;
    };
    Tokenizer.prototype.stateAfterCdata1 = function (c) {
        if (c === "]")
            this._state = 31 /* AfterCdata2 */;
        else
            this._state = 29 /* InCdata */;
    };
    Tokenizer.prototype.stateAfterCdata2 = function (c) {
        if (c === ">") {
            // Remove 2 trailing chars
            this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));
            this._state = 1 /* Text */;
            this.sectionStart = this._index + 1;
        }
        else if (c !== "]") {
            this._state = 29 /* InCdata */;
        }
        // Else: stay in AFTER_CDATA_2 (`]]]>`)
    };
    Tokenizer.prototype.stateBeforeSpecialS = function (c) {
        if (c === "c" || c === "C") {
            this._state = 34 /* BeforeScript1 */;
        }
        else if (c === "t" || c === "T") {
            this._state = 44 /* BeforeStyle1 */;
        }
        else {
            this._state = 3 /* InTagName */;
            this._index--; // Consume the token again
        }
    };
    Tokenizer.prototype.stateBeforeSpecialSEnd = function (c) {
        if (this.special === 2 /* Script */ && (c === "c" || c === "C")) {
            this._state = 39 /* AfterScript1 */;
        }
        else if (this.special === 3 /* Style */ && (c === "t" || c === "T")) {
            this._state = 48 /* AfterStyle1 */;
        }
        else
            this._state = 1 /* Text */;
    };
    Tokenizer.prototype.stateBeforeSpecialLast = function (c, special) {
        if (c === "/" || c === ">" || whitespace(c)) {
            this.special = special;
        }
        this._state = 3 /* InTagName */;
        this._index--; // Consume the token again
    };
    Tokenizer.prototype.stateAfterSpecialLast = function (c, sectionStartOffset) {
        if (c === ">" || whitespace(c)) {
            this.special = 1 /* None */;
            this._state = 6 /* InClosingTagName */;
            this.sectionStart = this._index - sectionStartOffset;
            this._index--; // Reconsume the token
        }
        else
            this._state = 1 /* Text */;
    };
    // For entities terminated with a semicolon
    Tokenizer.prototype.parseFixedEntity = function (map) {
        if (map === void 0) { map = this.xmlMode ? xml_json_1.default : entities_json_1.default; }
        // Offset = 1
        if (this.sectionStart + 1 < this._index) {
            var entity = this.buffer.substring(this.sectionStart + 1, this._index);
            if (Object.prototype.hasOwnProperty.call(map, entity)) {
                this.emitPartial(map[entity]);
                this.sectionStart = this._index + 1;
            }
        }
    };
    // Parses legacy entities (without trailing semicolon)
    Tokenizer.prototype.parseLegacyEntity = function () {
        var start = this.sectionStart + 1;
        // The max length of legacy entities is 6
        var limit = Math.min(this._index - start, 6);
        while (limit >= 2) {
            // The min length of legacy entities is 2
            var entity = this.buffer.substr(start, limit);
            if (Object.prototype.hasOwnProperty.call(legacy_json_1.default, entity)) {
                this.emitPartial(legacy_json_1.default[entity]);
                this.sectionStart += limit + 1;
                return;
            }
            limit--;
        }
    };
    Tokenizer.prototype.stateInNamedEntity = function (c) {
        if (c === ";") {
            this.parseFixedEntity();
            // Retry as legacy entity if entity wasn't parsed
            if (this.baseState === 1 /* Text */ &&
                this.sectionStart + 1 < this._index &&
                !this.xmlMode) {
                this.parseLegacyEntity();
            }
            this._state = this.baseState;
        }
        else if ((c < "0" || c > "9") && !isASCIIAlpha(c)) {
            if (this.xmlMode || this.sectionStart + 1 === this._index) {
                // Ignore
            }
            else if (this.baseState !== 1 /* Text */) {
                if (c !== "=") {
                    // Parse as legacy entity, without allowing additional characters.
                    this.parseFixedEntity(legacy_json_1.default);
                }
            }
            else {
                this.parseLegacyEntity();
            }
            this._state = this.baseState;
            this._index--;
        }
    };
    Tokenizer.prototype.decodeNumericEntity = function (offset, base, strict) {
        var sectionStart = this.sectionStart + offset;
        if (sectionStart !== this._index) {
            // Parse entity
            var entity = this.buffer.substring(sectionStart, this._index);
            var parsed = parseInt(entity, base);
            this.emitPartial(decode_codepoint_1.default(parsed));
            this.sectionStart = strict ? this._index + 1 : this._index;
        }
        this._state = this.baseState;
    };
    Tokenizer.prototype.stateInNumericEntity = function (c) {
        if (c === ";") {
            this.decodeNumericEntity(2, 10, true);
        }
        else if (c < "0" || c > "9") {
            if (!this.xmlMode) {
                this.decodeNumericEntity(2, 10, false);
            }
            else {
                this._state = this.baseState;
            }
            this._index--;
        }
    };
    Tokenizer.prototype.stateInHexEntity = function (c) {
        if (c === ";") {
            this.decodeNumericEntity(3, 16, true);
        }
        else if ((c < "a" || c > "f") &&
            (c < "A" || c > "F") &&
            (c < "0" || c > "9")) {
            if (!this.xmlMode) {
                this.decodeNumericEntity(3, 16, false);
            }
            else {
                this._state = this.baseState;
            }
            this._index--;
        }
    };
    Tokenizer.prototype.cleanup = function () {
        if (this.sectionStart < 0) {
            this.buffer = "";
            this.bufferOffset += this._index;
            this._index = 0;
        }
        else if (this.running) {
            if (this._state === 1 /* Text */) {
                if (this.sectionStart !== this._index) {
                    this.cbs.ontext(this.buffer.substr(this.sectionStart));
                }
                this.buffer = "";
                this.bufferOffset += this._index;
                this._index = 0;
            }
            else if (this.sectionStart === this._index) {
                // The section just started
                this.buffer = "";
                this.bufferOffset += this._index;
                this._index = 0;
            }
            else {
                // Remove everything unnecessary
                this.buffer = this.buffer.substr(this.sectionStart);
                this._index -= this.sectionStart;
                this.bufferOffset += this.sectionStart;
            }
            this.sectionStart = 0;
        }
    };
    /**
     * Iterates through the buffer, calling the function corresponding to the current state.
     *
     * States that are more likely to be hit are higher up, as a performance improvement.
     */
    Tokenizer.prototype.parse = function () {
        while (this._index < this.buffer.length && this.running) {
            var c = this.buffer.charAt(this._index);
            if (this._state === 1 /* Text */) {
                this.stateText(c);
            }
            else if (this._state === 12 /* InAttributeValueDq */) {
                this.stateInAttributeValueDoubleQuotes(c);
            }
            else if (this._state === 9 /* InAttributeName */) {
                this.stateInAttributeName(c);
            }
            else if (this._state === 19 /* InComment */) {
                this.stateInComment(c);
            }
            else if (this._state === 20 /* InSpecialComment */) {
                this.stateInSpecialComment(c);
            }
            else if (this._state === 8 /* BeforeAttributeName */) {
                this.stateBeforeAttributeName(c);
            }
            else if (this._state === 3 /* InTagName */) {
                this.stateInTagName(c);
            }
            else if (this._state === 6 /* InClosingTagName */) {
                this.stateInClosingTagName(c);
            }
            else if (this._state === 2 /* BeforeTagName */) {
                this.stateBeforeTagName(c);
            }
            else if (this._state === 10 /* AfterAttributeName */) {
                this.stateAfterAttributeName(c);
            }
            else if (this._state === 13 /* InAttributeValueSq */) {
                this.stateInAttributeValueSingleQuotes(c);
            }
            else if (this._state === 11 /* BeforeAttributeValue */) {
                this.stateBeforeAttributeValue(c);
            }
            else if (this._state === 5 /* BeforeClosingTagName */) {
                this.stateBeforeClosingTagName(c);
            }
            else if (this._state === 7 /* AfterClosingTagName */) {
                this.stateAfterClosingTagName(c);
            }
            else if (this._state === 32 /* BeforeSpecialS */) {
                this.stateBeforeSpecialS(c);
            }
            else if (this._state === 21 /* AfterComment1 */) {
                this.stateAfterComment1(c);
            }
            else if (this._state === 14 /* InAttributeValueNq */) {
                this.stateInAttributeValueNoQuotes(c);
            }
            else if (this._state === 4 /* InSelfClosingTag */) {
                this.stateInSelfClosingTag(c);
            }
            else if (this._state === 16 /* InDeclaration */) {
                this.stateInDeclaration(c);
            }
            else if (this._state === 15 /* BeforeDeclaration */) {
                this.stateBeforeDeclaration(c);
            }
            else if (this._state === 22 /* AfterComment2 */) {
                this.stateAfterComment2(c);
            }
            else if (this._state === 18 /* BeforeComment */) {
                this.stateBeforeComment(c);
            }
            else if (this._state === 33 /* BeforeSpecialSEnd */) {
                this.stateBeforeSpecialSEnd(c);
            }
            else if (this._state === 53 /* BeforeSpecialTEnd */) {
                stateAfterSpecialTEnd(this, c);
            }
            else if (this._state === 39 /* AfterScript1 */) {
                stateAfterScript1(this, c);
            }
            else if (this._state === 40 /* AfterScript2 */) {
                stateAfterScript2(this, c);
            }
            else if (this._state === 41 /* AfterScript3 */) {
                stateAfterScript3(this, c);
            }
            else if (this._state === 34 /* BeforeScript1 */) {
                stateBeforeScript1(this, c);
            }
            else if (this._state === 35 /* BeforeScript2 */) {
                stateBeforeScript2(this, c);
            }
            else if (this._state === 36 /* BeforeScript3 */) {
                stateBeforeScript3(this, c);
            }
            else if (this._state === 37 /* BeforeScript4 */) {
                stateBeforeScript4(this, c);
            }
            else if (this._state === 38 /* BeforeScript5 */) {
                this.stateBeforeSpecialLast(c, 2 /* Script */);
            }
            else if (this._state === 42 /* AfterScript4 */) {
                stateAfterScript4(this, c);
            }
            else if (this._state === 43 /* AfterScript5 */) {
                this.stateAfterSpecialLast(c, 6);
            }
            else if (this._state === 44 /* BeforeStyle1 */) {
                stateBeforeStyle1(this, c);
            }
            else if (this._state === 29 /* InCdata */) {
                this.stateInCdata(c);
            }
            else if (this._state === 45 /* BeforeStyle2 */) {
                stateBeforeStyle2(this, c);
            }
            else if (this._state === 46 /* BeforeStyle3 */) {
                stateBeforeStyle3(this, c);
            }
            else if (this._state === 47 /* BeforeStyle4 */) {
                this.stateBeforeSpecialLast(c, 3 /* Style */);
            }
            else if (this._state === 48 /* AfterStyle1 */) {
                stateAfterStyle1(this, c);
            }
            else if (this._state === 49 /* AfterStyle2 */) {
                stateAfterStyle2(this, c);
            }
            else if (this._state === 50 /* AfterStyle3 */) {
                stateAfterStyle3(this, c);
            }
            else if (this._state === 51 /* AfterStyle4 */) {
                this.stateAfterSpecialLast(c, 5);
            }
            else if (this._state === 52 /* BeforeSpecialT */) {
                stateBeforeSpecialT(this, c);
            }
            else if (this._state === 54 /* BeforeTitle1 */) {
                stateBeforeTitle1(this, c);
            }
            else if (this._state === 55 /* BeforeTitle2 */) {
                stateBeforeTitle2(this, c);
            }
            else if (this._state === 56 /* BeforeTitle3 */) {
                stateBeforeTitle3(this, c);
            }
            else if (this._state === 57 /* BeforeTitle4 */) {
                this.stateBeforeSpecialLast(c, 4 /* Title */);
            }
            else if (this._state === 58 /* AfterTitle1 */) {
                stateAfterTitle1(this, c);
            }
            else if (this._state === 59 /* AfterTitle2 */) {
                stateAfterTitle2(this, c);
            }
            else if (this._state === 60 /* AfterTitle3 */) {
                stateAfterTitle3(this, c);
            }
            else if (this._state === 61 /* AfterTitle4 */) {
                this.stateAfterSpecialLast(c, 5);
            }
            else if (this._state === 17 /* InProcessingInstruction */) {
                this.stateInProcessingInstruction(c);
            }
            else if (this._state === 64 /* InNamedEntity */) {
                this.stateInNamedEntity(c);
            }
            else if (this._state === 23 /* BeforeCdata1 */) {
                stateBeforeCdata1(this, c);
            }
            else if (this._state === 62 /* BeforeEntity */) {
                stateBeforeEntity(this, c);
            }
            else if (this._state === 24 /* BeforeCdata2 */) {
                stateBeforeCdata2(this, c);
            }
            else if (this._state === 25 /* BeforeCdata3 */) {
                stateBeforeCdata3(this, c);
            }
            else if (this._state === 30 /* AfterCdata1 */) {
                this.stateAfterCdata1(c);
            }
            else if (this._state === 31 /* AfterCdata2 */) {
                this.stateAfterCdata2(c);
            }
            else if (this._state === 26 /* BeforeCdata4 */) {
                stateBeforeCdata4(this, c);
            }
            else if (this._state === 27 /* BeforeCdata5 */) {
                stateBeforeCdata5(this, c);
            }
            else if (this._state === 28 /* BeforeCdata6 */) {
                this.stateBeforeCdata6(c);
            }
            else if (this._state === 66 /* InHexEntity */) {
                this.stateInHexEntity(c);
            }
            else if (this._state === 65 /* InNumericEntity */) {
                this.stateInNumericEntity(c);
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            }
            else if (this._state === 63 /* BeforeNumericEntity */) {
                stateBeforeNumericEntity(this, c);
            }
            else {
                this.cbs.onerror(Error("unknown _state"), this._state);
            }
            this._index++;
        }
        this.cleanup();
    };
    Tokenizer.prototype.finish = function () {
        // If there is remaining data, emit it in a reasonable way
        if (this.sectionStart < this._index) {
            this.handleTrailingData();
        }
        this.cbs.onend();
    };
    Tokenizer.prototype.handleTrailingData = function () {
        var data = this.buffer.substr(this.sectionStart);
        if (this._state === 29 /* InCdata */ ||
            this._state === 30 /* AfterCdata1 */ ||
            this._state === 31 /* AfterCdata2 */) {
            this.cbs.oncdata(data);
        }
        else if (this._state === 19 /* InComment */ ||
            this._state === 21 /* AfterComment1 */ ||
            this._state === 22 /* AfterComment2 */) {
            this.cbs.oncomment(data);
        }
        else if (this._state === 64 /* InNamedEntity */ && !this.xmlMode) {
            this.parseLegacyEntity();
            if (this.sectionStart < this._index) {
                this._state = this.baseState;
                this.handleTrailingData();
            }
        }
        else if (this._state === 65 /* InNumericEntity */ && !this.xmlMode) {
            this.decodeNumericEntity(2, 10, false);
            if (this.sectionStart < this._index) {
                this._state = this.baseState;
                this.handleTrailingData();
            }
        }
        else if (this._state === 66 /* InHexEntity */ && !this.xmlMode) {
            this.decodeNumericEntity(3, 16, false);
            if (this.sectionStart < this._index) {
                this._state = this.baseState;
                this.handleTrailingData();
            }
        }
        else if (this._state !== 3 /* InTagName */ &&
            this._state !== 8 /* BeforeAttributeName */ &&
            this._state !== 11 /* BeforeAttributeValue */ &&
            this._state !== 10 /* AfterAttributeName */ &&
            this._state !== 9 /* InAttributeName */ &&
            this._state !== 13 /* InAttributeValueSq */ &&
            this._state !== 12 /* InAttributeValueDq */ &&
            this._state !== 14 /* InAttributeValueNq */ &&
            this._state !== 6 /* InClosingTagName */) {
            this.cbs.ontext(data);
        }
        /*
         * Else, ignore remaining data
         * TODO add a way to remove current tag
         */
    };
    Tokenizer.prototype.getSection = function () {
        return this.buffer.substring(this.sectionStart, this._index);
    };
    Tokenizer.prototype.emitToken = function (name) {
        this.cbs[name](this.getSection());
        this.sectionStart = -1;
    };
    Tokenizer.prototype.emitPartial = function (value) {
        if (this.baseState !== 1 /* Text */) {
            this.cbs.onattribdata(value); // TODO implement the new event
        }
        else {
            this.cbs.ontext(value);
        }
    };
    return Tokenizer;
}());
exports["default"] = Tokenizer;


/***/ }),

/***/ 3719:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RssHandler = exports.DefaultHandler = exports.DomUtils = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.parseDOM = exports.parseDocument = exports.DomHandler = exports.Parser = void 0;
var Parser_1 = __webpack_require__(763);
Object.defineProperty(exports, "Parser", ({ enumerable: true, get: function () { return Parser_1.Parser; } }));
var domhandler_1 = __webpack_require__(7915);
Object.defineProperty(exports, "DomHandler", ({ enumerable: true, get: function () { return domhandler_1.DomHandler; } }));
Object.defineProperty(exports, "DefaultHandler", ({ enumerable: true, get: function () { return domhandler_1.DomHandler; } }));
// Helper methods
/**
 * Parses the data, returns the resulting document.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 */
function parseDocument(data, options) {
    var handler = new domhandler_1.DomHandler(undefined, options);
    new Parser_1.Parser(handler, options).end(data);
    return handler.root;
}
exports.parseDocument = parseDocument;
/**
 * Parses data, returns an array of the root nodes.
 *
 * Note that the root nodes still have a `Document` node as their parent.
 * Use `parseDocument` to get the `Document` node instead.
 *
 * @param data The data that should be parsed.
 * @param options Optional options for the parser and DOM builder.
 * @deprecated Use `parseDocument` instead.
 */
function parseDOM(data, options) {
    return parseDocument(data, options).children;
}
exports.parseDOM = parseDOM;
/**
 * Creates a parser instance, with an attached DOM handler.
 *
 * @param cb A callback that will be called once parsing has been completed.
 * @param options Optional options for the parser and DOM builder.
 * @param elementCb An optional callback that will be called every time a tag has been completed inside of the DOM.
 */
function createDomStream(cb, options, elementCb) {
    var handler = new domhandler_1.DomHandler(cb, options, elementCb);
    return new Parser_1.Parser(handler, options);
}
exports.createDomStream = createDomStream;
var Tokenizer_1 = __webpack_require__(9889);
Object.defineProperty(exports, "Tokenizer", ({ enumerable: true, get: function () { return __importDefault(Tokenizer_1).default; } }));
var ElementType = __importStar(__webpack_require__(9960));
exports.ElementType = ElementType;
/*
 * All of the following exports exist for backwards-compatibility.
 * They should probably be removed eventually.
 */
__exportStar(__webpack_require__(3870), exports);
exports.DomUtils = __importStar(__webpack_require__(9432));
var FeedHandler_1 = __webpack_require__(3870);
Object.defineProperty(exports, "RssHandler", ({ enumerable: true, get: function () { return FeedHandler_1.FeedHandler; } }));


/***/ }),

/***/ 8552:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ 1989:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(1789),
    hashDelete = __webpack_require__(401),
    hashGet = __webpack_require__(7667),
    hashHas = __webpack_require__(1327),
    hashSet = __webpack_require__(1866);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ 8407:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(7040),
    listCacheDelete = __webpack_require__(4125),
    listCacheGet = __webpack_require__(2117),
    listCacheHas = __webpack_require__(7518),
    listCacheSet = __webpack_require__(4705);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ 7071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ 3369:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(4785),
    mapCacheDelete = __webpack_require__(1285),
    mapCacheGet = __webpack_require__(6000),
    mapCacheHas = __webpack_require__(9916),
    mapCacheSet = __webpack_require__(5265);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ 3818:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ 8525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ 8668:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(3369),
    setCacheAdd = __webpack_require__(619),
    setCacheHas = __webpack_require__(2385);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ 6384:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(8407),
    stackClear = __webpack_require__(7465),
    stackDelete = __webpack_require__(3779),
    stackGet = __webpack_require__(7599),
    stackHas = __webpack_require__(4758),
    stackSet = __webpack_require__(4309);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ 2705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(5639);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ 1149:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(5639);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ 577:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ 7412:
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ 4963:
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ 4636:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(2545),
    isArguments = __webpack_require__(5694),
    isArray = __webpack_require__(1469),
    isBuffer = __webpack_require__(4144),
    isIndex = __webpack_require__(5776),
    isTypedArray = __webpack_require__(6719);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ 9932:
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ 2488:
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ 2908:
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ 8470:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(7813);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ 9881:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseForOwn = __webpack_require__(7816),
    createBaseEach = __webpack_require__(9291);

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),

/***/ 6029:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(3448);

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

module.exports = baseExtremum;


/***/ }),

/***/ 760:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(9881);

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;


/***/ }),

/***/ 1848:
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ 5744:
/***/ ((module) => {

/**
 * The base implementation of methods like `_.findKey` and `_.findLastKey`,
 * without support for iteratee shorthands, which iterates over `collection`
 * using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the found element or its key, else `undefined`.
 */
function baseFindKey(collection, predicate, eachFunc) {
  var result;
  eachFunc(collection, function(value, key, collection) {
    if (predicate(value, key, collection)) {
      result = key;
      return false;
    }
  });
  return result;
}

module.exports = baseFindKey;


/***/ }),

/***/ 8483:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(5063);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ 7816:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(8483),
    keys = __webpack_require__(3674);

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),

/***/ 7786:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(1811),
    toKey = __webpack_require__(327);

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ 8866:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(2488),
    isArray = __webpack_require__(1469);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ 4239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(2705),
    getRawTag = __webpack_require__(9607),
    objectToString = __webpack_require__(2333);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ 3325:
/***/ ((module) => {

/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

module.exports = baseGt;


/***/ }),

/***/ 13:
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ 2118:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(1848),
    baseIsNaN = __webpack_require__(2722),
    strictIndexOf = __webpack_require__(2351);

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),

/***/ 9454:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(4239),
    isObjectLike = __webpack_require__(7005);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ 939:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(2492),
    isObjectLike = __webpack_require__(7005);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ 2492:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(6384),
    equalArrays = __webpack_require__(7114),
    equalByTag = __webpack_require__(8351),
    equalObjects = __webpack_require__(6096),
    getTag = __webpack_require__(4160),
    isArray = __webpack_require__(1469),
    isBuffer = __webpack_require__(4144),
    isTypedArray = __webpack_require__(6719);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ 2958:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(6384),
    baseIsEqual = __webpack_require__(939);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ 2722:
/***/ ((module) => {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),

/***/ 8458:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(3560),
    isMasked = __webpack_require__(5346),
    isObject = __webpack_require__(3218),
    toSource = __webpack_require__(346);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ 8749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(4239),
    isLength = __webpack_require__(1780),
    isObjectLike = __webpack_require__(7005);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ 7206:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMatches = __webpack_require__(1573),
    baseMatchesProperty = __webpack_require__(6432),
    identity = __webpack_require__(6557),
    isArray = __webpack_require__(1469),
    property = __webpack_require__(9601);

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ 280:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(5726),
    nativeKeys = __webpack_require__(6916);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ 9199:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(9881),
    isArrayLike = __webpack_require__(8612);

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),

/***/ 1573:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__(2958),
    getMatchData = __webpack_require__(1499),
    matchesStrictComparable = __webpack_require__(2634);

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ 6432:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(939),
    get = __webpack_require__(7361),
    hasIn = __webpack_require__(9095),
    isKey = __webpack_require__(5403),
    isStrictComparable = __webpack_require__(9162),
    matchesStrictComparable = __webpack_require__(2634),
    toKey = __webpack_require__(327);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ 371:
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ 9152:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(7786);

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ 2545:
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ 531:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(2705),
    arrayMap = __webpack_require__(9932),
    isArray = __webpack_require__(1469),
    isSymbol = __webpack_require__(3448);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ 7561:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__(7990);

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ 1717:
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ 4757:
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ 4290:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(6557);

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),

/***/ 1811:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(1469),
    isKey = __webpack_require__(5403),
    stringToPath = __webpack_require__(5514),
    toString = __webpack_require__(9833);

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ 4429:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(5639);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ 9291:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(8612);

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),

/***/ 5063:
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ 7740:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIteratee = __webpack_require__(7206),
    isArrayLike = __webpack_require__(8612),
    keys = __webpack_require__(3674);

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;


/***/ }),

/***/ 7114:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(8668),
    arraySome = __webpack_require__(2908),
    cacheHas = __webpack_require__(4757);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ 8351:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(2705),
    Uint8Array = __webpack_require__(1149),
    eq = __webpack_require__(7813),
    equalArrays = __webpack_require__(7114),
    mapToArray = __webpack_require__(8776),
    setToArray = __webpack_require__(1814);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ 6096:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(8234);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ 1957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ 8234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(8866),
    getSymbols = __webpack_require__(9551),
    keys = __webpack_require__(3674);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ 5050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(7019);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ 1499:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__(9162),
    keys = __webpack_require__(3674);

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ 852:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(8458),
    getValue = __webpack_require__(7801);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ 9607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(2705);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ 9551:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(4963),
    stubArray = __webpack_require__(479);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ 4160:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(8552),
    Map = __webpack_require__(7071),
    Promise = __webpack_require__(3818),
    Set = __webpack_require__(8525),
    WeakMap = __webpack_require__(577),
    baseGetTag = __webpack_require__(4239),
    toSource = __webpack_require__(346);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ 7801:
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ 222:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(1811),
    isArguments = __webpack_require__(5694),
    isArray = __webpack_require__(1469),
    isIndex = __webpack_require__(5776),
    isLength = __webpack_require__(1780),
    toKey = __webpack_require__(327);

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ 1789:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4536);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ 401:
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ 7667:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4536);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ 1327:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4536);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ 1866:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4536);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ 5776:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ 5403:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(1469),
    isSymbol = __webpack_require__(3448);

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ 7019:
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ 5346:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(4429);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ 5726:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ 9162:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(3218);

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ 7040:
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ 4125:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(8470);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ 2117:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(8470);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ 7518:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(8470);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ 4705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(8470);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ 4785:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(1989),
    ListCache = __webpack_require__(8407),
    Map = __webpack_require__(7071);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ 1285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(5050);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ 6000:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(5050);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ 9916:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(5050);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ 5265:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(5050);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ 8776:
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ 2634:
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ 4523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__(8306);

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ 4536:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ 6916:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(5569);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ 1167:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(1957);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ 2333:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ 5569:
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ 5639:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(1957);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ 619:
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ 2385:
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ 1814:
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ 7465:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(8407);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ 3779:
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ 7599:
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ 4758:
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ 4309:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(8407),
    Map = __webpack_require__(7071),
    MapCache = __webpack_require__(3369);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ 2351:
/***/ ((module) => {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),

/***/ 5514:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__(4523);

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ 327:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(3448);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ 346:
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ 7990:
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ 7813:
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ 3105:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(4963),
    baseFilter = __webpack_require__(760),
    baseIteratee = __webpack_require__(7206),
    isArray = __webpack_require__(1469);

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 *
 * // Combining several predicates using `_.overEvery` or `_.overSome`.
 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
 * // => objects for ['fred', 'barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;


/***/ }),

/***/ 3311:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createFind = __webpack_require__(7740),
    findIndex = __webpack_require__(998);

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;


/***/ }),

/***/ 998:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(1848),
    baseIteratee = __webpack_require__(7206),
    toInteger = __webpack_require__(554);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),

/***/ 894:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindKey = __webpack_require__(5744),
    baseForOwn = __webpack_require__(7816),
    baseIteratee = __webpack_require__(7206);

/**
 * This method is like `_.find` except that it returns the key of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Object
 * @param {Object} object The object to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {string|undefined} Returns the key of the matched element,
 *  else `undefined`.
 * @example
 *
 * var users = {
 *   'barney':  { 'age': 36, 'active': true },
 *   'fred':    { 'age': 40, 'active': false },
 *   'pebbles': { 'age': 1,  'active': true }
 * };
 *
 * _.findKey(users, function(o) { return o.age < 40; });
 * // => 'barney' (iteration order is not guaranteed)
 *
 * // The `_.matches` iteratee shorthand.
 * _.findKey(users, { 'age': 1, 'active': true });
 * // => 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findKey(users, ['active', false]);
 * // => 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.findKey(users, 'active');
 * // => 'barney'
 */
function findKey(object, predicate) {
  return baseFindKey(object, baseIteratee(predicate, 3), baseForOwn);
}

module.exports = findKey;


/***/ }),

/***/ 4486:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(7412),
    baseEach = __webpack_require__(9881),
    castFunction = __webpack_require__(4290),
    isArray = __webpack_require__(1469);

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;


/***/ }),

/***/ 7361:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(7786);

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ 9095:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHasIn = __webpack_require__(13),
    hasPath = __webpack_require__(222);

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ 6557:
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ 3651:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIndexOf = __webpack_require__(2118),
    toInteger = __webpack_require__(554);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */
function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseIndexOf(array, value, index);
}

module.exports = indexOf;


/***/ }),

/***/ 5694:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(9454),
    isObjectLike = __webpack_require__(7005);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ 1469:
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ 8612:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(3560),
    isLength = __webpack_require__(1780);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ 4144:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(5639),
    stubFalse = __webpack_require__(5062);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ 3560:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(4239),
    isObject = __webpack_require__(3218);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ 1780:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ 3218:
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ 7005:
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ 3448:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(4239),
    isObjectLike = __webpack_require__(7005);

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ 6719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(8749),
    baseUnary = __webpack_require__(1717),
    nodeUtil = __webpack_require__(1167);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ 3674:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(4636),
    baseKeys = __webpack_require__(280),
    isArrayLike = __webpack_require__(8612);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ 5161:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(9932),
    baseIteratee = __webpack_require__(7206),
    baseMap = __webpack_require__(9199),
    isArray = __webpack_require__(1469);

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;


/***/ }),

/***/ 6162:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseExtremum = __webpack_require__(6029),
    baseGt = __webpack_require__(3325),
    identity = __webpack_require__(6557);

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseGt)
    : undefined;
}

module.exports = max;


/***/ }),

/***/ 8306:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(3369);

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ 9601:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(371),
    basePropertyDeep = __webpack_require__(9152),
    isKey = __webpack_require__(5403),
    toKey = __webpack_require__(327);

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ 479:
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ 5062:
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ 8601:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toNumber = __webpack_require__(4841);

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),

/***/ 554:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toFinite = __webpack_require__(8601);

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),

/***/ 4841:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTrim = __webpack_require__(7561),
    isObject = __webpack_require__(3218),
    isSymbol = __webpack_require__(3448);

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ 9833:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(531);

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ 9430:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Srcset Parser
 *
 * By Alex Bell |  MIT License
 *
 * JS Parser for the string value that appears in markup <img srcset="here">
 *
 * @returns Array [{url: _, d: _, w: _, h:_}, ...]
 *
 * Based super duper closely on the reference algorithm at:
 * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute
 *
 * Most comments are copied in directly from the spec
 * (except for comments in parens).
 */

(function (root, factory) {
	if (true) {
		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}(this, function () {

	// 1. Let input be the value passed to this algorithm.
	return function (input) {

		// UTILITY FUNCTIONS

		// Manual is faster than RegEx
		// http://bjorn.tipling.com/state-and-regular-expressions-in-javascript
		// http://jsperf.com/whitespace-character/5
		function isSpace(c) {
			return (c === "\u0020" || // space
			c === "\u0009" || // horizontal tab
			c === "\u000A" || // new line
			c === "\u000C" || // form feed
			c === "\u000D");  // carriage return
		}

		function collectCharacters(regEx) {
			var chars,
				match = regEx.exec(input.substring(pos));
			if (match) {
				chars = match[ 0 ];
				pos += chars.length;
				return chars;
			}
		}

		var inputLength = input.length,

			// (Don't use \s, to avoid matching non-breaking space)
			regexLeadingSpaces = /^[ \t\n\r\u000c]+/,
			regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/,
			regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/,
			regexTrailingCommas = /[,]+$/,
			regexNonNegativeInteger = /^\d+$/,

			// ( Positive or negative or unsigned integers or decimals, without or without exponents.
			// Must include at least one digit.
			// According to spec tests any decimal point must be followed by a digit.
			// No leading plus sign is allowed.)
			// https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number
			regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,

			url,
			descriptors,
			currentDescriptor,
			state,
			c,

			// 2. Let position be a pointer into input, initially pointing at the start
			//    of the string.
			pos = 0,

			// 3. Let candidates be an initially empty source set.
			candidates = [];

		// 4. Splitting loop: Collect a sequence of characters that are space
		//    characters or U+002C COMMA characters. If any U+002C COMMA characters
		//    were collected, that is a parse error.
		while (true) {
			collectCharacters(regexLeadingCommasOrSpaces);

			// 5. If position is past the end of input, return candidates and abort these steps.
			if (pos >= inputLength) {
				return candidates; // (we're done, this is the sole return path)
			}

			// 6. Collect a sequence of characters that are not space characters,
			//    and let that be url.
			url = collectCharacters(regexLeadingNotSpaces);

			// 7. Let descriptors be a new empty list.
			descriptors = [];

			// 8. If url ends with a U+002C COMMA character (,), follow these substeps:
			//		(1). Remove all trailing U+002C COMMA characters from url. If this removed
			//         more than one character, that is a parse error.
			if (url.slice(-1) === ",") {
				url = url.replace(regexTrailingCommas, "");
				// (Jump ahead to step 9 to skip tokenization and just push the candidate).
				parseDescriptors();

				//	Otherwise, follow these substeps:
			} else {
				tokenize();
			} // (close else of step 8)

			// 16. Return to the step labeled splitting loop.
		} // (Close of big while loop.)

		/**
		 * Tokenizes descriptor properties prior to parsing
		 * Returns undefined.
		 */
		function tokenize() {

			// 8.1. Descriptor tokeniser: Skip whitespace
			collectCharacters(regexLeadingSpaces);

			// 8.2. Let current descriptor be the empty string.
			currentDescriptor = "";

			// 8.3. Let state be in descriptor.
			state = "in descriptor";

			while (true) {

				// 8.4. Let c be the character at position.
				c = input.charAt(pos);

				//  Do the following depending on the value of state.
				//  For the purpose of this step, "EOF" is a special character representing
				//  that position is past the end of input.

				// In descriptor
				if (state === "in descriptor") {
					// Do the following, depending on the value of c:

					// Space character
					// If current descriptor is not empty, append current descriptor to
					// descriptors and let current descriptor be the empty string.
					// Set state to after descriptor.
					if (isSpace(c)) {
						if (currentDescriptor) {
							descriptors.push(currentDescriptor);
							currentDescriptor = "";
							state = "after descriptor";
						}

						// U+002C COMMA (,)
						// Advance position to the next character in input. If current descriptor
						// is not empty, append current descriptor to descriptors. Jump to the step
						// labeled descriptor parser.
					} else if (c === ",") {
						pos += 1;
						if (currentDescriptor) {
							descriptors.push(currentDescriptor);
						}
						parseDescriptors();
						return;

						// U+0028 LEFT PARENTHESIS (()
						// Append c to current descriptor. Set state to in parens.
					} else if (c === "\u0028") {
						currentDescriptor = currentDescriptor + c;
						state = "in parens";

						// EOF
						// If current descriptor is not empty, append current descriptor to
						// descriptors. Jump to the step labeled descriptor parser.
					} else if (c === "") {
						if (currentDescriptor) {
							descriptors.push(currentDescriptor);
						}
						parseDescriptors();
						return;

						// Anything else
						// Append c to current descriptor.
					} else {
						currentDescriptor = currentDescriptor + c;
					}
					// (end "in descriptor"

					// In parens
				} else if (state === "in parens") {

					// U+0029 RIGHT PARENTHESIS ())
					// Append c to current descriptor. Set state to in descriptor.
					if (c === ")") {
						currentDescriptor = currentDescriptor + c;
						state = "in descriptor";

						// EOF
						// Append current descriptor to descriptors. Jump to the step labeled
						// descriptor parser.
					} else if (c === "") {
						descriptors.push(currentDescriptor);
						parseDescriptors();
						return;

						// Anything else
						// Append c to current descriptor.
					} else {
						currentDescriptor = currentDescriptor + c;
					}

					// After descriptor
				} else if (state === "after descriptor") {

					// Do the following, depending on the value of c:
					// Space character: Stay in this state.
					if (isSpace(c)) {

						// EOF: Jump to the step labeled descriptor parser.
					} else if (c === "") {
						parseDescriptors();
						return;

						// Anything else
						// Set state to in descriptor. Set position to the previous character in input.
					} else {
						state = "in descriptor";
						pos -= 1;

					}
				}

				// Advance position to the next character in input.
				pos += 1;

				// Repeat this step.
			} // (close while true loop)
		}

		/**
		 * Adds descriptor properties to a candidate, pushes to the candidates array
		 * @return undefined
		 */
		// Declared outside of the while loop so that it's only created once.
		function parseDescriptors() {

			// 9. Descriptor parser: Let error be no.
			var pError = false,

				// 10. Let width be absent.
				// 11. Let density be absent.
				// 12. Let future-compat-h be absent. (We're implementing it now as h)
				w, d, h, i,
				candidate = {},
				desc, lastChar, value, intVal, floatVal;

			// 13. For each descriptor in descriptors, run the appropriate set of steps
			// from the following list:
			for (i = 0 ; i < descriptors.length; i++) {
				desc = descriptors[ i ];

				lastChar = desc[ desc.length - 1 ];
				value = desc.substring(0, desc.length - 1);
				intVal = parseInt(value, 10);
				floatVal = parseFloat(value);

				// If the descriptor consists of a valid non-negative integer followed by
				// a U+0077 LATIN SMALL LETTER W character
				if (regexNonNegativeInteger.test(value) && (lastChar === "w")) {

					// If width and density are not both absent, then let error be yes.
					if (w || d) {pError = true;}

					// Apply the rules for parsing non-negative integers to the descriptor.
					// If the result is zero, let error be yes.
					// Otherwise, let width be the result.
					if (intVal === 0) {pError = true;} else {w = intVal;}

					// If the descriptor consists of a valid floating-point number followed by
					// a U+0078 LATIN SMALL LETTER X character
				} else if (regexFloatingPoint.test(value) && (lastChar === "x")) {

					// If width, density and future-compat-h are not all absent, then let error
					// be yes.
					if (w || d || h) {pError = true;}

					// Apply the rules for parsing floating-point number values to the descriptor.
					// If the result is less than zero, let error be yes. Otherwise, let density
					// be the result.
					if (floatVal < 0) {pError = true;} else {d = floatVal;}

					// If the descriptor consists of a valid non-negative integer followed by
					// a U+0068 LATIN SMALL LETTER H character
				} else if (regexNonNegativeInteger.test(value) && (lastChar === "h")) {

					// If height and density are not both absent, then let error be yes.
					if (h || d) {pError = true;}

					// Apply the rules for parsing non-negative integers to the descriptor.
					// If the result is zero, let error be yes. Otherwise, let future-compat-h
					// be the result.
					if (intVal === 0) {pError = true;} else {h = intVal;}

					// Anything else, Let error be yes.
				} else {pError = true;}
			} // (close step 13 for loop)

			// 15. If error is still no, then append a new image source to candidates whose
			// URL is url, associated with a width width if not absent and a pixel
			// density density if not absent. Otherwise, there is a parse error.
			if (!pError) {
				candidate.url = url;
				if (w) { candidate.w = w;}
				if (d) { candidate.d = d;}
				if (h) { candidate.h = h;}
				candidates.push(candidate);
			} else if (console && console.log) {
				console.log("Invalid srcset descriptor found in '" +
					input + "' at '" + desc + "'.");
			}
		} // (close parseDescriptors fn)

	}
}));


/***/ }),

/***/ 4241:
/***/ ((module) => {

var x=String;
var create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x}};
module.exports=create();
module.exports.createColors = create;


/***/ }),

/***/ 1353:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(1019)

class AtRule extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'atrule'
  }

  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.append(...children)
  }

  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.prepend(...children)
  }
}

module.exports = AtRule
AtRule.default = AtRule

Container.registerAtRule(AtRule)


/***/ }),

/***/ 7923:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Node = __webpack_require__(5631)

class Comment extends Node {
  constructor(defaults) {
    super(defaults)
    this.type = 'comment'
  }
}

module.exports = Comment
Comment.default = Comment


/***/ }),

/***/ 1019:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { isClean, my } = __webpack_require__(5513)
let Declaration = __webpack_require__(4258)
let Comment = __webpack_require__(7923)
let Node = __webpack_require__(5631)

let parse, Rule, AtRule

function cleanSource(nodes) {
  return nodes.map(i => {
    if (i.nodes) i.nodes = cleanSource(i.nodes)
    delete i.source
    return i
  })
}

function markDirtyUp(node) {
  node[isClean] = false
  if (node.proxyOf.nodes) {
    for (let i of node.proxyOf.nodes) {
      markDirtyUp(i)
    }
  }
}

class Container extends Node {
  push(child) {
    child.parent = this
    this.proxyOf.nodes.push(child)
    return this
  }

  each(callback) {
    if (!this.proxyOf.nodes) return undefined
    let iterator = this.getIterator()

    let index, result
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index = this.indexes[iterator]
      result = callback(this.proxyOf.nodes[index], index)
      if (result === false) break

      this.indexes[iterator] += 1
    }

    delete this.indexes[iterator]
    return result
  }

  walk(callback) {
    return this.each((child, i) => {
      let result
      try {
        result = callback(child, i)
      } catch (e) {
        throw child.addToError(e)
      }
      if (result !== false && child.walk) {
        result = child.walk(callback)
      }

      return result
    })
  }

  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop
      return this.walk((child, i) => {
        if (child.type === 'decl') {
          return callback(child, i)
        }
      })
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'decl' && prop.test(child.prop)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'decl' && child.prop === prop) {
        return callback(child, i)
      }
    })
  }

  walkRules(selector, callback) {
    if (!callback) {
      callback = selector

      return this.walk((child, i) => {
        if (child.type === 'rule') {
          return callback(child, i)
        }
      })
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'rule' && selector.test(child.selector)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'rule' && child.selector === selector) {
        return callback(child, i)
      }
    })
  }

  walkAtRules(name, callback) {
    if (!callback) {
      callback = name
      return this.walk((child, i) => {
        if (child.type === 'atrule') {
          return callback(child, i)
        }
      })
    }
    if (name instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'atrule' && name.test(child.name)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'atrule' && child.name === name) {
        return callback(child, i)
      }
    })
  }

  walkComments(callback) {
    return this.walk((child, i) => {
      if (child.type === 'comment') {
        return callback(child, i)
      }
    })
  }

  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last)
      for (let node of nodes) this.proxyOf.nodes.push(node)
    }

    this.markDirty()

    return this
  }

  prepend(...children) {
    children = children.reverse()
    for (let child of children) {
      let nodes = this.normalize(child, this.first, 'prepend').reverse()
      for (let node of nodes) this.proxyOf.nodes.unshift(node)
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween)
    if (this.nodes) {
      for (let node of this.nodes) node.cleanRaws(keepBetween)
    }
  }

  insertBefore(exist, add) {
    exist = this.index(exist)

    let type = exist === 0 ? 'prepend' : false
    let nodes = this.normalize(add, this.proxyOf.nodes[exist], type).reverse()
    for (let node of nodes) this.proxyOf.nodes.splice(exist, 0, node)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (exist <= index) {
        this.indexes[id] = index + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  insertAfter(exist, add) {
    exist = this.index(exist)

    let nodes = this.normalize(add, this.proxyOf.nodes[exist]).reverse()
    for (let node of nodes) this.proxyOf.nodes.splice(exist + 1, 0, node)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (exist < index) {
        this.indexes[id] = index + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  removeChild(child) {
    child = this.index(child)
    this.proxyOf.nodes[child].parent = undefined
    this.proxyOf.nodes.splice(child, 1)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (index >= child) {
        this.indexes[id] = index - 1
      }
    }

    this.markDirty()

    return this
  }

  removeAll() {
    for (let node of this.proxyOf.nodes) node.parent = undefined
    this.proxyOf.nodes = []

    this.markDirty()

    return this
  }

  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts
      opts = {}
    }

    this.walkDecls(decl => {
      if (opts.props && !opts.props.includes(decl.prop)) return
      if (opts.fast && !decl.value.includes(opts.fast)) return

      decl.value = decl.value.replace(pattern, callback)
    })

    this.markDirty()

    return this
  }

  every(condition) {
    return this.nodes.every(condition)
  }

  some(condition) {
    return this.nodes.some(condition)
  }

  index(child) {
    if (typeof child === 'number') return child
    if (child.proxyOf) child = child.proxyOf
    return this.proxyOf.nodes.indexOf(child)
  }

  get first() {
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[0]
  }

  get last() {
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]
  }

  normalize(nodes, sample) {
    if (typeof nodes === 'string') {
      nodes = cleanSource(parse(nodes).nodes)
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0)
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore')
      }
    } else if (nodes.type === 'root' && this.type !== 'document') {
      nodes = nodes.nodes.slice(0)
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore')
      }
    } else if (nodes.type) {
      nodes = [nodes]
    } else if (nodes.prop) {
      if (typeof nodes.value === 'undefined') {
        throw new Error('Value field is missed in node creation')
      } else if (typeof nodes.value !== 'string') {
        nodes.value = String(nodes.value)
      }
      nodes = [new Declaration(nodes)]
    } else if (nodes.selector) {
      nodes = [new Rule(nodes)]
    } else if (nodes.name) {
      nodes = [new AtRule(nodes)]
    } else if (nodes.text) {
      nodes = [new Comment(nodes)]
    } else {
      throw new Error('Unknown node type in node creation')
    }

    let processed = nodes.map(i => {
      // istanbul ignore next
      if (!i[my]) Container.rebuild(i)
      i = i.proxyOf
      if (i.parent) i.parent.removeChild(i)
      if (i[isClean]) markDirtyUp(i)
      if (typeof i.raws.before === 'undefined') {
        if (sample && typeof sample.raws.before !== 'undefined') {
          i.raws.before = sample.raws.before.replace(/\S/g, '')
        }
      }
      i.parent = this
      return i
    })

    return processed
  }

  getProxyProcessor() {
    return {
      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (prop === 'name' || prop === 'params' || prop === 'selector') {
          node.markDirty()
        }
        return true
      },

      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        } else if (!node[prop]) {
          return node[prop]
        } else if (
          prop === 'each' ||
          (typeof prop === 'string' && prop.startsWith('walk'))
        ) {
          return (...args) => {
            return node[prop](
              ...args.map(i => {
                if (typeof i === 'function') {
                  return (child, index) => i(child.toProxy(), index)
                } else {
                  return i
                }
              })
            )
          }
        } else if (prop === 'every' || prop === 'some') {
          return cb => {
            return node[prop]((child, ...other) =>
              cb(child.toProxy(), ...other)
            )
          }
        } else if (prop === 'root') {
          return () => node.root().toProxy()
        } else if (prop === 'nodes') {
          return node.nodes.map(i => i.toProxy())
        } else if (prop === 'first' || prop === 'last') {
          return node[prop].toProxy()
        } else {
          return node[prop]
        }
      }
    }
  }

  getIterator() {
    if (!this.lastEach) this.lastEach = 0
    if (!this.indexes) this.indexes = {}

    this.lastEach += 1
    let iterator = this.lastEach
    this.indexes[iterator] = 0

    return iterator
  }
}

Container.registerParse = dependant => {
  parse = dependant
}

Container.registerRule = dependant => {
  Rule = dependant
}

Container.registerAtRule = dependant => {
  AtRule = dependant
}

module.exports = Container
Container.default = Container

// istanbul ignore next
Container.rebuild = node => {
  if (node.type === 'atrule') {
    Object.setPrototypeOf(node, AtRule.prototype)
  } else if (node.type === 'rule') {
    Object.setPrototypeOf(node, Rule.prototype)
  } else if (node.type === 'decl') {
    Object.setPrototypeOf(node, Declaration.prototype)
  } else if (node.type === 'comment') {
    Object.setPrototypeOf(node, Comment.prototype)
  }

  node[my] = true

  if (node.nodes) {
    node.nodes.forEach(child => {
      Container.rebuild(child)
    })
  }
}


/***/ }),

/***/ 2671:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let pico = __webpack_require__(4241)

let terminalHighlight = __webpack_require__(2868)

class CssSyntaxError extends Error {
  constructor(message, line, column, source, file, plugin) {
    super(message)
    this.name = 'CssSyntaxError'
    this.reason = message

    if (file) {
      this.file = file
    }
    if (source) {
      this.source = source
    }
    if (plugin) {
      this.plugin = plugin
    }
    if (typeof line !== 'undefined' && typeof column !== 'undefined') {
      this.line = line
      this.column = column
    }

    this.setMessage()

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError)
    }
  }

  setMessage() {
    this.message = this.plugin ? this.plugin + ': ' : ''
    this.message += this.file ? this.file : '<css input>'
    if (typeof this.line !== 'undefined') {
      this.message += ':' + this.line + ':' + this.column
    }
    this.message += ': ' + this.reason
  }

  showSourceCode(color) {
    if (!this.source) return ''

    let css = this.source
    if (color == null) color = pico.isColorSupported
    if (terminalHighlight) {
      if (color) css = terminalHighlight(css)
    }

    let lines = css.split(/\r?\n/)
    let start = Math.max(this.line - 3, 0)
    let end = Math.min(this.line + 2, lines.length)

    let maxWidth = String(end).length

    let mark, aside
    if (color) {
      let { bold, red, gray } = pico.createColors(true)
      mark = text => bold(red(text))
      aside = text => gray(text)
    } else {
      mark = aside = str => str
    }

    return lines
      .slice(start, end)
      .map((line, index) => {
        let number = start + 1 + index
        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | '
        if (number === this.line) {
          let spacing =
            aside(gutter.replace(/\d/g, ' ')) +
            line.slice(0, this.column - 1).replace(/[^\t]/g, ' ')
          return mark('>') + aside(gutter) + line + '\n ' + spacing + mark('^')
        }
        return ' ' + aside(gutter) + line
      })
      .join('\n')
  }

  toString() {
    let code = this.showSourceCode()
    if (code) {
      code = '\n\n' + code + '\n'
    }
    return this.name + ': ' + this.message + code
  }
}

module.exports = CssSyntaxError
CssSyntaxError.default = CssSyntaxError


/***/ }),

/***/ 4258:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Node = __webpack_require__(5631)

class Declaration extends Node {
  constructor(defaults) {
    if (
      defaults &&
      typeof defaults.value !== 'undefined' &&
      typeof defaults.value !== 'string'
    ) {
      defaults = { ...defaults, value: String(defaults.value) }
    }
    super(defaults)
    this.type = 'decl'
  }

  get variable() {
    return this.prop.startsWith('--') || this.prop[0] === '$'
  }
}

module.exports = Declaration
Declaration.default = Declaration


/***/ }),

/***/ 6461:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(1019)

let LazyResult, Processor

class Document extends Container {
  constructor(defaults) {
    // type needs to be passed to super, otherwise child roots won't be normalized correctly
    super({ type: 'document', ...defaults })

    if (!this.nodes) {
      this.nodes = []
    }
  }

  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts)

    return lazy.stringify()
  }
}

Document.registerLazyResult = dependant => {
  LazyResult = dependant
}

Document.registerProcessor = dependant => {
  Processor = dependant
}

module.exports = Document
Document.default = Document


/***/ }),

/***/ 250:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Declaration = __webpack_require__(4258)
let PreviousMap = __webpack_require__(7981)
let Comment = __webpack_require__(7923)
let AtRule = __webpack_require__(1353)
let Input = __webpack_require__(5995)
let Root = __webpack_require__(1025)
let Rule = __webpack_require__(1675)

function fromJSON(json, inputs) {
  if (Array.isArray(json)) return json.map(n => fromJSON(n))

  let { inputs: ownInputs, ...defaults } = json
  if (ownInputs) {
    inputs = []
    for (let input of ownInputs) {
      let inputHydrated = { ...input, __proto__: Input.prototype }
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap.prototype
        }
      }
      inputs.push(inputHydrated)
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs))
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source
    defaults.source = source
    if (inputId != null) {
      defaults.source.input = inputs[inputId]
    }
  }
  if (defaults.type === 'root') {
    return new Root(defaults)
  } else if (defaults.type === 'decl') {
    return new Declaration(defaults)
  } else if (defaults.type === 'rule') {
    return new Rule(defaults)
  } else if (defaults.type === 'comment') {
    return new Comment(defaults)
  } else if (defaults.type === 'atrule') {
    return new AtRule(defaults)
  } else {
    throw new Error('Unknown node type: ' + json.type)
  }
}

module.exports = fromJSON
fromJSON.default = fromJSON


/***/ }),

/***/ 5995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(209)
let { fileURLToPath, pathToFileURL } = __webpack_require__(7414)
let { resolve, isAbsolute } = __webpack_require__(9830)
let { nanoid } = __webpack_require__(2961)

let terminalHighlight = __webpack_require__(2868)
let CssSyntaxError = __webpack_require__(2671)
let PreviousMap = __webpack_require__(7981)

let fromOffsetCache = Symbol('fromOffsetCache')

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(resolve && isAbsolute)

class Input {
  constructor(css, opts = {}) {
    if (
      css === null ||
      typeof css === 'undefined' ||
      (typeof css === 'object' && !css.toString)
    ) {
      throw new Error(`PostCSS received ${css} instead of CSS string`)
    }

    this.css = css.toString()

    if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
      this.hasBOM = true
      this.css = this.css.slice(1)
    } else {
      this.hasBOM = false
    }

    if (opts.from) {
      if (
        !pathAvailable ||
        /^\w+:\/\//.test(opts.from) ||
        isAbsolute(opts.from)
      ) {
        this.file = opts.from
      } else {
        this.file = resolve(opts.from)
      }
    }

    if (pathAvailable && sourceMapAvailable) {
      let map = new PreviousMap(this.css, opts)
      if (map.text) {
        this.map = map
        let file = map.consumer().file
        if (!this.file && file) this.file = this.mapResolve(file)
      }
    }

    if (!this.file) {
      this.id = '<input css ' + nanoid(6) + '>'
    }
    if (this.map) this.map.file = this.from
  }

  fromOffset(offset) {
    let lastLine, lineToIndex
    if (!this[fromOffsetCache]) {
      let lines = this.css.split('\n')
      lineToIndex = new Array(lines.length)
      let prevIndex = 0

      for (let i = 0, l = lines.length; i < l; i++) {
        lineToIndex[i] = prevIndex
        prevIndex += lines[i].length + 1
      }

      this[fromOffsetCache] = lineToIndex
    } else {
      lineToIndex = this[fromOffsetCache]
    }
    lastLine = lineToIndex[lineToIndex.length - 1]

    let min = 0
    if (offset >= lastLine) {
      min = lineToIndex.length - 1
    } else {
      let max = lineToIndex.length - 2
      let mid
      while (min < max) {
        mid = min + ((max - min) >> 1)
        if (offset < lineToIndex[mid]) {
          max = mid - 1
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1
        } else {
          min = mid
          break
        }
      }
    }
    return {
      line: min + 1,
      col: offset - lineToIndex[min] + 1
    }
  }

  error(message, line, column, opts = {}) {
    let result
    if (!column) {
      let pos = this.fromOffset(line)
      line = pos.line
      column = pos.col
    }
    let origin = this.origin(line, column)
    if (origin) {
      result = new CssSyntaxError(
        message,
        origin.line,
        origin.column,
        origin.source,
        origin.file,
        opts.plugin
      )
    } else {
      result = new CssSyntaxError(
        message,
        line,
        column,
        this.css,
        this.file,
        opts.plugin
      )
    }

    result.input = { line, column, source: this.css }
    if (this.file) {
      if (pathToFileURL) {
        result.input.url = pathToFileURL(this.file).toString()
      }
      result.input.file = this.file
    }

    return result
  }

  origin(line, column) {
    if (!this.map) return false
    let consumer = this.map.consumer()

    let from = consumer.originalPositionFor({ line, column })
    if (!from.source) return false

    let fromUrl

    if (isAbsolute(from.source)) {
      fromUrl = pathToFileURL(from.source)
    } else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
      )
    }

    let result = {
      url: fromUrl.toString(),
      line: from.line,
      column: from.column
    }

    if (fromUrl.protocol === 'file:') {
      if (fileURLToPath) {
        result.file = fileURLToPath(fromUrl)
      } else {
        // istanbul ignore next
        throw new Error(`file: protocol is not available in this PostCSS build`)
      }
    }

    let source = consumer.sourceContentFor(from.source)
    if (source) result.source = source

    return result
  }

  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file
    }
    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)
  }

  get from() {
    return this.file || this.id
  }

  toJSON() {
    let json = {}
    for (let name of ['hasBOM', 'css', 'file', 'id']) {
      if (this[name] != null) {
        json[name] = this[name]
      }
    }
    if (this.map) {
      json.map = { ...this.map }
      if (json.map.consumerCache) {
        json.map.consumerCache = undefined
      }
    }
    return json
  }
}

module.exports = Input
Input.default = Input

if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input)
}


/***/ }),

/***/ 1939:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { isClean, my } = __webpack_require__(5513)
let MapGenerator = __webpack_require__(8505)
let stringify = __webpack_require__(7088)
let Container = __webpack_require__(1019)
let Document = __webpack_require__(6461)
let warnOnce = __webpack_require__(2448)
let Result = __webpack_require__(3632)
let parse = __webpack_require__(6939)
let Root = __webpack_require__(1025)

const TYPE_TO_CLASS_NAME = {
  document: 'Document',
  root: 'Root',
  atrule: 'AtRule',
  rule: 'Rule',
  decl: 'Declaration',
  comment: 'Comment'
}

const PLUGIN_PROPS = {
  postcssPlugin: true,
  prepare: true,
  Once: true,
  Document: true,
  Root: true,
  Declaration: true,
  Rule: true,
  AtRule: true,
  Comment: true,
  DeclarationExit: true,
  RuleExit: true,
  AtRuleExit: true,
  CommentExit: true,
  RootExit: true,
  DocumentExit: true,
  OnceExit: true
}

const NOT_VISITORS = {
  postcssPlugin: true,
  prepare: true,
  Once: true
}

const CHILDREN = 0

function isPromise(obj) {
  return typeof obj === 'object' && typeof obj.then === 'function'
}

function getEvents(node) {
  let key = false
  let type = TYPE_TO_CLASS_NAME[node.type]
  if (node.type === 'decl') {
    key = node.prop.toLowerCase()
  } else if (node.type === 'atrule') {
    key = node.name.toLowerCase()
  }

  if (key && node.append) {
    return [
      type,
      type + '-' + key,
      CHILDREN,
      type + 'Exit',
      type + 'Exit-' + key
    ]
  } else if (key) {
    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]
  } else if (node.append) {
    return [type, CHILDREN, type + 'Exit']
  } else {
    return [type, type + 'Exit']
  }
}

function toStack(node) {
  let events
  if (node.type === 'document') {
    events = ['Document', CHILDREN, 'DocumentExit']
  } else if (node.type === 'root') {
    events = ['Root', CHILDREN, 'RootExit']
  } else {
    events = getEvents(node)
  }

  return {
    node,
    events,
    eventIndex: 0,
    visitors: [],
    visitorIndex: 0,
    iterator: 0
  }
}

function cleanMarks(node) {
  node[isClean] = false
  if (node.nodes) node.nodes.forEach(i => cleanMarks(i))
  return node
}

let postcss = {}

class LazyResult {
  constructor(processor, css, opts) {
    this.stringified = false
    this.processed = false

    let root
    if (
      typeof css === 'object' &&
      css !== null &&
      (css.type === 'root' || css.type === 'document')
    ) {
      root = cleanMarks(css)
    } else if (css instanceof LazyResult || css instanceof Result) {
      root = cleanMarks(css.root)
      if (css.map) {
        if (typeof opts.map === 'undefined') opts.map = {}
        if (!opts.map.inline) opts.map.inline = false
        opts.map.prev = css.map
      }
    } else {
      let parser = parse
      if (opts.syntax) parser = opts.syntax.parse
      if (opts.parser) parser = opts.parser
      if (parser.parse) parser = parser.parse

      try {
        root = parser(css, opts)
      } catch (error) {
        this.processed = true
        this.error = error
      }

      if (root && !root[my]) {
        // istanbul ignore next
        Container.rebuild(root)
      }
    }

    this.result = new Result(processor, root, opts)
    this.helpers = { ...postcss, result: this.result, postcss }
    this.plugins = this.processor.plugins.map(plugin => {
      if (typeof plugin === 'object' && plugin.prepare) {
        return { ...plugin, ...plugin.prepare(this.result) }
      } else {
        return plugin
      }
    })
  }

  get [Symbol.toStringTag]() {
    return 'LazyResult'
  }

  get processor() {
    return this.result.processor
  }

  get opts() {
    return this.result.opts
  }

  get css() {
    return this.stringify().css
  }

  get content() {
    return this.stringify().content
  }

  get map() {
    return this.stringify().map
  }

  get root() {
    return this.sync().root
  }

  get messages() {
    return this.sync().messages
  }

  warnings() {
    return this.sync().warnings()
  }

  toString() {
    return this.css
  }

  then(onFulfilled, onRejected) {
    if (false) {}
    return this.async().then(onFulfilled, onRejected)
  }

  catch(onRejected) {
    return this.async().catch(onRejected)
  }

  finally(onFinally) {
    return this.async().then(onFinally, onFinally)
  }

  async() {
    if (this.error) return Promise.reject(this.error)
    if (this.processed) return Promise.resolve(this.result)
    if (!this.processing) {
      this.processing = this.runAsync()
    }
    return this.processing
  }

  sync() {
    if (this.error) throw this.error
    if (this.processed) return this.result
    this.processed = true

    if (this.processing) {
      throw this.getAsyncError()
    }

    for (let plugin of this.plugins) {
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) {
        throw this.getAsyncError()
      }
    }

    this.prepareVisitors()
    if (this.hasListener) {
      let root = this.result.root
      while (!root[isClean]) {
        root[isClean] = true
        this.walkSync(root)
      }
      if (this.listeners.OnceExit) {
        if (root.type === 'document') {
          for (let subRoot of root.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot)
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root)
        }
      }
    }

    return this.result
  }

  stringify() {
    if (this.error) throw this.error
    if (this.stringified) return this.result
    this.stringified = true

    this.sync()

    let opts = this.result.opts
    let str = stringify
    if (opts.syntax) str = opts.syntax.stringify
    if (opts.stringifier) str = opts.stringifier
    if (str.stringify) str = str.stringify

    let map = new MapGenerator(str, this.result.root, this.result.opts)
    let data = map.generate()
    this.result.css = data[0]
    this.result.map = data[1]

    return this.result
  }

  walkSync(node) {
    node[isClean] = true
    let events = getEvents(node)
    for (let event of events) {
      if (event === CHILDREN) {
        if (node.nodes) {
          node.each(child => {
            if (!child[isClean]) this.walkSync(child)
          })
        }
      } else {
        let visitors = this.listeners[event]
        if (visitors) {
          if (this.visitSync(visitors, node.toProxy())) return
        }
      }
    }
  }

  visitSync(visitors, node) {
    for (let [plugin, visitor] of visitors) {
      this.result.lastPlugin = plugin
      let promise
      try {
        promise = visitor(node, this.helpers)
      } catch (e) {
        throw this.handleError(e, node.proxyOf)
      }
      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
        return true
      }
      if (isPromise(promise)) {
        throw this.getAsyncError()
      }
    }
  }

  runOnRoot(plugin) {
    this.result.lastPlugin = plugin
    try {
      if (typeof plugin === 'object' && plugin.Once) {
        if (this.result.root.type === 'document') {
          let roots = this.result.root.nodes.map(root =>
            plugin.Once(root, this.helpers)
          )

          if (isPromise(roots[0])) {
            return Promise.all(roots)
          }

          return roots
        }

        return plugin.Once(this.result.root, this.helpers)
      } else if (typeof plugin === 'function') {
        return plugin(this.result.root, this.result)
      }
    } catch (error) {
      throw this.handleError(error)
    }
  }

  getAsyncError() {
    throw new Error('Use process(css).then(cb) to work with async plugins')
  }

  handleError(error, node) {
    let plugin = this.result.lastPlugin
    try {
      if (node) node.addToError(error)
      this.error = error
      if (error.name === 'CssSyntaxError' && !error.plugin) {
        error.plugin = plugin.postcssPlugin
        error.setMessage()
      } else if (plugin.postcssVersion) {
        if (false) {}
      }
    } catch (err) {
      // istanbul ignore next
      if (console && console.error) console.error(err)
    }
    return error
  }

  async runAsync() {
    this.plugin = 0
    for (let i = 0; i < this.plugins.length; i++) {
      let plugin = this.plugins[i]
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) {
        try {
          await promise
        } catch (error) {
          throw this.handleError(error)
        }
      }
    }

    this.prepareVisitors()
    if (this.hasListener) {
      let root = this.result.root
      while (!root[isClean]) {
        root[isClean] = true
        let stack = [toStack(root)]
        while (stack.length > 0) {
          let promise = this.visitTick(stack)
          if (isPromise(promise)) {
            try {
              await promise
            } catch (e) {
              let node = stack[stack.length - 1].node
              throw this.handleError(e, node)
            }
          }
        }
      }

      if (this.listeners.OnceExit) {
        for (let [plugin, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin
          try {
            if (root.type === 'document') {
              let roots = root.nodes.map(subRoot =>
                visitor(subRoot, this.helpers)
              )

              await Promise.all(roots)
            } else {
              await visitor(root, this.helpers)
            }
          } catch (e) {
            throw this.handleError(e)
          }
        }
      }
    }

    this.processed = true
    return this.stringify()
  }

  prepareVisitors() {
    this.listeners = {}
    let add = (plugin, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = []
      this.listeners[type].push([plugin, cb])
    }
    for (let plugin of this.plugins) {
      if (typeof plugin === 'object') {
        for (let event in plugin) {
          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
            throw new Error(
              `Unknown event ${event} in ${plugin.postcssPlugin}. ` +
                `Try to update PostCSS (${this.processor.version} now).`
            )
          }
          if (!NOT_VISITORS[event]) {
            if (typeof plugin[event] === 'object') {
              for (let filter in plugin[event]) {
                if (filter === '*') {
                  add(plugin, event, plugin[event][filter])
                } else {
                  add(
                    plugin,
                    event + '-' + filter.toLowerCase(),
                    plugin[event][filter]
                  )
                }
              }
            } else if (typeof plugin[event] === 'function') {
              add(plugin, event, plugin[event])
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0
  }

  visitTick(stack) {
    let visit = stack[stack.length - 1]
    let { node, visitors } = visit

    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
      stack.pop()
      return
    }

    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
      let [plugin, visitor] = visitors[visit.visitorIndex]
      visit.visitorIndex += 1
      if (visit.visitorIndex === visitors.length) {
        visit.visitors = []
        visit.visitorIndex = 0
      }
      this.result.lastPlugin = plugin
      try {
        return visitor(node.toProxy(), this.helpers)
      } catch (e) {
        throw this.handleError(e, node)
      }
    }

    if (visit.iterator !== 0) {
      let iterator = visit.iterator
      let child
      while ((child = node.nodes[node.indexes[iterator]])) {
        node.indexes[iterator] += 1
        if (!child[isClean]) {
          child[isClean] = true
          stack.push(toStack(child))
          return
        }
      }
      visit.iterator = 0
      delete node.indexes[iterator]
    }

    let events = visit.events
    while (visit.eventIndex < events.length) {
      let event = events[visit.eventIndex]
      visit.eventIndex += 1
      if (event === CHILDREN) {
        if (node.nodes && node.nodes.length) {
          node[isClean] = true
          visit.iterator = node.getIterator()
        }
        return
      } else if (this.listeners[event]) {
        visit.visitors = this.listeners[event]
        return
      }
    }
    stack.pop()
  }
}

LazyResult.registerPostcss = dependant => {
  postcss = dependant
}

module.exports = LazyResult
LazyResult.default = LazyResult

Root.registerLazyResult(LazyResult)
Document.registerLazyResult(LazyResult)


/***/ }),

/***/ 4715:
/***/ ((module) => {

"use strict";


let list = {
  split(string, separators, last) {
    let array = []
    let current = ''
    let split = false

    let func = 0
    let quote = false
    let escape = false

    for (let letter of string) {
      if (escape) {
        escape = false
      } else if (letter === '\\') {
        escape = true
      } else if (quote) {
        if (letter === quote) {
          quote = false
        }
      } else if (letter === '"' || letter === "'") {
        quote = letter
      } else if (letter === '(') {
        func += 1
      } else if (letter === ')') {
        if (func > 0) func -= 1
      } else if (func === 0) {
        if (separators.includes(letter)) split = true
      }

      if (split) {
        if (current !== '') array.push(current.trim())
        current = ''
        split = false
      } else {
        current += letter
      }
    }

    if (last || current !== '') array.push(current.trim())
    return array
  },

  space(string) {
    let spaces = [' ', '\n', '\t']
    return list.split(string, spaces)
  },

  comma(string) {
    return list.split(string, [','], true)
  }
}

module.exports = list
list.default = list


/***/ }),

/***/ 8505:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(209)
let { dirname, resolve, relative, sep } = __webpack_require__(9830)
let { pathToFileURL } = __webpack_require__(7414)

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(dirname && resolve && relative && sep)

class MapGenerator {
  constructor(stringify, root, opts) {
    this.stringify = stringify
    this.mapOpts = opts.map || {}
    this.root = root
    this.opts = opts
  }

  isMap() {
    if (typeof this.opts.map !== 'undefined') {
      return !!this.opts.map
    }
    return this.previous().length > 0
  }

  previous() {
    if (!this.previousMaps) {
      this.previousMaps = []
      this.root.walk(node => {
        if (node.source && node.source.input.map) {
          let map = node.source.input.map
          if (!this.previousMaps.includes(map)) {
            this.previousMaps.push(map)
          }
        }
      })
    }

    return this.previousMaps
  }

  isInline() {
    if (typeof this.mapOpts.inline !== 'undefined') {
      return this.mapOpts.inline
    }

    let annotation = this.mapOpts.annotation
    if (typeof annotation !== 'undefined' && annotation !== true) {
      return false
    }

    if (this.previous().length) {
      return this.previous().some(i => i.inline)
    }
    return true
  }

  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
      return this.mapOpts.sourcesContent
    }
    if (this.previous().length) {
      return this.previous().some(i => i.withContent())
    }
    return true
  }

  clearAnnotation() {
    if (this.mapOpts.annotation === false) return

    let node
    for (let i = this.root.nodes.length - 1; i >= 0; i--) {
      node = this.root.nodes[i]
      if (node.type !== 'comment') continue
      if (node.text.indexOf('# sourceMappingURL=') === 0) {
        this.root.removeChild(i)
      }
    }
  }

  setSourcesContent() {
    let already = {}
    this.root.walk(node => {
      if (node.source) {
        let from = node.source.input.from
        if (from && !already[from]) {
          already[from] = true
          this.map.setSourceContent(
            this.toUrl(this.path(from)),
            node.source.input.css
          )
        }
      }
    })
  }

  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file))
      let root = prev.root || dirname(prev.file)
      let map

      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer(prev.text)
        if (map.sourcesContent) {
          map.sourcesContent = map.sourcesContent.map(() => null)
        }
      } else {
        map = prev.consumer()
      }

      this.map.applySourceMap(map, from, this.toUrl(this.path(root)))
    }
  }

  isAnnotation() {
    if (this.isInline()) {
      return true
    }
    if (typeof this.mapOpts.annotation !== 'undefined') {
      return this.mapOpts.annotation
    }
    if (this.previous().length) {
      return this.previous().some(i => i.annotation)
    }
    return true
  }

  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString('base64')
    } else {
      // istanbul ignore next
      return window.btoa(unescape(encodeURIComponent(str)))
    }
  }

  addAnnotation() {
    let content

    if (this.isInline()) {
      content =
        'data:application/json;base64,' + this.toBase64(this.map.toString())
    } else if (typeof this.mapOpts.annotation === 'string') {
      content = this.mapOpts.annotation
    } else if (typeof this.mapOpts.annotation === 'function') {
      content = this.mapOpts.annotation(this.opts.to, this.root)
    } else {
      content = this.outputFile() + '.map'
    }

    let eol = '\n'
    if (this.css.includes('\r\n')) eol = '\r\n'

    this.css += eol + '/*# sourceMappingURL=' + content + ' */'
  }

  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to)
    }
    if (this.opts.from) {
      return this.path(this.opts.from)
    }
    return 'to.css'
  }

  generateMap() {
    this.generateString()
    if (this.isSourcesContent()) this.setSourcesContent()
    if (this.previous().length > 0) this.applyPrevMaps()
    if (this.isAnnotation()) this.addAnnotation()

    if (this.isInline()) {
      return [this.css]
    }
    return [this.css, this.map]
  }

  path(file) {
    if (file.indexOf('<') === 0) return file
    if (/^\w+:\/\//.test(file)) return file
    if (this.mapOpts.absolute) return file

    let from = this.opts.to ? dirname(this.opts.to) : '.'

    if (typeof this.mapOpts.annotation === 'string') {
      from = dirname(resolve(from, this.mapOpts.annotation))
    }

    file = relative(from, file)
    return file
  }

  toUrl(path) {
    if (sep === '\\') {
      // istanbul ignore next
      path = path.replace(/\\/g, '/')
    }
    return encodeURI(path).replace(/[#?]/g, encodeURIComponent)
  }

  sourcePath(node) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from)
    } else if (this.mapOpts.absolute) {
      if (pathToFileURL) {
        return pathToFileURL(node.source.input.from).toString()
      } else {
        // istanbul ignore next
        throw new Error(
          '`map.absolute` option is not available in this PostCSS build'
        )
      }
    } else {
      return this.toUrl(this.path(node.source.input.from))
    }
  }

  generateString() {
    this.css = ''
    this.map = new SourceMapGenerator({ file: this.outputFile() })

    let line = 1
    let column = 1

    let noSource = '<no source>'
    let mapping = {
      source: '',
      generated: { line: 0, column: 0 },
      original: { line: 0, column: 0 }
    }

    let lines, last
    this.stringify(this.root, (str, node, type) => {
      this.css += str

      if (node && type !== 'end') {
        mapping.generated.line = line
        mapping.generated.column = column - 1
        if (node.source && node.source.start) {
          mapping.source = this.sourcePath(node)
          mapping.original.line = node.source.start.line
          mapping.original.column = node.source.start.column - 1
          this.map.addMapping(mapping)
        } else {
          mapping.source = noSource
          mapping.original.line = 1
          mapping.original.column = 0
          this.map.addMapping(mapping)
        }
      }

      lines = str.match(/\n/g)
      if (lines) {
        line += lines.length
        last = str.lastIndexOf('\n')
        column = str.length - last
      } else {
        column += str.length
      }

      if (node && type !== 'start') {
        let p = node.parent || { raws: {} }
        if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {
          if (node.source && node.source.end) {
            mapping.source = this.sourcePath(node)
            mapping.original.line = node.source.end.line
            mapping.original.column = node.source.end.column - 1
            mapping.generated.line = line
            mapping.generated.column = column - 2
            this.map.addMapping(mapping)
          } else {
            mapping.source = noSource
            mapping.original.line = 1
            mapping.original.column = 0
            mapping.generated.line = line
            mapping.generated.column = column - 1
            this.map.addMapping(mapping)
          }
        }
      }
    })
  }

  generate() {
    this.clearAnnotation()

    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap()
    }

    let result = ''
    this.stringify(this.root, i => {
      result += i
    })
    return [result]
  }
}

module.exports = MapGenerator


/***/ }),

/***/ 5631:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { isClean, my } = __webpack_require__(5513)
let CssSyntaxError = __webpack_require__(2671)
let Stringifier = __webpack_require__(1062)
let stringify = __webpack_require__(7088)

function cloneNode(obj, parent) {
  let cloned = new obj.constructor()

  for (let i in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i)) {
      // istanbul ignore next
      continue
    }
    if (i === 'proxyCache') continue
    let value = obj[i]
    let type = typeof value

    if (i === 'parent' && type === 'object') {
      if (parent) cloned[i] = parent
    } else if (i === 'source') {
      cloned[i] = value
    } else if (Array.isArray(value)) {
      cloned[i] = value.map(j => cloneNode(j, cloned))
    } else {
      if (type === 'object' && value !== null) value = cloneNode(value)
      cloned[i] = value
    }
  }

  return cloned
}

class Node {
  constructor(defaults = {}) {
    this.raws = {}
    this[isClean] = false
    this[my] = true

    for (let name in defaults) {
      if (name === 'nodes') {
        this.nodes = []
        for (let node of defaults[name]) {
          if (typeof node.clone === 'function') {
            this.append(node.clone())
          } else {
            this.append(node)
          }
        }
      } else {
        this[name] = defaults[name]
      }
    }
  }

  error(message, opts = {}) {
    if (this.source) {
      let pos = this.positionBy(opts)
      return this.source.input.error(message, pos.line, pos.column, opts)
    }
    return new CssSyntaxError(message)
  }

  warn(result, text, opts) {
    let data = { node: this }
    for (let i in opts) data[i] = opts[i]
    return result.warn(text, data)
  }

  remove() {
    if (this.parent) {
      this.parent.removeChild(this)
    }
    this.parent = undefined
    return this
  }

  toString(stringifier = stringify) {
    if (stringifier.stringify) stringifier = stringifier.stringify
    let result = ''
    stringifier(this, i => {
      result += i
    })
    return result
  }

  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name]
    }
    return this
  }

  clone(overrides = {}) {
    let cloned = cloneNode(this)
    for (let name in overrides) {
      cloned[name] = overrides[name]
    }
    return cloned
  }

  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides)
    this.parent.insertBefore(this, cloned)
    return cloned
  }

  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides)
    this.parent.insertAfter(this, cloned)
    return cloned
  }

  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this
      let foundSelf = false
      for (let node of nodes) {
        if (node === this) {
          foundSelf = true
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node)
          bookmark = node
        } else {
          this.parent.insertBefore(bookmark, node)
        }
      }

      if (!foundSelf) {
        this.remove()
      }
    }

    return this
  }

  next() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index + 1]
  }

  prev() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index - 1]
  }

  before(add) {
    this.parent.insertBefore(this, add)
    return this
  }

  after(add) {
    this.parent.insertAfter(this, add)
    return this
  }

  root() {
    let result = this
    while (result.parent && result.parent.type !== 'document') {
      result = result.parent
    }
    return result
  }

  raw(prop, defaultType) {
    let str = new Stringifier()
    return str.raw(this, prop, defaultType)
  }

  cleanRaws(keepBetween) {
    delete this.raws.before
    delete this.raws.after
    if (!keepBetween) delete this.raws.between
  }

  toJSON(_, inputs) {
    let fixed = {}
    let emitInputs = inputs == null
    inputs = inputs || new Map()
    let inputsNextIndex = 0

    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        // istanbul ignore next
        continue
      }
      if (name === 'parent' || name === 'proxyCache') continue
      let value = this[name]

      if (Array.isArray(value)) {
        fixed[name] = value.map(i => {
          if (typeof i === 'object' && i.toJSON) {
            return i.toJSON(null, inputs)
          } else {
            return i
          }
        })
      } else if (typeof value === 'object' && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs)
      } else if (name === 'source') {
        let inputId = inputs.get(value.input)
        if (inputId == null) {
          inputId = inputsNextIndex
          inputs.set(value.input, inputsNextIndex)
          inputsNextIndex++
        }
        fixed[name] = {
          inputId,
          start: value.start,
          end: value.end
        }
      } else {
        fixed[name] = value
      }
    }

    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())
    }

    return fixed
  }

  positionInside(index) {
    let string = this.toString()
    let column = this.source.start.column
    let line = this.source.start.line

    for (let i = 0; i < index; i++) {
      if (string[i] === '\n') {
        column = 1
        line += 1
      } else {
        column += 1
      }
    }

    return { line, column }
  }

  positionBy(opts) {
    let pos = this.source.start
    if (opts.index) {
      pos = this.positionInside(opts.index)
    } else if (opts.word) {
      let index = this.toString().indexOf(opts.word)
      if (index !== -1) pos = this.positionInside(index)
    }
    return pos
  }

  getProxyProcessor() {
    return {
      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (
          prop === 'prop' ||
          prop === 'value' ||
          prop === 'name' ||
          prop === 'params' ||
          prop === 'important' ||
          prop === 'text'
        ) {
          node.markDirty()
        }
        return true
      },

      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        } else if (prop === 'root') {
          return () => node.root().toProxy()
        } else {
          return node[prop]
        }
      }
    }
  }

  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor())
    }
    return this.proxyCache
  }

  addToError(error) {
    error.postcssNode = this
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s = this.source
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
      )
    }
    return error
  }

  markDirty() {
    if (this[isClean]) {
      this[isClean] = false
      let next = this
      while ((next = next.parent)) {
        next[isClean] = false
      }
    }
  }

  get proxyOf() {
    return this
  }
}

module.exports = Node
Node.default = Node


/***/ }),

/***/ 6939:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(1019)
let Parser = __webpack_require__(8867)
let Input = __webpack_require__(5995)

function parse(css, opts) {
  let input = new Input(css, opts)
  let parser = new Parser(input)
  try {
    parser.parse()
  } catch (e) {
    if (false) {}
    throw e
  }

  return parser.root
}

module.exports = parse
parse.default = parse

Container.registerParse(parse)


/***/ }),

/***/ 8867:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Declaration = __webpack_require__(4258)
let tokenizer = __webpack_require__(3852)
let Comment = __webpack_require__(7923)
let AtRule = __webpack_require__(1353)
let Root = __webpack_require__(1025)
let Rule = __webpack_require__(1675)

class Parser {
  constructor(input) {
    this.input = input

    this.root = new Root()
    this.current = this.root
    this.spaces = ''
    this.semicolon = false
    this.customProperty = false

    this.createTokenizer()
    this.root.source = { input, start: { offset: 0, line: 1, column: 1 } }
  }

  createTokenizer() {
    this.tokenizer = tokenizer(this.input)
  }

  parse() {
    let token
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()

      switch (token[0]) {
        case 'space':
          this.spaces += token[1]
          break

        case ';':
          this.freeSemicolon(token)
          break

        case '}':
          this.end(token)
          break

        case 'comment':
          this.comment(token)
          break

        case 'at-word':
          this.atrule(token)
          break

        case '{':
          this.emptyRule(token)
          break

        default:
          this.other(token)
          break
      }
    }
    this.endFile()
  }

  comment(token) {
    let node = new Comment()
    this.init(node, token[2])
    node.source.end = this.getPosition(token[3] || token[2])

    let text = token[1].slice(2, -2)
    if (/^\s*$/.test(text)) {
      node.text = ''
      node.raws.left = text
      node.raws.right = ''
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/)
      node.text = match[2]
      node.raws.left = match[1]
      node.raws.right = match[3]
    }
  }

  emptyRule(token) {
    let node = new Rule()
    this.init(node, token[2])
    node.selector = ''
    node.raws.between = ''
    this.current = node
  }

  other(start) {
    let end = false
    let type = null
    let colon = false
    let bracket = null
    let brackets = []
    let customProperty = start[1].startsWith('--')

    let tokens = []
    let token = start
    while (token) {
      type = token[0]
      tokens.push(token)

      if (type === '(' || type === '[') {
        if (!bracket) bracket = token
        brackets.push(type === '(' ? ')' : ']')
      } else if (customProperty && colon && type === '{') {
        if (!bracket) bracket = token
        brackets.push('}')
      } else if (brackets.length === 0) {
        if (type === ';') {
          if (colon) {
            this.decl(tokens, customProperty)
            return
          } else {
            break
          }
        } else if (type === '{') {
          this.rule(tokens)
          return
        } else if (type === '}') {
          this.tokenizer.back(tokens.pop())
          end = true
          break
        } else if (type === ':') {
          colon = true
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
        if (brackets.length === 0) bracket = null
      }

      token = this.tokenizer.nextToken()
    }

    if (this.tokenizer.endOfFile()) end = true
    if (brackets.length > 0) this.unclosedBracket(bracket)

    if (end && colon) {
      while (tokens.length) {
        token = tokens[tokens.length - 1][0]
        if (token !== 'space' && token !== 'comment') break
        this.tokenizer.back(tokens.pop())
      }
      this.decl(tokens, customProperty)
    } else {
      this.unknownWord(tokens)
    }
  }

  rule(tokens) {
    tokens.pop()

    let node = new Rule()
    this.init(node, tokens[0][2])

    node.raws.between = this.spacesAndCommentsFromEnd(tokens)
    this.raw(node, 'selector', tokens)
    this.current = node
  }

  decl(tokens, customProperty) {
    let node = new Declaration()
    this.init(node, tokens[0][2])

    let last = tokens[tokens.length - 1]
    if (last[0] === ';') {
      this.semicolon = true
      tokens.pop()
    }
    node.source.end = this.getPosition(last[3] || last[2])

    while (tokens[0][0] !== 'word') {
      if (tokens.length === 1) this.unknownWord(tokens)
      node.raws.before += tokens.shift()[1]
    }
    node.source.start = this.getPosition(tokens[0][2])

    node.prop = ''
    while (tokens.length) {
      let type = tokens[0][0]
      if (type === ':' || type === 'space' || type === 'comment') {
        break
      }
      node.prop += tokens.shift()[1]
    }

    node.raws.between = ''

    let token
    while (tokens.length) {
      token = tokens.shift()

      if (token[0] === ':') {
        node.raws.between += token[1]
        break
      } else {
        if (token[0] === 'word' && /\w/.test(token[1])) {
          this.unknownWord([token])
        }
        node.raws.between += token[1]
      }
    }

    if (node.prop[0] === '_' || node.prop[0] === '*') {
      node.raws.before += node.prop[0]
      node.prop = node.prop.slice(1)
    }
    let firstSpaces = this.spacesAndCommentsFromStart(tokens)
    this.precheckMissedSemicolon(tokens)

    for (let i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i]
      if (token[1].toLowerCase() === '!important') {
        node.important = true
        let string = this.stringFrom(tokens, i)
        string = this.spacesFromEnd(tokens) + string
        if (string !== ' !important') node.raws.important = string
        break
      } else if (token[1].toLowerCase() === 'important') {
        let cache = tokens.slice(0)
        let str = ''
        for (let j = i; j > 0; j--) {
          let type = cache[j][0]
          if (str.trim().indexOf('!') === 0 && type !== 'space') {
            break
          }
          str = cache.pop()[1] + str
        }
        if (str.trim().indexOf('!') === 0) {
          node.important = true
          node.raws.important = str
          tokens = cache
        }
      }

      if (token[0] !== 'space' && token[0] !== 'comment') {
        break
      }
    }

    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')
    this.raw(node, 'value', tokens)
    if (hasWord) {
      node.raws.between += firstSpaces
    } else {
      node.value = firstSpaces + node.value
    }

    if (node.value.includes(':') && !customProperty) {
      this.checkMissedSemicolon(tokens)
    }
  }

  atrule(token) {
    let node = new AtRule()
    node.name = token[1].slice(1)
    if (node.name === '') {
      this.unnamedAtrule(node, token)
    }
    this.init(node, token[2])

    let type
    let prev
    let shift
    let last = false
    let open = false
    let params = []
    let brackets = []

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()
      type = token[0]

      if (type === '(' || type === '[') {
        brackets.push(type === '(' ? ')' : ']')
      } else if (type === '{' && brackets.length > 0) {
        brackets.push('}')
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
      }

      if (brackets.length === 0) {
        if (type === ';') {
          node.source.end = this.getPosition(token[2])
          this.semicolon = true
          break
        } else if (type === '{') {
          open = true
          break
        } else if (type === '}') {
          if (params.length > 0) {
            shift = params.length - 1
            prev = params[shift]
            while (prev && prev[0] === 'space') {
              prev = params[--shift]
            }
            if (prev) {
              node.source.end = this.getPosition(prev[3] || prev[2])
            }
          }
          this.end(token)
          break
        } else {
          params.push(token)
        }
      } else {
        params.push(token)
      }

      if (this.tokenizer.endOfFile()) {
        last = true
        break
      }
    }

    node.raws.between = this.spacesAndCommentsFromEnd(params)
    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params)
      this.raw(node, 'params', params)
      if (last) {
        token = params[params.length - 1]
        node.source.end = this.getPosition(token[3] || token[2])
        this.spaces = node.raws.between
        node.raws.between = ''
      }
    } else {
      node.raws.afterName = ''
      node.params = ''
    }

    if (open) {
      node.nodes = []
      this.current = node
    }
  }

  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.semicolon = false

    this.current.raws.after = (this.current.raws.after || '') + this.spaces
    this.spaces = ''

    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2])
      this.current = this.current.parent
    } else {
      this.unexpectedClose(token)
    }
  }

  endFile() {
    if (this.current.parent) this.unclosedBlock()
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.current.raws.after = (this.current.raws.after || '') + this.spaces
  }

  freeSemicolon(token) {
    this.spaces += token[1]
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1]
      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces
        this.spaces = ''
      }
    }
  }

  // Helpers

  getPosition(offset) {
    let pos = this.input.fromOffset(offset)
    return {
      offset,
      line: pos.line,
      column: pos.col
    }
  }

  init(node, offset) {
    this.current.push(node)
    node.source = {
      start: this.getPosition(offset),
      input: this.input
    }
    node.raws.before = this.spaces
    this.spaces = ''
    if (node.type !== 'comment') this.semicolon = false
  }

  raw(node, prop, tokens) {
    let token, type
    let length = tokens.length
    let value = ''
    let clean = true
    let next, prev
    let pattern = /^([#.|])?(\w)+/i

    for (let i = 0; i < length; i += 1) {
      token = tokens[i]
      type = token[0]

      if (type === 'comment' && node.type === 'rule') {
        prev = tokens[i - 1]
        next = tokens[i + 1]

        if (
          prev[0] !== 'space' &&
          next[0] !== 'space' &&
          pattern.test(prev[1]) &&
          pattern.test(next[1])
        ) {
          value += token[1]
        } else {
          clean = false
        }

        continue
      }

      if (type === 'comment' || (type === 'space' && i === length - 1)) {
        clean = false
      } else {
        value += token[1]
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i) => all + i[1], '')
      node.raws[prop] = { value, raw }
    }
    node[prop] = value
  }

  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType
    let spaces = ''
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  spacesAndCommentsFromStart(tokens) {
    let next
    let spaces = ''
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      spaces += tokens.shift()[1]
    }
    return spaces
  }

  spacesFromEnd(tokens) {
    let lastTokenType
    let spaces = ''
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space') break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  stringFrom(tokens, from) {
    let result = ''
    for (let i = from; i < tokens.length; i++) {
      result += tokens[i][1]
    }
    tokens.splice(from, tokens.length - from)
    return result
  }

  colon(tokens) {
    let brackets = 0
    let token, type, prev
    for (let [i, element] of tokens.entries()) {
      token = element
      type = token[0]

      if (type === '(') {
        brackets += 1
      }
      if (type === ')') {
        brackets -= 1
      }
      if (brackets === 0 && type === ':') {
        if (!prev) {
          this.doubleColon(token)
        } else if (prev[0] === 'word' && prev[1] === 'progid') {
          continue
        } else {
          return i
        }
      }

      prev = token
    }
    return false
  }

  // Errors

  unclosedBracket(bracket) {
    throw this.input.error('Unclosed bracket', bracket[2])
  }

  unknownWord(tokens) {
    throw this.input.error('Unknown word', tokens[0][2])
  }

  unexpectedClose(token) {
    throw this.input.error('Unexpected }', token[2])
  }

  unclosedBlock() {
    let pos = this.current.source.start
    throw this.input.error('Unclosed block', pos.line, pos.column)
  }

  doubleColon(token) {
    throw this.input.error('Double colon', token[2])
  }

  unnamedAtrule(node, token) {
    throw this.input.error('At-rule without name', token[2])
  }

  precheckMissedSemicolon(/* tokens */) {
    // Hook for Safe Parser
  }

  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens)
    if (colon === false) return

    let founded = 0
    let token
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j]
      if (token[0] !== 'space') {
        founded += 1
        if (founded === 2) break
      }
    }
    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
    // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
    // And because we need it after that one we do +1 to get the next one.
    throw this.input.error(
      'Missed semicolon',
      token[0] === 'word' ? token[3] + 1 : token[2]
    )
  }
}

module.exports = Parser


/***/ }),

/***/ 20:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let CssSyntaxError = __webpack_require__(2671)
let Declaration = __webpack_require__(4258)
let LazyResult = __webpack_require__(1939)
let Container = __webpack_require__(1019)
let Processor = __webpack_require__(1723)
let stringify = __webpack_require__(7088)
let fromJSON = __webpack_require__(250)
let Document = __webpack_require__(6461)
let Warning = __webpack_require__(1728)
let Comment = __webpack_require__(7923)
let AtRule = __webpack_require__(1353)
let Result = __webpack_require__(3632)
let Input = __webpack_require__(5995)
let parse = __webpack_require__(6939)
let list = __webpack_require__(4715)
let Rule = __webpack_require__(1675)
let Root = __webpack_require__(1025)
let Node = __webpack_require__(5631)

function postcss(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0]
  }
  return new Processor(plugins)
}

postcss.plugin = function plugin(name, initializer) {
  if (console && console.warn) {
    console.warn(
      name +
        ': postcss.plugin was deprecated. Migration guide:\n' +
        'https://evilmartians.com/chronicles/postcss-8-plugin-migration'
    )
    if (process.env.LANG && process.env.LANG.startsWith('cn')) {
      // istanbul ignore next
      console.warn(
        name +
          ':  postcss.plugin . :\n' +
          'https://www.w3ctech.com/topic/2226'
      )
    }
  }
  function creator(...args) {
    let transformer = initializer(...args)
    transformer.postcssPlugin = name
    transformer.postcssVersion = new Processor().version
    return transformer
  }

  let cache
  Object.defineProperty(creator, 'postcss', {
    get() {
      if (!cache) cache = creator()
      return cache
    }
  })

  creator.process = function (css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts)
  }

  return creator
}

postcss.stringify = stringify
postcss.parse = parse
postcss.fromJSON = fromJSON
postcss.list = list

postcss.comment = defaults => new Comment(defaults)
postcss.atRule = defaults => new AtRule(defaults)
postcss.decl = defaults => new Declaration(defaults)
postcss.rule = defaults => new Rule(defaults)
postcss.root = defaults => new Root(defaults)
postcss.document = defaults => new Document(defaults)

postcss.CssSyntaxError = CssSyntaxError
postcss.Declaration = Declaration
postcss.Container = Container
postcss.Document = Document
postcss.Comment = Comment
postcss.Warning = Warning
postcss.AtRule = AtRule
postcss.Result = Result
postcss.Input = Input
postcss.Rule = Rule
postcss.Root = Root
postcss.Node = Node

LazyResult.registerPostcss(postcss)

module.exports = postcss
postcss.default = postcss


/***/ }),

/***/ 7981:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let { SourceMapConsumer, SourceMapGenerator } = __webpack_require__(209)
let { existsSync, readFileSync } = __webpack_require__(4777)
let { dirname, join } = __webpack_require__(9830)

function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, 'base64').toString()
  } else {
    // istanbul ignore next
    return window.atob(str)
  }
}

class PreviousMap {
  constructor(css, opts) {
    if (opts.map === false) return
    this.loadAnnotation(css)
    this.inline = this.startWith(this.annotation, 'data:')

    let prev = opts.map ? opts.map.prev : undefined
    let text = this.loadMap(opts.from, prev)
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from
    }
    if (this.mapFile) this.root = dirname(this.mapFile)
    if (text) this.text = text
  }

  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer(this.text)
    }
    return this.consumerCache
  }

  withContent() {
    return !!(
      this.consumer().sourcesContent &&
      this.consumer().sourcesContent.length > 0
    )
  }

  startWith(string, start) {
    if (!string) return false
    return string.substr(0, start.length) === start
  }

  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim()
  }

  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/gm)
    if (!comments) return

    // sourceMappingURLs from comments, strings, etc.
    let start = css.lastIndexOf(comments.pop())
    let end = css.indexOf('*/', start)

    if (start > -1 && end > -1) {
      // Locate the last sourceMappingURL to avoid pickin
      this.annotation = this.getAnnotationURL(css.substring(start, end))
    }
  }

  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/
    let baseUri = /^data:application\/json;base64,/
    let charsetUri = /^data:application\/json;charset=utf-?8,/
    let uri = /^data:application\/json,/

    if (charsetUri.test(text) || uri.test(text)) {
      return decodeURIComponent(text.substr(RegExp.lastMatch.length))
    }

    if (baseCharsetUri.test(text) || baseUri.test(text)) {
      return fromBase64(text.substr(RegExp.lastMatch.length))
    }

    let encoding = text.match(/data:application\/json;([^,]+),/)[1]
    throw new Error('Unsupported source map encoding ' + encoding)
  }

  loadFile(path) {
    this.root = dirname(path)
    if (existsSync(path)) {
      this.mapFile = path
      return readFileSync(path, 'utf-8').toString().trim()
    }
  }

  loadMap(file, prev) {
    if (prev === false) return false

    if (prev) {
      if (typeof prev === 'string') {
        return prev
      } else if (typeof prev === 'function') {
        let prevPath = prev(file)
        if (prevPath) {
          let map = this.loadFile(prevPath)
          if (!map) {
            throw new Error(
              'Unable to load previous source map: ' + prevPath.toString()
            )
          }
          return map
        }
      } else if (prev instanceof SourceMapConsumer) {
        return SourceMapGenerator.fromSourceMap(prev).toString()
      } else if (prev instanceof SourceMapGenerator) {
        return prev.toString()
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev)
      } else {
        throw new Error(
          'Unsupported previous source map format: ' + prev.toString()
        )
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation)
    } else if (this.annotation) {
      let map = this.annotation
      if (file) map = join(dirname(file), map)
      return this.loadFile(map)
    }
  }

  isMap(map) {
    if (typeof map !== 'object') return false
    return (
      typeof map.mappings === 'string' ||
      typeof map._mappings === 'string' ||
      Array.isArray(map.sections)
    )
  }
}

module.exports = PreviousMap
PreviousMap.default = PreviousMap


/***/ }),

/***/ 1723:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let LazyResult = __webpack_require__(1939)
let Document = __webpack_require__(6461)
let Root = __webpack_require__(1025)

class Processor {
  constructor(plugins = []) {
    this.version = '8.3.11'
    this.plugins = this.normalize(plugins)
  }

  use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]))
    return this
  }

  process(css, opts = {}) {
    if (
      this.plugins.length === 0 &&
      typeof opts.parser === 'undefined' &&
      typeof opts.stringifier === 'undefined' &&
      typeof opts.syntax === 'undefined' &&
      !opts.hideNothingWarning
    ) {
      if (false) {}
    }
    return new LazyResult(this, css, opts)
  }

  normalize(plugins) {
    let normalized = []
    for (let i of plugins) {
      if (i.postcss === true) {
        i = i()
      } else if (i.postcss) {
        i = i.postcss
      }

      if (typeof i === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins)
      } else if (typeof i === 'object' && i.postcssPlugin) {
        normalized.push(i)
      } else if (typeof i === 'function') {
        normalized.push(i)
      } else if (typeof i === 'object' && (i.parse || i.stringify)) {
        if (false) {}
      } else {
        throw new Error(i + ' is not a PostCSS plugin')
      }
    }
    return normalized
  }
}

module.exports = Processor
Processor.default = Processor

Root.registerProcessor(Processor)
Document.registerProcessor(Processor)


/***/ }),

/***/ 3632:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Warning = __webpack_require__(1728)

class Result {
  constructor(processor, root, opts) {
    this.processor = processor
    this.messages = []
    this.root = root
    this.opts = opts
    this.css = undefined
    this.map = undefined
  }

  toString() {
    return this.css
  }

  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin
      }
    }

    let warning = new Warning(text, opts)
    this.messages.push(warning)

    return warning
  }

  warnings() {
    return this.messages.filter(i => i.type === 'warning')
  }

  get content() {
    return this.css
  }
}

module.exports = Result
Result.default = Result


/***/ }),

/***/ 1025:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(1019)

let LazyResult, Processor

class Root extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'root'
    if (!this.nodes) this.nodes = []
  }

  removeChild(child, ignore) {
    let index = this.index(child)

    if (!ignore && index === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index].raws.before
    }

    return super.removeChild(child)
  }

  normalize(child, sample, type) {
    let nodes = super.normalize(child)

    if (sample) {
      if (type === 'prepend') {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before
        } else {
          delete sample.raws.before
        }
      } else if (this.first !== sample) {
        for (let node of nodes) {
          node.raws.before = sample.raws.before
        }
      }
    }

    return nodes
  }

  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts)
    return lazy.stringify()
  }
}

Root.registerLazyResult = dependant => {
  LazyResult = dependant
}

Root.registerProcessor = dependant => {
  Processor = dependant
}

module.exports = Root
Root.default = Root


/***/ }),

/***/ 1675:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Container = __webpack_require__(1019)
let list = __webpack_require__(4715)

class Rule extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'rule'
    if (!this.nodes) this.nodes = []
  }

  get selectors() {
    return list.comma(this.selector)
  }

  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null
    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen')
    this.selector = values.join(sep)
  }
}

module.exports = Rule
Rule.default = Rule

Container.registerRule(Rule)


/***/ }),

/***/ 1062:
/***/ ((module) => {

"use strict";


const DEFAULT_RAW = {
  colon: ': ',
  indent: '    ',
  beforeDecl: '\n',
  beforeRule: '\n',
  beforeOpen: ' ',
  beforeClose: '\n',
  beforeComment: '\n',
  after: '\n',
  emptyBody: '',
  commentLeft: ' ',
  commentRight: ' ',
  semicolon: false
}

function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1)
}

class Stringifier {
  constructor(builder) {
    this.builder = builder
  }

  stringify(node, semicolon) {
    /* istanbul ignore if */
    if (!this[node.type]) {
      throw new Error(
        'Unknown AST node type ' +
          node.type +
          '. ' +
          'Maybe you need to change PostCSS stringifier.'
      )
    }
    this[node.type](node, semicolon)
  }

  document(node) {
    this.body(node)
  }

  root(node) {
    this.body(node)
    if (node.raws.after) this.builder(node.raws.after)
  }

  comment(node) {
    let left = this.raw(node, 'left', 'commentLeft')
    let right = this.raw(node, 'right', 'commentRight')
    this.builder('/*' + left + node.text + right + '*/', node)
  }

  decl(node, semicolon) {
    let between = this.raw(node, 'between', 'colon')
    let string = node.prop + between + this.rawValue(node, 'value')

    if (node.important) {
      string += node.raws.important || ' !important'
    }

    if (semicolon) string += ';'
    this.builder(string, node)
  }

  rule(node) {
    this.block(node, this.rawValue(node, 'selector'))
    if (node.raws.ownSemicolon) {
      this.builder(node.raws.ownSemicolon, node, 'end')
    }
  }

  atrule(node, semicolon) {
    let name = '@' + node.name
    let params = node.params ? this.rawValue(node, 'params') : ''

    if (typeof node.raws.afterName !== 'undefined') {
      name += node.raws.afterName
    } else if (params) {
      name += ' '
    }

    if (node.nodes) {
      this.block(node, name + params)
    } else {
      let end = (node.raws.between || '') + (semicolon ? ';' : '')
      this.builder(name + params + end, node)
    }
  }

  body(node) {
    let last = node.nodes.length - 1
    while (last > 0) {
      if (node.nodes[last].type !== 'comment') break
      last -= 1
    }

    let semicolon = this.raw(node, 'semicolon')
    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i]
      let before = this.raw(child, 'before')
      if (before) this.builder(before)
      this.stringify(child, last !== i || semicolon)
    }
  }

  block(node, start) {
    let between = this.raw(node, 'between', 'beforeOpen')
    this.builder(start + between + '{', node, 'start')

    let after
    if (node.nodes && node.nodes.length) {
      this.body(node)
      after = this.raw(node, 'after')
    } else {
      after = this.raw(node, 'after', 'emptyBody')
    }

    if (after) this.builder(after)
    this.builder('}', node, 'end')
  }

  raw(node, own, detect) {
    let value
    if (!detect) detect = own

    // Already had
    if (own) {
      value = node.raws[own]
      if (typeof value !== 'undefined') return value
    }

    let parent = node.parent

    if (detect === 'before') {
      // Hack for first rule in CSS
      if (!parent || (parent.type === 'root' && parent.first === node)) {
        return ''
      }

      // `root` nodes in `document` should use only their own raws
      if (parent && parent.type === 'document') {
        return ''
      }
    }

    // Floating child without parent
    if (!parent) return DEFAULT_RAW[detect]

    // Detect style by other nodes
    let root = node.root()
    if (!root.rawCache) root.rawCache = {}
    if (typeof root.rawCache[detect] !== 'undefined') {
      return root.rawCache[detect]
    }

    if (detect === 'before' || detect === 'after') {
      return this.beforeAfter(node, detect)
    } else {
      let method = 'raw' + capitalize(detect)
      if (this[method]) {
        value = this[method](root, node)
      } else {
        root.walk(i => {
          value = i.raws[own]
          if (typeof value !== 'undefined') return false
        })
      }
    }

    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]

    root.rawCache[detect] = value
    return value
  }

  rawSemicolon(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length && i.last.type === 'decl') {
        value = i.raws.semicolon
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawEmptyBody(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length === 0) {
        value = i.raws.after
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawIndent(root) {
    if (root.raws.indent) return root.raws.indent
    let value
    root.walk(i => {
      let p = i.parent
      if (p && p !== root && p.parent && p.parent === root) {
        if (typeof i.raws.before !== 'undefined') {
          let parts = i.raws.before.split('\n')
          value = parts[parts.length - 1]
          value = value.replace(/\S/g, '')
          return false
        }
      }
    })
    return value
  }

  rawBeforeComment(root, node) {
    let value
    root.walkComments(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '')
        }
        return false
      }
    })
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeDecl')
    } else if (value) {
      value = value.replace(/\S/g, '')
    }
    return value
  }

  rawBeforeDecl(root, node) {
    let value
    root.walkDecls(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '')
        }
        return false
      }
    })
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeRule')
    } else if (value) {
      value = value.replace(/\S/g, '')
    }
    return value
  }

  rawBeforeRule(root) {
    let value
    root.walk(i => {
      if (i.nodes && (i.parent !== root || root.first !== i)) {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '')
          }
          return false
        }
      }
    })
    if (value) value = value.replace(/\S/g, '')
    return value
  }

  rawBeforeClose(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length > 0) {
        if (typeof i.raws.after !== 'undefined') {
          value = i.raws.after
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '')
          }
          return false
        }
      }
    })
    if (value) value = value.replace(/\S/g, '')
    return value
  }

  rawBeforeOpen(root) {
    let value
    root.walk(i => {
      if (i.type !== 'decl') {
        value = i.raws.between
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawColon(root) {
    let value
    root.walkDecls(i => {
      if (typeof i.raws.between !== 'undefined') {
        value = i.raws.between.replace(/[^\s:]/g, '')
        return false
      }
    })
    return value
  }

  beforeAfter(node, detect) {
    let value
    if (node.type === 'decl') {
      value = this.raw(node, null, 'beforeDecl')
    } else if (node.type === 'comment') {
      value = this.raw(node, null, 'beforeComment')
    } else if (detect === 'before') {
      value = this.raw(node, null, 'beforeRule')
    } else {
      value = this.raw(node, null, 'beforeClose')
    }

    let buf = node.parent
    let depth = 0
    while (buf && buf.type !== 'root') {
      depth += 1
      buf = buf.parent
    }

    if (value.includes('\n')) {
      let indent = this.raw(node, null, 'indent')
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent
      }
    }

    return value
  }

  rawValue(node, prop) {
    let value = node[prop]
    let raw = node.raws[prop]
    if (raw && raw.value === value) {
      return raw.raw
    }

    return value
  }
}

module.exports = Stringifier


/***/ }),

/***/ 7088:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


let Stringifier = __webpack_require__(1062)

function stringify(node, builder) {
  let str = new Stringifier(builder)
  str.stringify(node)
}

module.exports = stringify
stringify.default = stringify


/***/ }),

/***/ 5513:
/***/ ((module) => {

"use strict";


module.exports.isClean = Symbol('isClean')

module.exports.my = Symbol('my')


/***/ }),

/***/ 3852:
/***/ ((module) => {

"use strict";


const SINGLE_QUOTE = "'".charCodeAt(0)
const DOUBLE_QUOTE = '"'.charCodeAt(0)
const BACKSLASH = '\\'.charCodeAt(0)
const SLASH = '/'.charCodeAt(0)
const NEWLINE = '\n'.charCodeAt(0)
const SPACE = ' '.charCodeAt(0)
const FEED = '\f'.charCodeAt(0)
const TAB = '\t'.charCodeAt(0)
const CR = '\r'.charCodeAt(0)
const OPEN_SQUARE = '['.charCodeAt(0)
const CLOSE_SQUARE = ']'.charCodeAt(0)
const OPEN_PARENTHESES = '('.charCodeAt(0)
const CLOSE_PARENTHESES = ')'.charCodeAt(0)
const OPEN_CURLY = '{'.charCodeAt(0)
const CLOSE_CURLY = '}'.charCodeAt(0)
const SEMICOLON = ';'.charCodeAt(0)
const ASTERISK = '*'.charCodeAt(0)
const COLON = ':'.charCodeAt(0)
const AT = '@'.charCodeAt(0)

const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g
const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g
const RE_BAD_BRACKET = /.[\n"'(/\\]/
const RE_HEX_ESCAPE = /[\da-f]/i

module.exports = function tokenizer(input, options = {}) {
  let css = input.css.valueOf()
  let ignore = options.ignoreErrors

  let code, next, quote, content, escape
  let escaped, escapePos, prev, n, currentToken

  let length = css.length
  let pos = 0
  let buffer = []
  let returned = []

  function position() {
    return pos
  }

  function unclosed(what) {
    throw input.error('Unclosed ' + what, pos)
  }

  function endOfFile() {
    return returned.length === 0 && pos >= length
  }

  function nextToken(opts) {
    if (returned.length) return returned.pop()
    if (pos >= length) return

    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false

    code = css.charCodeAt(pos)

    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED: {
        next = pos
        do {
          next += 1
          code = css.charCodeAt(next)
        } while (
          code === SPACE ||
          code === NEWLINE ||
          code === TAB ||
          code === CR ||
          code === FEED
        )

        currentToken = ['space', css.slice(pos, next)]
        pos = next - 1
        break
      }

      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES: {
        let controlChar = String.fromCharCode(code)
        currentToken = [controlChar, controlChar, pos]
        break
      }

      case OPEN_PARENTHESES: {
        prev = buffer.length ? buffer.pop()[1] : ''
        n = css.charCodeAt(pos + 1)
        if (
          prev === 'url' &&
          n !== SINGLE_QUOTE &&
          n !== DOUBLE_QUOTE &&
          n !== SPACE &&
          n !== NEWLINE &&
          n !== TAB &&
          n !== FEED &&
          n !== CR
        ) {
          next = pos
          do {
            escaped = false
            next = css.indexOf(')', next + 1)
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos
                break
              } else {
                unclosed('bracket')
              }
            }
            escapePos = next
            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1
              escaped = !escaped
            }
          } while (escaped)

          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]

          pos = next
        } else {
          next = css.indexOf(')', pos + 1)
          content = css.slice(pos, next + 1)

          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ['(', '(', pos]
          } else {
            currentToken = ['brackets', content, pos, next]
            pos = next
          }
        }

        break
      }

      case SINGLE_QUOTE:
      case DOUBLE_QUOTE: {
        quote = code === SINGLE_QUOTE ? "'" : '"'
        next = pos
        do {
          escaped = false
          next = css.indexOf(quote, next + 1)
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1
              break
            } else {
              unclosed('string')
            }
          }
          escapePos = next
          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1
            escaped = !escaped
          }
        } while (escaped)

        currentToken = ['string', css.slice(pos, next + 1), pos, next]
        pos = next
        break
      }

      case AT: {
        RE_AT_END.lastIndex = pos + 1
        RE_AT_END.test(css)
        if (RE_AT_END.lastIndex === 0) {
          next = css.length - 1
        } else {
          next = RE_AT_END.lastIndex - 2
        }

        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]

        pos = next
        break
      }

      case BACKSLASH: {
        next = pos
        escape = true
        while (css.charCodeAt(next + 1) === BACKSLASH) {
          next += 1
          escape = !escape
        }
        code = css.charCodeAt(next + 1)
        if (
          escape &&
          code !== SLASH &&
          code !== SPACE &&
          code !== NEWLINE &&
          code !== TAB &&
          code !== CR &&
          code !== FEED
        ) {
          next += 1
          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
              next += 1
            }
            if (css.charCodeAt(next + 1) === SPACE) {
              next += 1
            }
          }
        }

        currentToken = ['word', css.slice(pos, next + 1), pos, next]

        pos = next
        break
      }

      default: {
        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
          next = css.indexOf('*/', pos + 2) + 1
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length
            } else {
              unclosed('comment')
            }
          }

          currentToken = ['comment', css.slice(pos, next + 1), pos, next]
          pos = next
        } else {
          RE_WORD_END.lastIndex = pos + 1
          RE_WORD_END.test(css)
          if (RE_WORD_END.lastIndex === 0) {
            next = css.length - 1
          } else {
            next = RE_WORD_END.lastIndex - 2
          }

          currentToken = ['word', css.slice(pos, next + 1), pos, next]
          buffer.push(currentToken)
          pos = next
        }

        break
      }
    }

    pos++
    return currentToken
  }

  function back(token) {
    returned.push(token)
  }

  return {
    back,
    nextToken,
    endOfFile,
    position
  }
}


/***/ }),

/***/ 2448:
/***/ ((module) => {

"use strict";


let printed = {}

module.exports = function warnOnce(message) {
  if (printed[message]) return
  printed[message] = true

  if (typeof console !== 'undefined' && console.warn) {
    console.warn(message)
  }
}


/***/ }),

/***/ 1728:
/***/ ((module) => {

"use strict";


class Warning {
  constructor(text, opts = {}) {
    this.type = 'warning'
    this.text = text

    if (opts.node && opts.node.source) {
      let pos = opts.node.positionBy(opts)
      this.line = pos.line
      this.column = pos.column
    }

    for (let opt in opts) this[opt] = opts[opt]
  }

  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        plugin: this.plugin,
        index: this.index,
        word: this.word
      }).message
    }

    if (this.plugin) {
      return this.plugin + ': ' + this.text
    }

    return this.text
  }
}

module.exports = Warning
Warning.default = Warning


/***/ }),

/***/ 1036:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const htmlparser = __webpack_require__(3719);
const escapeStringRegexp = __webpack_require__(2997);
const { isPlainObject } = __webpack_require__(977);
const deepmerge = __webpack_require__(9996);
const parseSrcset = __webpack_require__(9430);
const { parse: postcssParse } = __webpack_require__(20);
// Tags that can conceivably represent stand-alone media.
const mediaTags = [
  'img', 'audio', 'video', 'picture', 'svg',
  'object', 'map', 'iframe', 'embed'
];
// Tags that are inherently vulnerable to being used in XSS attacks.
const vulnerableTags = [ 'script', 'style' ];

function each(obj, cb) {
  if (obj) {
    Object.keys(obj).forEach(function (key) {
      cb(obj[key], key);
    });
  }
}

// Avoid false positives with .__proto__, .hasOwnProperty, etc.
function has(obj, key) {
  return ({}).hasOwnProperty.call(obj, key);
}

// Returns those elements of `a` for which `cb(a)` returns truthy
function filter(a, cb) {
  const n = [];
  each(a, function(v) {
    if (cb(v)) {
      n.push(v);
    }
  });
  return n;
}

function isEmptyObject(obj) {
  for (const key in obj) {
    if (has(obj, key)) {
      return false;
    }
  }
  return true;
}

function stringifySrcset(parsedSrcset) {
  return parsedSrcset.map(function(part) {
    if (!part.url) {
      throw new Error('URL missing');
    }

    return (
      part.url +
      (part.w ? ` ${part.w}w` : '') +
      (part.h ? ` ${part.h}h` : '') +
      (part.d ? ` ${part.d}x` : '')
    );
  }).join(', ');
}

module.exports = sanitizeHtml;

// A valid attribute name.
// We use a tolerant definition based on the set of strings defined by
// html.spec.whatwg.org/multipage/parsing.html#before-attribute-name-state
// and html.spec.whatwg.org/multipage/parsing.html#attribute-name-state .
// The characters accepted are ones which can be appended to the attribute
// name buffer without triggering a parse error:
//   * unexpected-equals-sign-before-attribute-name
//   * unexpected-null-character
//   * unexpected-character-in-attribute-name
// We exclude the empty string because it's impossible to get to the after
// attribute name state with an empty attribute name buffer.
const VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;

// Ignore the _recursing flag; it's there for recursive
// invocation as a guard against this exploit:
// https://github.com/fb55/htmlparser2/issues/105

function sanitizeHtml(html, options, _recursing) {
  if (html == null) {
    return '';
  }

  let result = '';
  // Used for hot swapping the result variable with an empty string in order to "capture" the text written to it.
  let tempResult = '';

  function Frame(tag, attribs) {
    const that = this;
    this.tag = tag;
    this.attribs = attribs || {};
    this.tagPosition = result.length;
    this.text = ''; // Node inner text
    this.mediaChildren = [];

    this.updateParentNodeText = function() {
      if (stack.length) {
        const parentFrame = stack[stack.length - 1];
        parentFrame.text += that.text;
      }
    };

    this.updateParentNodeMediaChildren = function() {
      if (stack.length && mediaTags.includes(this.tag)) {
        const parentFrame = stack[stack.length - 1];
        parentFrame.mediaChildren.push(this.tag);
      }
    };
  }

  options = Object.assign({}, sanitizeHtml.defaults, options);
  options.parser = Object.assign({}, htmlParserDefaults, options.parser);

  // vulnerableTags
  vulnerableTags.forEach(function (tag) {
    if (
      options.allowedTags && options.allowedTags.indexOf(tag) > -1 &&
      !options.allowVulnerableTags
    ) {
      console.warn(`\n\n Your \`allowedTags\` option includes, \`${tag}\`, which is inherently\nvulnerable to XSS attacks. Please remove it from \`allowedTags\`.\nOr, to disable this warning, add the \`allowVulnerableTags\` option\nand ensure you are accounting for this risk.\n\n`);
    }
  });

  // Tags that contain something other than HTML, or where discarding
  // the text when the tag is disallowed makes sense for other reasons.
  // If we are not allowing these tags, we should drop their content too.
  // For other tags you would drop the tag but keep its content.
  const nonTextTagsArray = options.nonTextTags || [
    'script',
    'style',
    'textarea',
    'option'
  ];
  let allowedAttributesMap;
  let allowedAttributesGlobMap;
  if (options.allowedAttributes) {
    allowedAttributesMap = {};
    allowedAttributesGlobMap = {};
    each(options.allowedAttributes, function(attributes, tag) {
      allowedAttributesMap[tag] = [];
      const globRegex = [];
      attributes.forEach(function(obj) {
        if (typeof obj === 'string' && obj.indexOf('*') >= 0) {
          globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, '.*'));
        } else {
          allowedAttributesMap[tag].push(obj);
        }
      });
      if (globRegex.length) {
        allowedAttributesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');
      }
    });
  }
  const allowedClassesMap = {};
  const allowedClassesGlobMap = {};
  const allowedClassesRegexMap = {};
  each(options.allowedClasses, function(classes, tag) {
    // Implicitly allows the class attribute
    if (allowedAttributesMap) {
      if (!has(allowedAttributesMap, tag)) {
        allowedAttributesMap[tag] = [];
      }
      allowedAttributesMap[tag].push('class');
    }

    allowedClassesMap[tag] = [];
    allowedClassesRegexMap[tag] = [];
    const globRegex = [];
    classes.forEach(function(obj) {
      if (typeof obj === 'string' && obj.indexOf('*') >= 0) {
        globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, '.*'));
      } else if (obj instanceof RegExp) {
        allowedClassesRegexMap[tag].push(obj);
      } else {
        allowedClassesMap[tag].push(obj);
      }
    });
    if (globRegex.length) {
      allowedClassesGlobMap[tag] = new RegExp('^(' + globRegex.join('|') + ')$');
    }
  });

  const transformTagsMap = {};
  let transformTagsAll;
  each(options.transformTags, function(transform, tag) {
    let transFun;
    if (typeof transform === 'function') {
      transFun = transform;
    } else if (typeof transform === 'string') {
      transFun = sanitizeHtml.simpleTransform(transform);
    }
    if (tag === '*') {
      transformTagsAll = transFun;
    } else {
      transformTagsMap[tag] = transFun;
    }
  });

  let depth;
  let stack;
  let skipMap;
  let transformMap;
  let skipText;
  let skipTextDepth;
  let addedText = false;

  initializeState();

  const parser = new htmlparser.Parser({
    onopentag: function(name, attribs) {
      // If `enforceHtmlBoundary` is `true` and this has found the opening
      // `html` tag, reset the state.
      if (options.enforceHtmlBoundary && name === 'html') {
        initializeState();
      }

      if (skipText) {
        skipTextDepth++;
        return;
      }
      const frame = new Frame(name, attribs);
      stack.push(frame);

      let skip = false;
      const hasText = !!frame.text;
      let transformedTag;
      if (has(transformTagsMap, name)) {
        transformedTag = transformTagsMap[name](name, attribs);

        frame.attribs = attribs = transformedTag.attribs;

        if (transformedTag.text !== undefined) {
          frame.innerText = transformedTag.text;
        }

        if (name !== transformedTag.tagName) {
          frame.name = name = transformedTag.tagName;
          transformMap[depth] = transformedTag.tagName;
        }
      }
      if (transformTagsAll) {
        transformedTag = transformTagsAll(name, attribs);

        frame.attribs = attribs = transformedTag.attribs;
        if (name !== transformedTag.tagName) {
          frame.name = name = transformedTag.tagName;
          transformMap[depth] = transformedTag.tagName;
        }
      }

      if ((options.allowedTags && options.allowedTags.indexOf(name) === -1) || (options.disallowedTagsMode === 'recursiveEscape' && !isEmptyObject(skipMap)) || (options.nestingLimit != null && depth >= options.nestingLimit)) {
        skip = true;
        skipMap[depth] = true;
        if (options.disallowedTagsMode === 'discard') {
          if (nonTextTagsArray.indexOf(name) !== -1) {
            skipText = true;
            skipTextDepth = 1;
          }
        }
        skipMap[depth] = true;
      }
      depth++;
      if (skip) {
        if (options.disallowedTagsMode === 'discard') {
          // We want the contents but not this tag
          return;
        }
        tempResult = result;
        result = '';
      }
      result += '<' + name;

      if (name === 'script') {
        if (options.allowedScriptHostnames || options.allowedScriptDomains) {
          frame.innerText = '';
        }
      }

      if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap['*']) {
        each(attribs, function(value, a) {
          if (!VALID_HTML_ATTRIBUTE_NAME.test(a)) {
            // This prevents part of an attribute name in the output from being
            // interpreted as the end of an attribute, or end of a tag.
            delete frame.attribs[a];
            return;
          }
          let parsed;
          // check allowedAttributesMap for the element and attribute and modify the value
          // as necessary if there are specific values defined.
          let passedAllowedAttributesMapCheck = false;
          if (!allowedAttributesMap ||
            (has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a) !== -1) ||
            (allowedAttributesMap['*'] && allowedAttributesMap['*'].indexOf(a) !== -1) ||
            (has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a)) ||
            (allowedAttributesGlobMap['*'] && allowedAttributesGlobMap['*'].test(a))) {
            passedAllowedAttributesMapCheck = true;
          } else if (allowedAttributesMap && allowedAttributesMap[name]) {
            for (const o of allowedAttributesMap[name]) {
              if (isPlainObject(o) && o.name && (o.name === a)) {
                passedAllowedAttributesMapCheck = true;
                let newValue = '';
                if (o.multiple === true) {
                  // verify the values that are allowed
                  const splitStrArray = value.split(' ');
                  for (const s of splitStrArray) {
                    if (o.values.indexOf(s) !== -1) {
                      if (newValue === '') {
                        newValue = s;
                      } else {
                        newValue += ' ' + s;
                      }
                    }
                  }
                } else if (o.values.indexOf(value) >= 0) {
                  // verified an allowed value matches the entire attribute value
                  newValue = value;
                }
                value = newValue;
              }
            }
          }
          if (passedAllowedAttributesMapCheck) {
            if (options.allowedSchemesAppliedToAttributes.indexOf(a) !== -1) {
              if (naughtyHref(name, value)) {
                delete frame.attribs[a];
                return;
              }
            }

            if (name === 'script' && a === 'src') {

              let allowed = true;

              try {
                const parsed = new URL(value);

                if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                  const allowedHostname = (options.allowedScriptHostnames || []).find(function (hostname) {
                    return hostname === parsed.hostname;
                  });
                  const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                    return parsed.hostname === domain || parsed.hostname.endsWith(`.${domain}`);
                  });
                  allowed = allowedHostname || allowedDomain;
                }
              } catch (e) {
                allowed = false;
              }

              if (!allowed) {
                delete frame.attribs[a];
                return;
              }
            }

            if (name === 'iframe' && a === 'src') {
              let allowed = true;
              try {
                // Chrome accepts \ as a substitute for / in the // at the
                // start of a URL, so rewrite accordingly to prevent exploit.
                // Also drop any whitespace at that point in the URL
                value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, '$1//');
                if (value.startsWith('relative:')) {
                  // An attempt to exploit our workaround for base URLs being
                  // mandatory for relative URL validation in the WHATWG
                  // URL parser, reject it
                  throw new Error('relative: exploit attempt');
                }
                // naughtyHref is in charge of whether protocol relative URLs
                // are cool. Here we are concerned just with allowed hostnames and
                // whether to allow relative URLs.
                //
                // Build a placeholder "base URL" against which any reasonable
                // relative URL may be parsed successfully
                let base = 'relative://relative-site';
                for (let i = 0; (i < 100); i++) {
                  base += `/${i}`;
                }
                const parsed = new URL(value, base);
                const isRelativeUrl = parsed && parsed.hostname === 'relative-site' && parsed.protocol === 'relative:';
                if (isRelativeUrl) {
                  // default value of allowIframeRelativeUrls is true
                  // unless allowedIframeHostnames or allowedIframeDomains specified
                  allowed = has(options, 'allowIframeRelativeUrls')
                    ? options.allowIframeRelativeUrls
                    : (!options.allowedIframeHostnames && !options.allowedIframeDomains);
                } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                  const allowedHostname = (options.allowedIframeHostnames || []).find(function (hostname) {
                    return hostname === parsed.hostname;
                  });
                  const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                    return parsed.hostname === domain || parsed.hostname.endsWith(`.${domain}`);
                  });
                  allowed = allowedHostname || allowedDomain;
                }
              } catch (e) {
                // Unparseable iframe src
                allowed = false;
              }
              if (!allowed) {
                delete frame.attribs[a];
                return;
              }
            }
            if (a === 'srcset') {
              try {
                parsed = parseSrcset(value);
                parsed.forEach(function(value) {
                  if (naughtyHref('srcset', value.url)) {
                    value.evil = true;
                  }
                });
                parsed = filter(parsed, function(v) {
                  return !v.evil;
                });
                if (!parsed.length) {
                  delete frame.attribs[a];
                  return;
                } else {
                  value = stringifySrcset(filter(parsed, function(v) {
                    return !v.evil;
                  }));
                  frame.attribs[a] = value;
                }
              } catch (e) {
                // Unparseable srcset
                delete frame.attribs[a];
                return;
              }
            }
            if (a === 'class') {
              const allowedSpecificClasses = allowedClassesMap[name];
              const allowedWildcardClasses = allowedClassesMap['*'];
              const allowedSpecificClassesGlob = allowedClassesGlobMap[name];
              const allowedSpecificClassesRegex = allowedClassesRegexMap[name];
              const allowedWildcardClassesGlob = allowedClassesGlobMap['*'];
              const allowedClassesGlobs = [
                allowedSpecificClassesGlob,
                allowedWildcardClassesGlob
              ]
                .concat(allowedSpecificClassesRegex)
                .filter(function (t) {
                  return t;
                });
              if (allowedSpecificClasses && allowedWildcardClasses) {
                value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
              } else {
                value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
              }
              if (!value.length) {
                delete frame.attribs[a];
                return;
              }
            }
            if (a === 'style') {
              try {
                const abstractSyntaxTree = postcssParse(name + ' {' + value + '}');
                const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);

                value = stringifyStyleAttributes(filteredAST);

                if (value.length === 0) {
                  delete frame.attribs[a];
                  return;
                }
              } catch (e) {
                delete frame.attribs[a];
                return;
              }
            }
            result += ' ' + a;
            if (value && value.length) {
              result += '="' + escapeHtml(value, true) + '"';
            }
          } else {
            delete frame.attribs[a];
          }
        });
      }
      if (options.selfClosing.indexOf(name) !== -1) {
        result += ' />';
      } else {
        result += '>';
        if (frame.innerText && !hasText && !options.textFilter) {
          result += escapeHtml(frame.innerText);
          addedText = true;
        }
      }
      if (skip) {
        result = tempResult + escapeHtml(result);
        tempResult = '';
      }
    },
    ontext: function(text) {
      if (skipText) {
        return;
      }
      const lastFrame = stack[stack.length - 1];
      let tag;

      if (lastFrame) {
        tag = lastFrame.tag;
        // If inner text was set by transform function then let's use it
        text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;
      }

      if (options.disallowedTagsMode === 'discard' && ((tag === 'script') || (tag === 'style'))) {
        // htmlparser2 gives us these as-is. Escaping them ruins the content. Allowing
        // script tags is, by definition, game over for XSS protection, so if that's
        // your concern, don't allow them. The same is essentially true for style tags
        // which have their own collection of XSS vectors.
        result += text;
      } else {
        const escaped = escapeHtml(text, false);
        if (options.textFilter && !addedText) {
          result += options.textFilter(escaped, tag);
        } else if (!addedText) {
          result += escaped;
        }
      }
      if (stack.length) {
        const frame = stack[stack.length - 1];
        frame.text += text;
      }
    },
    onclosetag: function(name) {

      if (skipText) {
        skipTextDepth--;
        if (!skipTextDepth) {
          skipText = false;
        } else {
          return;
        }
      }

      const frame = stack.pop();
      if (!frame) {
        // Do not crash on bad markup
        return;
      }
      skipText = options.enforceHtmlBoundary ? name === 'html' : false;
      depth--;
      const skip = skipMap[depth];
      if (skip) {
        delete skipMap[depth];
        if (options.disallowedTagsMode === 'discard') {
          frame.updateParentNodeText();
          return;
        }
        tempResult = result;
        result = '';
      }

      if (transformMap[depth]) {
        name = transformMap[depth];
        delete transformMap[depth];
      }

      if (options.exclusiveFilter && options.exclusiveFilter(frame)) {
        result = result.substr(0, frame.tagPosition);
        return;
      }

      frame.updateParentNodeMediaChildren();
      frame.updateParentNodeText();

      if (options.selfClosing.indexOf(name) !== -1) {
        // Already output />
        if (skip) {
          result = tempResult;
          tempResult = '';
        }
        return;
      }

      result += '</' + name + '>';
      if (skip) {
        result = tempResult + escapeHtml(result);
        tempResult = '';
      }
    }
  }, options.parser);
  parser.write(html);
  parser.end();

  return result;

  function initializeState() {
    result = '';
    depth = 0;
    stack = [];
    skipMap = {};
    transformMap = {};
    skipText = false;
    skipTextDepth = 0;
  }

  function escapeHtml(s, quote) {
    if (typeof (s) !== 'string') {
      s = s + '';
    }
    if (options.parser.decodeEntities) {
      s = s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      if (quote) {
        s = s.replace(/"/g, '&quot;');
      }
    }
    // TODO: this is inadequate because it will pass `&0;`. This approach
    // will not work, each & must be considered with regard to whether it
    // is followed by a 100% syntactically valid entity or not, and escaped
    // if it is not. If this bothers you, don't set parser.decodeEntities
    // to false. (The default is true.)
    s = s.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, '&amp;') // Match ampersands not part of existing HTML entity
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');
    if (quote) {
      s = s.replace(/"/g, '&quot;');
    }
    return s;
  }

  function naughtyHref(name, href) {
    // Browsers ignore character codes of 32 (space) and below in a surprising
    // number of situations. Start reading here:
    // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet#Embedded_tab
    // eslint-disable-next-line no-control-regex
    href = href.replace(/[\x00-\x20]+/g, '');
    // Clobber any comments in URLs, which the browser might
    // interpret inside an XML data island, allowing
    // a javascript: URL to be snuck through
    href = href.replace(/<!--.*?-->/g, '');
    // Case insensitive so we don't get faked out by JAVASCRIPT #1
    // Allow more characters after the first so we don't get faked
    // out by certain schemes browsers accept
    const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
    if (!matches) {
      // Protocol-relative URL starting with any combination of '/' and '\'
      if (href.match(/^[/\\]{2}/)) {
        return !options.allowProtocolRelative;
      }

      // No scheme
      return false;
    }
    const scheme = matches[1].toLowerCase();

    if (has(options.allowedSchemesByTag, name)) {
      return options.allowedSchemesByTag[name].indexOf(scheme) === -1;
    }

    return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
  }

  /**
   * Filters user input css properties by allowlisted regex attributes.
   * Modifies the abstractSyntaxTree object.
   *
   * @param {object} abstractSyntaxTree  - Object representation of CSS attributes.
   * @property {array[Declaration]} abstractSyntaxTree.nodes[0] - Each object cointains prop and value key, i.e { prop: 'color', value: 'red' }.
   * @param {object} allowedStyles       - Keys are properties (i.e color), value is list of permitted regex rules (i.e /green/i).
   * @return {object}                    - The modified tree.
   */
  function filterCss(abstractSyntaxTree, allowedStyles) {
    if (!allowedStyles) {
      return abstractSyntaxTree;
    }

    const astRules = abstractSyntaxTree.nodes[0];
    let selectedRule;

    // Merge global and tag-specific styles into new AST.
    if (allowedStyles[astRules.selector] && allowedStyles['*']) {
      selectedRule = deepmerge(
        allowedStyles[astRules.selector],
        allowedStyles['*']
      );
    } else {
      selectedRule = allowedStyles[astRules.selector] || allowedStyles['*'];
    }

    if (selectedRule) {
      abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
    }

    return abstractSyntaxTree;
  }

  /**
   * Extracts the style attribues from an AbstractSyntaxTree and formats those
   * values in the inline style attribute format.
   *
   * @param  {AbstractSyntaxTree} filteredAST
   * @return {string}             - Example: "color:yellow;text-align:center;font-family:helvetica;"
   */
  function stringifyStyleAttributes(filteredAST) {
    return filteredAST.nodes[0].nodes
      .reduce(function(extractedAttributes, attributeObject) {
        extractedAttributes.push(
          attributeObject.prop + ':' + attributeObject.value
        );
        return extractedAttributes;
      }, [])
      .join(';');
  }

  /**
    * Filters the existing attributes for the given property. Discards any attributes
    * which don't match the allowlist.
    *
    * @param  {object} selectedRule             - Example: { color: red, font-family: helvetica }
    * @param  {array} allowedDeclarationsList   - List of declarations which pass the allowlist.
    * @param  {object} attributeObject          - Object representing the current css property.
    * @property {string} attributeObject.type   - Typically 'declaration'.
    * @property {string} attributeObject.prop   - The CSS property, i.e 'color'.
    * @property {string} attributeObject.value  - The corresponding value to the css property, i.e 'red'.
    * @return {function}                        - When used in Array.reduce, will return an array of Declaration objects
    */
  function filterDeclarations(selectedRule) {
    return function (allowedDeclarationsList, attributeObject) {
      // If this property is allowlisted...
      if (has(selectedRule, attributeObject.prop)) {
        const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
          return regularExpression.test(attributeObject.value);
        });

        if (matchesRegex) {
          allowedDeclarationsList.push(attributeObject);
        }
      }
      return allowedDeclarationsList;
    };
  }

  function filterClasses(classes, allowed, allowedGlobs) {
    if (!allowed) {
      // The class attribute is allowed without filtering on this tag
      return classes;
    }
    classes = classes.split(/\s+/);
    return classes.filter(function(clss) {
      return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
        return glob.test(clss);
      });
    }).join(' ');
  }
}

// Defaults are accessible to you so that you can use them as a starting point
// programmatically if you wish

const htmlParserDefaults = {
  decodeEntities: true
};
sanitizeHtml.defaults = {
  allowedTags: [
    // Sections derived from MDN element categories and limited to the more
    // benign categories.
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
    // Content sectioning
    'address', 'article', 'aside', 'footer', 'header',
    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hgroup',
    'main', 'nav', 'section',
    // Text content
    'blockquote', 'dd', 'div', 'dl', 'dt', 'figcaption', 'figure',
    'hr', 'li', 'main', 'ol', 'p', 'pre', 'ul',
    // Inline text semantics
    'a', 'abbr', 'b', 'bdi', 'bdo', 'br', 'cite', 'code', 'data', 'dfn',
    'em', 'i', 'kbd', 'mark', 'q',
    'rb', 'rp', 'rt', 'rtc', 'ruby',
    's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'time', 'u', 'var', 'wbr',
    // Table content
    'caption', 'col', 'colgroup', 'table', 'tbody', 'td', 'tfoot', 'th',
    'thead', 'tr'
  ],
  disallowedTagsMode: 'discard',
  allowedAttributes: {
    a: [ 'href', 'name', 'target' ],
    // We don't currently allow img itself by default, but this
    // would make sense if we did. You could add srcset here,
    // and if you do the URL is checked for safety
    img: [ 'src' ]
  },
  // Lots of these won't come up by default because we don't allow them
  selfClosing: [ 'img', 'br', 'hr', 'area', 'base', 'basefont', 'input', 'link', 'meta' ],
  // URL schemes we permit
  allowedSchemes: [ 'http', 'https', 'ftp', 'mailto', 'tel' ],
  allowedSchemesByTag: {},
  allowedSchemesAppliedToAttributes: [ 'href', 'src', 'cite' ],
  allowProtocolRelative: true,
  enforceHtmlBoundary: false
};

sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge) {
  merge = (merge === undefined) ? true : merge;
  newAttribs = newAttribs || {};

  return function(tagName, attribs) {
    let attrib;
    if (merge) {
      for (attrib in newAttribs) {
        attribs[attrib] = newAttribs[attrib];
      }
    } else {
      attribs = newAttribs;
    }

    return {
      tagName: newTagName,
      attribs: attribs
    };
  };
};


/***/ }),

/***/ 2997:
/***/ ((module) => {

"use strict";


module.exports = string => {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Escape characters with special meaning either inside or outside character sets.
	// Use a simple backslash escape when its always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.
	return string
		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
		.replace(/-/g, '\\x2d');
};


/***/ }),

/***/ 977:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (ctor === undefined) return true;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}

exports.isPlainObject = isPlainObject;


/***/ }),

/***/ 4670:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(5607);


/***/ }),

/***/ 9829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var randomFromSeed = __webpack_require__(8946);

var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet;
var previousSeed;

var shuffled;

function reset() {
    shuffled = false;
}

function setCharacters(_alphabet_) {
    if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
        }
        return;
    }

    if (_alphabet_ === alphabet) {
        return;
    }

    if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortid must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet = _alphabet_;
    reset();
}

function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet;
}

function setSeed(seed) {
    randomFromSeed.seed(seed);
    if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
    }
}

function shuffle() {
    if (!alphabet) {
        setCharacters(ORIGINAL);
    }

    var sourceArray = alphabet.split('');
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;

    while (sourceArray.length > 0) {
        r = randomFromSeed.nextValue();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled() {
    if (shuffled) {
        return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
}

function get () {
  return alphabet || ORIGINAL;
}

module.exports = {
    get: get,
    characters: characters,
    seed: setSeed,
    lookup: lookup,
    shuffled: getShuffled
};


/***/ }),

/***/ 480:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var generate = __webpack_require__(8416);
var alphabet = __webpack_require__(9829);

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME = 1567752802062;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version = 7;

// Counter is used when shortid is called multiple times in one second.
var counter;

// Remember the last time shortid was called in case counter is needed.
var previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
function build(clusterWorkerId) {
    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + generate(version);
    str = str + generate(clusterWorkerId);
    if (counter > 0) {
        str = str + generate(counter);
    }
    str = str + generate(seconds);
    return str;
}

module.exports = build;


/***/ }),

/***/ 8416:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var alphabet = __webpack_require__(9829);
var random = __webpack_require__(3766);
var format = __webpack_require__(296);

function generate(number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + format(random, alphabet.get(), 1);
        done = number < (Math.pow(16, loopCounter + 1 ) );
        loopCounter++;
    }
    return str;
}

module.exports = generate;


/***/ }),

/***/ 5607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var alphabet = __webpack_require__(9829);
var build = __webpack_require__(480);
var isValid = __webpack_require__(1082);

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
// Note: I don't know if this is automatically set when using third
// party cluster solutions such as pm2.
var clusterWorkerId = __webpack_require__(5636) || 0;

/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as shortid.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
function seed(seedValue) {
    alphabet.seed(seedValue);
    return module.exports;
}

/**
 * Set the cluster worker or machine id
 * exposed as shortid.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns shortid module so it can be chained.
 */
function worker(workerId) {
    clusterWorkerId = workerId;
    return module.exports;
}

/**
 *
 * sets new characters to use in the alphabet
 * returns the shuffled alphabet
 */
function characters(newCharacters) {
    if (newCharacters !== undefined) {
        alphabet.characters(newCharacters);
    }

    return alphabet.shuffled();
}

/**
 * Generate unique id
 * Returns string id
 */
function generate() {
  return build(clusterWorkerId);
}

// Export all other functions as properties of the generate function
module.exports = generate;
module.exports.generate = generate;
module.exports.seed = seed;
module.exports.worker = worker;
module.exports.characters = characters;
module.exports.isValid = isValid;


/***/ }),

/***/ 1082:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var alphabet = __webpack_require__(9829);

function isShortId(id) {
    if (!id || typeof id !== 'string' || id.length < 6 ) {
        return false;
    }

    var nonAlphabetic = new RegExp('[^' +
      alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&') +
    ']');
    return !nonAlphabetic.test(id);
}

module.exports = isShortId;


/***/ }),

/***/ 3766:
/***/ ((module) => {

"use strict";


var crypto = typeof window === 'object' && (window.crypto || window.msCrypto); // IE 11 uses window.msCrypto

var randomByte;

if (!crypto || !crypto.getRandomValues) {
    randomByte = function(size) {
        var bytes = [];
        for (var i = 0; i < size; i++) {
            bytes.push(Math.floor(Math.random() * 256));
        }
        return bytes;
    };
} else {
    randomByte = function(size) {
        return crypto.getRandomValues(new Uint8Array(size));
    };
}

module.exports = randomByte;


/***/ }),

/***/ 8946:
/***/ ((module) => {

"use strict";


// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

var seed = 1;

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */
function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed/(233280.0);
}

function setSeed(_seed_) {
    seed = _seed_;
}

module.exports = {
    nextValue: getNextValue,
    seed: setSeed
};


/***/ }),

/***/ 5636:
/***/ ((module) => {

"use strict";


module.exports = 0;


/***/ }),

/***/ 296:
/***/ ((module) => {

// This file replaces `format.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.

module.exports = function (random, alphabet, size) {
  // We cant use bytes bigger than the alphabet. To make bytes values closer
  // to the alphabet, we apply bitmask on them. We look for the closest
  // `2 ** x - 1` number, which will be bigger than alphabet size. If we have
  // 30 symbols in the alphabet, we will take 31 (00011111).
  // We do not use faster Math.clz32, because it is not available in browsers.
  var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1
  // Bitmask is not a perfect solution (in our example it will pass 31 bytes,
  // which is bigger than the alphabet). As a result, we will need more bytes,
  // than ID size, because we will refuse bytes bigger than the alphabet.

  // Every hardware random generator call is costly,
  // because we need to wait for entropy collection. This is why often it will
  // be faster to ask for few extra bytes in advance, to avoid additional calls.

  // Here we calculate how many random bytes should we call in advance.
  // It depends on ID length, mask / alphabet size and magic number 1.6
  // (which was selected according benchmarks).

  // -~f => Math.ceil(f) if n is float number
  // -~i => i + 1 if n is integer number
  var step = -~(1.6 * mask * size / alphabet.length)
  var id = ''

  while (true) {
    var bytes = random(step)
    // Compact alternative for `for (var i = 0; i < step; i++)`
    var i = step
    while (i--) {
      // If random byte is bigger than alphabet even after bitmask,
      // we refuse it by `|| ''`.
      id += alphabet[bytes[i] & mask] || ''
      // More compact than `id.length + 1 === size`
      if (id.length === +size) return id
    }
  }
}


/***/ }),

/***/ 6777:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ AdvancedFill)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/AdvancedFill.vue?vue&type=template&id=d0dc8062&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("g", [
    _vm.fill.type === "image" && _vm.fill.image
      ? _c("defs", [
          _c(
            "pattern",
            {
              attrs: {
                id: _vm.fillId,
                patternUnits: "userSpaceOnUse",
                width: _vm.area.w,
                height: _vm.area.h,
              },
            },
            [
              _c("image", {
                attrs: {
                  "xlink:href": _vm.fill.image,
                  x: "0",
                  y: "0",
                  width: _vm.area.w,
                  height: _vm.area.h,
                  preserveAspectRatio: _vm.imagePreserveAspectRatio,
                },
              }),
            ]
          ),
        ])
      : _vm._e(),
    _vm._v(" "),
    _vm.fill.type === "gradient" && _vm.fill.gradient
      ? _c(
          "defs",
          [
            _vm.fill.gradient.type === "linear"
              ? _c(
                  "linearGradient",
                  {
                    attrs: {
                      id: _vm.fillId,
                      x1: _vm.direction.x1 + "%",
                      y1: _vm.direction.y1 + "%",
                      x2: _vm.direction.x2 + "%",
                      y2: _vm.direction.y2 + "%",
                    },
                  },
                  _vm._l(_vm.fill.gradient.colors, function (color) {
                    return _c("stop", {
                      style: { "stop-color": color.c },
                      attrs: { offset: color.p + "%" },
                    })
                  }),
                  1
                )
              : _vm._e(),
            _vm._v(" "),
            _vm.fill.gradient.type === "radial"
              ? _c(
                  "radialGradient",
                  {
                    attrs: {
                      id: _vm.fillId,
                      cx: "50%",
                      cy: "50%",
                      r: "50%",
                      fx: "50%",
                      fy: "50%",
                    },
                  },
                  _vm._l(_vm.fill.gradient.colors, function (color) {
                    return _c("stop", {
                      style: { "stop-color": color.c },
                      attrs: { offset: color.p + "%" },
                    })
                  }),
                  1
                )
              : _vm._e(),
          ],
          1
        )
      : _vm._e(),
  ])
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/AdvancedFill.vue?vue&type=template&id=d0dc8062&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/AdvancedFill.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
/* harmony default export */ const AdvancedFillvue_type_script_lang_js_ = ({
  props: ['fillId', 'fill', 'area'],

  computeSvgFill(fill, fillId) {
    if (!fill) {
      return 'none';
    }

    if (fill.type === 'solid') {
      return fill.color;
    } else if (fill.type === 'image' && fill.image || fill.type === 'gradient' && fill.gradient) {
      return `url(#${fillId})`;
    }

    return 'none';
  },

  // Uses 'fill' property of shapeProps
  computeStandardFill(item) {
    return this.computeStandardFillForValue(item.shapeProps.fill, `fill-pattern-${item.id}`);
  },

  computeStandardFillForValue(fill, fillId) {
    return this.computeSvgFill(fill, fillId);
  },

  computed: {
    direction() {
      let direction = parseInt(this.fill.gradient.direction);

      if (!isFinite(direction)) {
        direction = 0;
      }

      if (this.fill.type === 'gradient' && this.fill.gradient) {
        const vx = 50 * Math.cos(Math.PI * (direction - 90) / 180);
        const vy = 50 * Math.sin(Math.PI * (direction - 90) / 180);
        return {
          x1: 50 - vx,
          y1: 50 - vy,
          x2: 50 + vx,
          y2: 50 + vy
        };
      }

      return {
        x1: 0,
        y1: 0,
        x2: 100,
        y2: 0
      };
    },

    imagePreserveAspectRatio() {
      if (this.fill.stretch) {
        return 'none';
      }

      return 'xMidYMid meet';
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/AdvancedFill.vue?vue&type=script&lang=js&
 /* harmony default export */ const items_AdvancedFillvue_type_script_lang_js_ = (AdvancedFillvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/AdvancedFill.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  items_AdvancedFillvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/AdvancedFill.vue"
/* harmony default export */ const AdvancedFill = (component.exports);

/***/ }),

/***/ 8148:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ CodeBlock)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/CodeBlock.vue?vue&type=template&id=39db888d&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "g",
    [
      _c("advanced-fill", {
        attrs: {
          fillId: "fill-pattern-" + _vm.item.id,
          fill: _vm.item.shapeProps.fill,
          area: _vm.item.area,
        },
      }),
      _vm._v(" "),
      _c("path", {
        attrs: {
          d: _vm.shapePath,
          "stroke-width": _vm.item.shapeProps.strokeSize + "px",
          stroke: _vm.item.shapeProps.strokeColor,
          fill: _vm.svgFill,
        },
      }),
      _vm._v(" "),
      _c("circle", { attrs: { cx: "15", cy: "15", r: "5", fill: "#EC6762" } }),
      _vm._v(" "),
      _c("circle", { attrs: { cx: "30", cy: "15", r: "5", fill: "#F4BE5E" } }),
      _vm._v(" "),
      _c("circle", { attrs: { cx: "45", cy: "15", r: "5", fill: "#61C761" } }),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/CodeBlock.vue?vue&type=template&id=39db888d&

// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/ShapeDefaults.js
var ShapeDefaults = __webpack_require__(9498);
// EXTERNAL MODULE: ./src/ui/components/editor/items/AdvancedFill.vue + 4 modules
var AdvancedFill = __webpack_require__(6777);
// EXTERNAL MODULE: ./src/ui/components/editor/EventBus.js
var EventBus = __webpack_require__(536);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/CodeBlock.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




const computePath = item => {
  const W = item.area.w;
  const H = item.area.h;
  const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 4, item.area.h / 4);
  return `M ${W - R} ${H}  L ${R} ${H} a ${R} ${R} 0 0 1 ${-R} ${-R}  L 0 ${R}  a ${R} ${R} 0 0 1 ${R} ${-R}   L ${W - R} 0   a ${R} ${R} 0 0 1 ${R} ${R}  L ${W} ${H - R}   a ${R} ${R} 0 0 1 ${-R} ${R} Z`;
};

const darkBackground = 'rgba(40, 40, 40, 1.0)';
const lightBackground = 'rgba(240, 240, 240, 1.0)';

function onThemeUpdate($store, item, value, previousValue) {
  if (value === 'dark') {
    item.shapeProps.fill = {
      type: 'solid',
      color: darkBackground
    };
    item.textSlots.title.color = 'rgba(245, 245, 245, 1.0)';
    item.textSlots.body.color = 'rgba(245, 245, 245, 1.0)';
  } else {
    item.shapeProps.fill = {
      type: 'solid',
      color: lightBackground
    };
    item.textSlots.title.color = 'rgba(0, 0, 0, 1.0)';
    item.textSlots.body.color = 'rgba(0, 0, 0, 1.0)';
  }

  EventBus/* default.emitItemChanged */.Z.emitItemChanged(item.id);
}

function onLangUpdate($store, item, value, previousValue) {
  const foreignObject = document.getElementById(`item-text-slot-${item.id}-body`);

  if (foreignObject) {
    highlightItemTextSlot($store, item, foreignObject);
  }
}

function highlightItemTextSlot($store, item, foreignObject) {
  const language = langMapping[item.shapeProps.lang];

  if (!language) {
    return;
  }

  let assetsPath = $store.state.assetsPath;

  if (assetsPath === '/') {
    assetsPath = '';
  }

  const worker = new Worker(`${assetsPath}/syntax-highlight-worker.js`);

  worker.onmessage = event => {
    const itemTextElement = foreignObject.querySelector('.item-text-element');

    if (itemTextElement) {
      itemTextElement.innerHTML = event.data;
    }
  };

  const code = document.createElement('code');
  code.appendChild(document.createTextNode(item.textSlots.body.text));
  worker.postMessage({
    text: code.innerText,
    lang: language
  });
}

const langMapping = {
  'Bash': 'bash',
  'C': 'c',
  'C++': 'cpp',
  'C#': 'csharp',
  'CSS': 'css',
  'Diff': 'diff',
  'GO': 'go',
  'GraphQL': 'graphql',
  'Ini': 'ini',
  'Java': 'java',
  'JavaScript': 'javascript',
  'JSON': 'json',
  'Kotlin': 'kotlin',
  'Less': 'less',
  'Lua': 'lua',
  'Makefile': 'makefile',
  'Markdown': 'markdown',
  'Objective C': 'objectivec',
  'Perl': 'perl',
  'PHP': 'php',
  'PHP Template': 'php-template',
  'Text': 'plaintext',
  'Python': 'python',
  'Python REPL': 'python-repl',
  'R': 'r',
  'Ruby': 'ruby',
  'Rust': 'rust',
  'SCSS': 'scss',
  'Shell': 'shell',
  'SQL': 'sql',
  'Swift': 'swift',
  'TypeScript': 'typescript',
  'VB.NET': 'vbnet',
  'WebAssembly': 'wasm',
  'XML': 'xml',
  'YAML': 'yaml'
};
const allLanguages = Object.keys(langMapping);
/* harmony default export */ const CodeBlockvue_type_script_lang_js_ = ({
  props: ['item'],
  components: {
    AdvancedFill: AdvancedFill/* default */.Z
  },
  shapeConfig: {
    shapeType: 'vue',
    id: 'code_block',
    menuItems: [{
      group: 'General',
      name: 'Code Block',
      iconUrl: '/assets/images/items/code-block.svg',
      item: {
        textSlots: {
          title: {
            text: '<b>Code</b>',
            halign: 'center',
            valign: 'middle',
            color: 'rgba(245, 245, 245, 1.0)',
            paddingTop: 4,
            paddingLeft: 10,
            paddingRight: 10,
            paddingBottom: 4
          },
          body: {
            font: 'Courier New',
            text: '',
            color: 'rgba(245, 245, 245, 1.0)',
            halign: 'left',
            valign: 'top',
            whiteSpace: 'pre-wrap',
            paddingTop: 10,
            paddingLeft: 10,
            paddingRight: 10,
            paddingBottom: 10
          }
        }
      }
    }],

    getPins(item) {
      return (0,ShapeDefaults/* getStandardRectPins */.F)(item);
    },

    computePath,

    getTextSlots(item) {
      return [{
        name: 'title',
        area: {
          x: 0,
          y: 0,
          w: item.area.w,
          h: Math.max(0, item.shapeProps.headerHeight)
        }
      }, {
        name: 'body',
        markupDisabled: true,
        cssClass: `syntax-theme-${item.shapeProps.theme}`,
        area: {
          x: 0,
          y: item.shapeProps.headerHeight,
          w: item.area.w,
          h: Math.max(1, item.area.h - item.shapeProps.headerHeight)
        }
      }];
    },

    editorProps: {},
    args: {
      theme: {
        type: 'choice',
        value: 'dark',
        options: ['dark', 'light'],
        name: 'Theme',
        onUpdate: onThemeUpdate
      },
      lang: {
        type: 'choice',
        value: 'Text',
        options: allLanguages,
        name: 'Language',
        onUpdate: onLangUpdate
      },
      fill: {
        type: 'advanced-color',
        value: {
          type: 'solid',
          color: darkBackground
        },
        name: 'Fill'
      },
      strokeColor: {
        type: 'color',
        value: 'rgba(80, 80, 80, 1.0)',
        name: 'Stroke color'
      },
      strokeSize: {
        type: 'number',
        value: 1,
        name: 'Stroke size'
      },
      cornerRadius: {
        type: 'number',
        value: 4,
        name: 'Corner radius'
      },
      headerHeight: {
        type: 'number',
        value: 30,
        name: 'Header hight',
        min: 0
      }
    },

    mounted($store, item, elements) {
      if (Array.isArray(elements.textSlots)) {
        elements.textSlots.forEach(foreignObject => {
          if (foreignObject.getAttribute('data-text-slot-name') === 'body') {
            highlightItemTextSlot($store, item, foreignObject);
          }
        });
      }
    }

  },
  computed: {
    shapePath() {
      return computePath(this.item);
    },

    svgFill() {
      return AdvancedFill/* default.computeStandardFill */.Z.computeStandardFill(this.item);
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/CodeBlock.vue?vue&type=script&lang=js&
 /* harmony default export */ const shapes_CodeBlockvue_type_script_lang_js_ = (CodeBlockvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/CodeBlock.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  shapes_CodeBlockvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/shapes/CodeBlock.vue"
/* harmony default export */ const CodeBlock = (component.exports);

/***/ }),

/***/ 332:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "YL": () => (/* reexport */ COMPONENT_DESTROYED),
  "LM": () => (/* reexport */ COMPONENT_FAILED),
  "lK": () => (/* reexport */ COMPONENT_LOADED_EVENT),
  "ZP": () => (/* binding */ Component),
  "Si": () => (/* reexport */ generateComponentGoBackButton)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/Component.vue?vue&type=template&id=51c5472c&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "g",
    {
      on: {
        click: function ($event) {
          return _vm.$emit("custom-event", "clicked")
        },
        mouseover: function ($event) {
          return _vm.$emit("custom-event", "mousein")
        },
        mouseleave: function ($event) {
          return _vm.$emit("custom-event", "mouseout")
        },
      },
    },
    [
      _c("advanced-fill", {
        attrs: {
          fillId: "fill-pattern-" + _vm.item.id,
          fill: _vm.item.shapeProps.fill,
          area: _vm.item.area,
        },
      }),
      _vm._v(" "),
      _c("advanced-fill", {
        attrs: {
          fillId: "fill-pattern-button-" + _vm.item.id,
          fill: _vm.item.shapeProps.buttonFill,
          area: _vm.item.area,
        },
      }),
      _vm._v(" "),
      _c("advanced-fill", {
        attrs: {
          fillId: "fill-pattern-button-hovered-" + _vm.item.id,
          fill: _vm.item.shapeProps.buttonHoverFill,
          area: _vm.item.area,
        },
      }),
      _vm._v(" "),
      _c("path", {
        attrs: {
          d: _vm.shapePath,
          "stroke-width": _vm.item.shapeProps.strokeSize + "px",
          stroke: _vm.item.shapeProps.strokeColor,
          "stroke-dasharray": _vm.strokeDashArray,
          fill: _vm.svgFill,
        },
      }),
      _vm._v(" "),
      _vm.hideTextSlot !== "body" && _vm.bodyTextShown
        ? _c(
            "foreignObject",
            {
              attrs: {
                x: 0,
                y: 0,
                width: _vm.item.area.w,
                height: _vm.bodyTextSlotHeight,
              },
            },
            [
              _c("div", {
                staticClass: "item-text-container",
                style: _vm.bodyTextStyle,
                attrs: { xmlns: "http://www.w3.org/1999/xhtml" },
                domProps: { innerHTML: _vm._s(_vm.sanitizedBodyText) },
              }),
            ]
          )
        : _vm._e(),
      _vm._v(" "),
      !(_vm.isLoading && _vm.item.shapeProps.showProgressBar) &&
      _vm.buttonShown &&
      _vm.buttonArea.w > 0 &&
      _vm.buttonArea.h > 0
        ? _c("g", { staticStyle: { cursor: "pointer" } }, [
            _vm.buttonHovered
              ? _c("rect", {
                  attrs: {
                    fill: _vm.svgButtonHoverFill,
                    x: _vm.buttonArea.x,
                    y: _vm.buttonArea.y,
                    rx: _vm.item.shapeProps.buttonCornerRadius,
                    width: _vm.buttonArea.w,
                    height: _vm.buttonArea.h,
                    "stroke-width": _vm.item.shapeProps.buttonStrokeSize + "px",
                    stroke: _vm.item.shapeProps.buttonStrokeColor,
                  },
                })
              : _c("rect", {
                  attrs: {
                    fill: _vm.svgButtonFill,
                    x: _vm.buttonArea.x,
                    y: _vm.buttonArea.y,
                    rx: _vm.item.shapeProps.buttonCornerRadius,
                    width: _vm.buttonArea.w,
                    height: _vm.buttonArea.h,
                    "stroke-width": _vm.item.shapeProps.buttonStrokeSize + "px",
                    stroke: _vm.item.shapeProps.buttonHoverStrokeColor,
                  },
                }),
            _vm._v(" "),
            _vm.hideTextSlot !== "button"
              ? _c(
                  "foreignObject",
                  {
                    attrs: {
                      x: _vm.buttonArea.x,
                      y: _vm.buttonArea.y,
                      width: _vm.buttonArea.w,
                      height: _vm.buttonArea.h,
                    },
                  },
                  [
                    _c("div", {
                      staticClass: "item-text-container",
                      style: _vm.textStyle,
                      attrs: { xmlns: "http://www.w3.org/1999/xhtml" },
                      domProps: { innerHTML: _vm._s(_vm.sanitizedButtonText) },
                    }),
                  ]
                )
              : _vm._e(),
            _vm._v(" "),
            _c("rect", {
              attrs: {
                "data-preview-ignore": "true",
                fill: "rgba(255,255,255,0)",
                x: _vm.buttonArea.x,
                y: _vm.buttonArea.y,
                rx: _vm.item.shapeProps.buttonCornerRadius,
                width: _vm.buttonArea.w,
                height: _vm.buttonArea.h,
              },
              on: {
                click: _vm.onLoadSchemeClick,
                mouseover: _vm.onButtonMouseOver,
                mouseleave: _vm.onButtonMouseLeave,
              },
            }),
          ])
        : _vm._e(),
      _vm._v(" "),
      _vm.isLoading &&
      _vm.item.shapeProps.showProgressBar &&
      _vm.progressBar.w > 0 &&
      _vm.progressBar.h > 0
        ? _c(
            "foreignObject",
            {
              attrs: {
                x: _vm.progressBar.x,
                y: _vm.progressBar.y,
                width: _vm.progressBar.w,
                height: _vm.progressBar.h,
              },
            },
            [
              _c("div", {
                staticClass: "progress-bar",
                style: _vm.progressBarStyle,
              }),
            ]
          )
        : _vm._e(),
      _vm._v(" "),
      !_vm.isLoading && _vm.item.meta && _vm.item.meta.componentLoadFailed
        ? _c(
            "g",
            {
              staticStyle: { cursor: "pointer" },
              on: { click: _vm.resetFailureMessage },
            },
            [
              _c("rect", {
                attrs: {
                  x: 0,
                  y: 0,
                  width: _vm.item.area.w,
                  height: _vm.item.area.h,
                  fill: "rgba(250, 70, 70)",
                },
              }),
              _vm._v(" "),
              _c(
                "foreignObject",
                {
                  attrs: {
                    x: 0,
                    y: 0,
                    width: _vm.item.area.w,
                    height: _vm.item.area.h,
                  },
                },
                [
                  _c(
                    "div",
                    {
                      staticClass: "item-text-container",
                      style: _vm.failureMessageStyle,
                      attrs: { xmlns: "http://www.w3.org/1999/xhtml" },
                    },
                    [_c("b", [_vm._v("Loading failed")])]
                  ),
                ]
              ),
            ]
          )
        : _vm._e(),
      _vm._v(" "),
      _vm.item.meta && _vm.item.meta.cyclicComponent
        ? _c("g", [
            _c("rect", {
              attrs: {
                x: 0,
                y: 0,
                width: _vm.item.area.w,
                height: _vm.item.area.h,
                fill: "rgba(250, 70, 70)",
              },
            }),
            _vm._v(" "),
            _c(
              "foreignObject",
              {
                attrs: {
                  x: 0,
                  y: 0,
                  width: _vm.item.area.w,
                  height: _vm.item.area.h,
                },
              },
              [
                _c(
                  "div",
                  {
                    staticClass: "item-text-container",
                    style: _vm.failureMessageStyle,
                    attrs: { xmlns: "http://www.w3.org/1999/xhtml" },
                  },
                  [_c("b", [_vm._v("Cyclic dependency!")])]
                ),
              ]
            ),
          ])
        : _vm._e(),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Component.vue?vue&type=template&id=51c5472c&

// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/ShapeDefaults.js
var ShapeDefaults = __webpack_require__(9498);
// EXTERNAL MODULE: ./src/ui/components/editor/items/StrokePattern.js
var StrokePattern = __webpack_require__(4502);
// EXTERNAL MODULE: ./src/ui/components/editor/items/AdvancedFill.vue + 4 modules
var AdvancedFill = __webpack_require__(6777);
// EXTERNAL MODULE: ./src/ui/components/editor/EventBus.js
var EventBus = __webpack_require__(536);
// EXTERNAL MODULE: ./src/ui/components/editor/text/ItemText.js
var ItemText = __webpack_require__(5635);
// EXTERNAL MODULE: ./src/htmlSanitize.js
var htmlSanitize = __webpack_require__(3762);
var htmlSanitize_default = /*#__PURE__*/__webpack_require__.n(htmlSanitize);
// EXTERNAL MODULE: ./src/ui/myMath.js
var myMath = __webpack_require__(3590);
// EXTERNAL MODULE: ./node_modules/shortid/index.js
var shortid = __webpack_require__(4670);
var shortid_default = /*#__PURE__*/__webpack_require__.n(shortid);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/Component.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//









const computePath = item => {
  const W = item.area.w;
  const H = item.area.h;
  const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 2, item.area.h / 2);
  return `M ${W - R} ${H}  L ${R} ${H} a ${R} ${R} 0 0 1 ${-R} ${-R}  L 0 ${R}  a ${R} ${R} 0 0 1 ${R} ${-R}   L ${W - R} 0   a ${R} ${R} 0 0 1 ${R} ${R}  L ${W} ${H - R}   a ${R} ${R} 0 0 1 ${-R} ${R} Z`;
};

function calculateButtonArea(item, maxWidth, maxHeight) {
  const minPadding = 5;
  const itemMaxWidth = item.area.w - 2 * minPadding;
  const itemMaxHeight = item.area.h - 2 * minPadding;
  const w = Math.min(maxWidth, itemMaxWidth);
  const h = Math.min(maxHeight, itemMaxHeight);
  const x = (item.area.w - w) / 2;
  const y = Math.max(minPadding, item.area.h - h - 10);
  return {
    x,
    y,
    w,
    h
  };
}

const COMPONENT_LOADED_EVENT = 'Component Loaded';
const COMPONENT_FAILED = 'Component Failed';
const COMPONENT_DESTROYED = 'Component Destroyed';
function generateComponentGoBackButton(componentItem, containerArea, currentScreenTransform) {
  if (!componentItem.shapeProps.showBackButton || componentItem.shapeProps.kind !== 'external') {
    return null;
  }

  const btnWidth = 95;
  const btnHeight = 30;
  return {
    id: componentItem.id + '-go-back-btn',
    shape: 'rect',
    area: {
      x: containerArea.w - btnWidth - componentItem.shapeProps.backButtonHPad,
      y: componentItem.shapeProps.backButtonVPad,
      w: btnWidth,
      h: btnHeight,
      sx: 1,
      sy: 1,
      r: 0,
      px: 0.5,
      py: 0.5
    },
    textSlots: {
      body: {
        text: '<b>go back</b>',
        color: componentItem.shapeProps.backButtonTextColor
      }
    },
    opacity: 70,
    visibile: true,
    cursor: 'pointer',
    shapeProps: {
      cornerRadius: 15,
      strokeSize: 0,
      fill: componentItem.shapeProps.backButtonFill
    },
    behavior: {
      events: [{
        id: shortid_default().generate(),
        event: 'clicked',
        actions: [{
          id: shortid_default().generate(),
          element: '#' + componentItem.id,
          method: '_transformScreen',
          args: {
            x: currentScreenTransform.x,
            y: currentScreenTransform.y,
            scale: currentScreenTransform.scale
          }
        }, {
          id: shortid_default().generate(),
          element: '#' + componentItem.id,
          method: 'destroyComponent',
          args: {}
        }]
      }, {
        id: shortid_default().generate(),
        event: 'mousein',
        actions: [{
          id: shortid_default().generate(),
          element: 'self',
          method: 'set',
          args: {
            field: 'selfOpacity',
            value: 100,
            animated: true,
            animationDuration: 0.2,
            transition: 'ease-in-out',
            inBackground: false
          }
        }]
      }, {
        id: shortid_default().generate(),
        event: 'mouseout',
        actions: [{
          id: shortid_default().generate(),
          element: 'self',
          method: 'set',
          args: {
            field: 'selfOpacity',
            value: 70,
            animated: true,
            animationDuration: 0.2,
            transition: 'ease-in-out',
            inBackground: false
          }
        }]
      }]
    }
  };
}
/* harmony default export */ const Componentvue_type_script_lang_js_ = ({
  props: ['item'],
  components: {
    AdvancedFill: AdvancedFill/* default */.Z
  },
  shapeConfig: {
    shapeType: 'vue',
    id: 'component',
    menuItems: [{
      group: 'General',
      name: 'Component',
      iconUrl: '/assets/images/items/component.svg',
      description: `
                Lets you embed other schemes into this item.
            `,
      item: {
        textSlots: {
          body: {
            text: 'Component',
            valign: 'middle',
            halign: 'center',
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            paddingBottom: 0
          },
          button: {
            text: 'Load more',
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            paddingBottom: 0
          }
        }
      }
    }],

    getPins(item) {
      return (0,ShapeDefaults/* getStandardRectPins */.F)(item);
    },

    getTextSlots(item) {
      const btnArea = calculateButtonArea(item, item.shapeProps.buttonWidth, item.shapeProps.buttonHeight);
      let h = item.area.h;
      let hasButton = false;

      if (item.shapeProps.kind === 'external' && item.shapeProps.showButton) {
        h = btnArea.y;
        hasButton = true;
      }

      const textSlots = [{
        name: 'body',
        area: {
          x: 0,
          y: 0,
          w: item.area.w,
          h
        }
      }];

      if (hasButton) {
        textSlots.push({
          name: 'button',
          area: btnArea
        });
      }

      return textSlots;
    },

    computePath,
    controlPoints: {
      make(item) {
        const points = {
          cornerRadius: {
            x: Math.min(item.area.w, Math.max(item.area.w - item.shapeProps.cornerRadius, item.area.w / 2)),
            y: 0
          }
        };

        if (item.shapeProps.kind === 'external' && item.shapeProps.showButton) {
          const btnArea = calculateButtonArea(item, item.shapeProps.buttonWidth, item.shapeProps.buttonHeight);
          points['buttonCornerRadius'] = {
            x: btnArea.x + btnArea.w - Math.min(item.shapeProps.buttonCornerRadius, btnArea.w / 2, btnArea.h / 2),
            y: btnArea.y
          };
        }

        return points;
      },

      handleDrag(item, controlPointName, originalX, originalY, dx, dy) {
        if (controlPointName === 'cornerRadius') {
          item.shapeProps.cornerRadius = Math.max(0, myMath/* default.roundPrecise */.Z.roundPrecise(item.area.w - Math.max(item.area.w / 2, originalX + dx), 1));
        } else if (controlPointName === 'buttonCornerRadius') {
          const btnArea = calculateButtonArea(item, item.shapeProps.buttonWidth, item.shapeProps.buttonHeight);
          item.shapeProps.buttonCornerRadius = Math.min(btnArea.h / 2, btnArea.w / 2, Math.max(0, myMath/* default.roundPrecise */.Z.roundPrecise(btnArea.x + btnArea.w - originalX - dx)));
        }
      }

    },
    args: {
      kind: {
        type: 'choice',
        value: 'external',
        name: 'Kind',
        options: ['external', 'embedded'],
        description: 'External - allows to fetch other documents and render them inside the component. Embedded - uses the items in the same document'
      },
      schemeId: {
        type: 'scheme-ref',
        value: '',
        name: 'External Document',
        depends: {
          kind: 'external'
        },
        description: 'ID of the document that this component should load'
      },
      referenceItem: {
        type: 'element',
        name: 'Item',
        depends: {
          kind: 'embedded'
        },
        description: 'Reference item that this component should render'
      },
      fill: {
        type: 'advanced-color',
        value: {
          type: 'solid',
          color: 'rgba(255,255,255,1)'
        },
        name: 'Fill'
      },
      strokeColor: {
        type: 'color',
        value: '#466AAA',
        name: 'Stroke color'
      },
      strokeSize: {
        type: 'number',
        value: 2,
        name: 'Stroke size'
      },
      strokePattern: {
        type: 'stroke-pattern',
        value: 'solid',
        name: 'Stroke pattern'
      },
      cornerRadius: {
        type: 'number',
        value: 0,
        name: 'Corner radius',
        min: 0
      },
      placement: {
        type: 'choice',
        value: 'centered',
        options: ['centered', 'stretch'],
        name: 'Placement'
      },
      autoZoom: {
        type: 'boolean',
        value: true,
        name: 'Auto zoom',
        description: 'Zoom into component when it is loaded',
        depends: {
          kind: 'external'
        }
      },
      showButton: {
        type: 'boolean',
        value: true,
        name: 'Show button',
        description: 'Displays a button which user can click to load component in view mode',
        depends: {
          kind: 'external'
        }
      },
      buttonFill: {
        type: 'advanced-color',
        value: {
          type: 'solid',
          color: 'rgba(14,195,255,0.15)'
        },
        name: 'Button Fill',
        depends: {
          showButton: true,
          kind: 'external'
        }
      },
      buttonStrokeColor: {
        type: 'color',
        value: 'rgba(24,127,191,0.9)',
        name: 'Button stroke color',
        depends: {
          showButton: true,
          kind: 'external'
        }
      },
      buttonHoverFill: {
        type: 'advanced-color',
        value: {
          type: 'solid',
          color: 'rgba(14,195,255,0.45)'
        },
        name: 'Hovered button Fill',
        depends: {
          showButton: true,
          kind: 'external'
        }
      },
      buttonHoverStrokeColor: {
        type: 'color',
        value: 'rgba(24,127,191,0.9)',
        name: 'Hovered button stroke color',
        depends: {
          showButton: true,
          kind: 'external'
        }
      },
      buttonStrokeSize: {
        type: 'number',
        value: 2,
        name: 'Button stroke size',
        depends: {
          showButton: true,
          kind: 'external'
        }
      },
      buttonCornerRadius: {
        type: 'number',
        value: 0,
        name: 'Button Corner radius',
        min: 0,
        depends: {
          showButton: true,
          kind: 'external'
        }
      },
      buttonWidth: {
        type: 'number',
        value: 180,
        name: 'Button width',
        depends: {
          showButton: true,
          kind: 'external'
        }
      },
      buttonHeight: {
        type: 'number',
        value: 40,
        name: 'Button height',
        depends: {
          showButton: true,
          kind: 'external'
        }
      },
      showProgressBar: {
        type: 'boolean',
        value: true,
        name: 'Show progress bar',
        depends: {
          kind: 'external'
        }
      },
      progressColor1: {
        type: 'color',
        value: 'rgba(24,127,191,1)',
        name: 'Progress bar color 1',
        depends: {
          showProgressBar: true,
          kind: 'external'
        }
      },
      progressColor2: {
        type: 'color',
        value: 'rgba(140,214,219,1)',
        name: 'Progress bar color 2',
        depends: {
          showProgressBar: true,
          kind: 'external'
        }
      },
      showBackButton: {
        type: 'boolean',
        value: true,
        name: 'Show back button',
        depends: {
          kind: 'external'
        }
      },
      backButtonFill: {
        type: 'advanced-color',
        value: {
          type: 'solid',
          color: 'rgba(102,102,102,1.0)'
        },
        name: 'Button Fill',
        depends: {
          showBackButton: true,
          kind: 'external'
        }
      },
      backButtonTextColor: {
        type: 'color',
        value: 'rgba(245,245,245,1.0)',
        name: 'Back button text color',
        depends: {
          showBackButton: true,
          kind: 'external'
        }
      },
      backButtonVPad: {
        type: 'number',
        value: 20,
        name: 'Back Button Vertical Padding',
        depends: {
          showBackButton: true,
          kind: 'external'
        }
      },
      backButtonHPad: {
        type: 'number',
        value: 20,
        name: 'Back Button Horizontal Padding',
        depends: {
          showBackButton: true,
          kind: 'external'
        }
      }
    },
    editorProps: {
      customTextRendering: true,
      ignoreEventLayer: true // tells not to draw a layer for events handling, as this shape will handle everything itself

    },

    /**
     * Returns events that given item is able to emit
     * The result of this function is dynamic based on the item settings.
     * This is used in order to build suggestions in BehaviorPanel.
     */
    getEvents(item) {
      return [{
        name: COMPONENT_LOADED_EVENT
      }, {
        name: COMPONENT_FAILED
      }, {
        name: COMPONENT_DESTROYED
      }];
    }

  },

  beforeMount() {
    EventBus/* default.subscribeForItemChanged */.Z.subscribeForItemChanged(this.item.id, this.onItemChanged);
    EventBus/* default.$on */.Z.$on(EventBus/* default.ITEM_TEXT_SLOT_EDIT_TRIGGERED */.Z.ITEM_TEXT_SLOT_EDIT_TRIGGERED, this.onItemTextSlotEditTriggered);
    EventBus/* default.$on */.Z.$on(EventBus/* default.ITEM_TEXT_SLOT_EDIT_CANCELED */.Z.ITEM_TEXT_SLOT_EDIT_CANCELED, this.onItemTextSlotEditCanceled);
    EventBus/* default.$on */.Z.$on(EventBus/* default.COMPONENT_LOAD_REQUESTED */.Z.COMPONENT_LOAD_REQUESTED, this.onAnyComponentLoadRequested);
    EventBus/* default.$on */.Z.$on(EventBus/* default.COMPONENT_LOAD_FAILED */.Z.COMPONENT_LOAD_FAILED, this.onAnyComponentLoadFailed);
    EventBus/* default.$on */.Z.$on(EventBus/* default.COMPONENT_SCHEME_MOUNTED */.Z.COMPONENT_SCHEME_MOUNTED, this.onAnyComponentMounted);
  },

  beforeDestroy() {
    EventBus/* default.unsubscribeForItemChanged */.Z.unsubscribeForItemChanged(this.item.id, this.onItemChanged);
    EventBus/* default.$off */.Z.$off(EventBus/* default.ITEM_TEXT_SLOT_EDIT_TRIGGERED */.Z.ITEM_TEXT_SLOT_EDIT_TRIGGERED, this.onItemTextSlotEditTriggered);
    EventBus/* default.$off */.Z.$off(EventBus/* default.ITEM_TEXT_SLOT_EDIT_CANCELED */.Z.ITEM_TEXT_SLOT_EDIT_CANCELED, this.onItemTextSlotEditCanceled);
    EventBus/* default.$off */.Z.$off(EventBus/* default.COMPONENT_LOAD_REQUESTED */.Z.COMPONENT_LOAD_REQUESTED, this.onAnyComponentLoadRequested);
    EventBus/* default.$off */.Z.$off(EventBus/* default.COMPONENT_LOAD_FAILED */.Z.COMPONENT_LOAD_FAILED, this.onAnyComponentLoadFailed);
    EventBus/* default.$off */.Z.$off(EventBus/* default.COMPONENT_SCHEME_MOUNTED */.Z.COMPONENT_SCHEME_MOUNTED, this.onAnyComponentMounted);
  },

  data() {
    const externalItemsMounted = this.item._childItems && this.item._childItems.length > 0;
    return {
      buttonHovered: false,
      buttonShown: this.item.shapeProps.kind === 'external' && this.item.shapeProps.showButton && !externalItemsMounted,
      bodyTextShown: !externalItemsMounted,
      isLoading: false,
      hideTextSlot: null,
      textStyle: this.createTextStyle(),
      bodyTextStyle: this.createBodyTextStyle()
    };
  },

  methods: {
    onLoadSchemeClick() {
      this.isLoading = true;
      EventBus/* default.emitComponentLoadRequested */.Z.emitComponentLoadRequested(this.item);
    },

    onItemChanged() {
      if (this.item._childItems && this.item._childItems.length > 0) {
        this.buttonShown = false;
        this.bodyTextShown = false;
      }

      this.isLoading = false;
      this.buttonHovered = false;
      this.textStyle = this.createTextStyle();
      this.bodyTextStyle = this.createBodyTextStyle();
    },

    createBodyTextStyle() {
      let style = {};

      if (this.item.textSlots && this.item.textSlots.body) {
        style = (0,ItemText/* generateTextStyle */.A)(this.item.textSlots.body);
        const btnArea = calculateButtonArea(this.item, this.item.shapeProps.buttonWidth, this.item.shapeProps.buttonHeight);
        style.width = `${this.item.area.w}px`;
        let h = this.item.area.h;

        if (this.item.shapeProps.kind === 'external' && this.item.shapeProps.showButton) {
          h = btnArea.y;
        }

        style.height = `${h}px`;
      }

      return style;
    },

    createTextStyle() {
      let style = {};

      if (this.item.textSlots && this.item.textSlots.button) {
        style = (0,ItemText/* generateTextStyle */.A)(this.item.textSlots.button);
        const textArea = calculateButtonArea(this.item, this.item.shapeProps.buttonWidth, this.item.shapeProps.buttonHeight);
        style.width = `${textArea.w}px`;
        style.height = `${textArea.h}px`;
      }

      return style;
    },

    onItemTextSlotEditTriggered(item, slotName, area, markupDisabled) {
      if (item.id === this.item.id) {
        this.hideTextSlot = slotName;
      }
    },

    onItemTextSlotEditCanceled(item, slotName) {
      if (item.id === this.item.id) {
        this.hideTextSlot = null;
      }
    },

    onButtonMouseOver() {
      this.buttonHovered = true;
      this.$forceUpdate();
    },

    onButtonMouseLeave() {
      this.buttonHovered = false;
      this.$forceUpdate();
    },

    onAnyComponentLoadRequested(item) {
      if (this.item.id === item.id) {
        this.isLoading = true;
      }
    },

    onAnyComponentLoadFailed(item) {
      if (this.item.id === item.id) {
        this.isLoading = false;
      }
    },

    onAnyComponentMounted(item) {
      if (this.item.id === item.id) {
        this.isLoading = false;
      }
    },

    resetFailureMessage() {
      this.item.meta.componentLoadFailed = false;
      this.$forceUpdate();
    }

  },
  computed: {
    shapePath() {
      return computePath(this.item);
    },

    svgFill() {
      return AdvancedFill/* default.computeSvgFill */.Z.computeSvgFill(this.item.shapeProps.fill, `fill-pattern-${this.item.id}`);
    },

    svgButtonFill() {
      return AdvancedFill/* default.computeSvgFill */.Z.computeSvgFill(this.item.shapeProps.buttonFill, `fill-pattern-button-${this.item.id}`);
    },

    svgButtonHoverFill() {
      return AdvancedFill/* default.computeSvgFill */.Z.computeSvgFill(this.item.shapeProps.buttonHoverFill, `fill-pattern-button-hovered-${this.item.id}`);
    },

    strokeDashArray() {
      return StrokePattern/* default.createDashArray */.Z.createDashArray(this.item.shapeProps.strokePattern, this.item.shapeProps.strokeSize);
    },

    buttonArea() {
      return calculateButtonArea(this.item, this.item.shapeProps.buttonWidth, this.item.shapeProps.buttonHeight);
    },

    bodyTextSlotHeight() {
      const btnArea = calculateButtonArea(this.item, this.item.shapeProps.buttonWidth, this.item.shapeProps.buttonHeight);

      if (this.item.shapeProps.kind === 'external' && this.item.shapeProps.showButton) {
        return btnArea.y;
      }

      return this.item.area.h;
    },

    sanitizedBodyText() {
      if (this.item.textSlots && this.item.textSlots.body) {
        return htmlSanitize_default()(this.item.textSlots.body.text);
      }

      return '';
    },

    sanitizedButtonText() {
      if (this.isLoading) {
        return 'Loading ...';
      }

      let text = '';

      if (this.item.textSlots && this.item.textSlots.button) {
        text = this.item.textSlots.button.text;
      }

      return htmlSanitize_default()(text);
    },

    failureMessageStyle() {
      return {
        color: 'rgb(255, 255, 255)',
        'font-size': '14px',
        'font-family': 'Arial, Helvetica, sans-serif',
        padding: '10px',
        'text-align': 'center',
        'vertical-align': 'middle',
        'white-space': 'normal',
        display: 'table-cell',
        'box-sizing': 'border-box',
        width: `${this.item.area.w}px`,
        height: `${this.item.area.h}px`
      };
    },

    progressBar() {
      return calculateButtonArea(this.item, 180, 10);
    },

    progressBarStyle() {
      return {
        background: `linear-gradient(90deg, ${this.item.shapeProps.progressColor1} 0%, ${this.item.shapeProps.progressColor2} 25%, ${this.item.shapeProps.progressColor2} 50%, ${this.item.shapeProps.progressColor1} 75%) 0% 0% / 60% 100%`
      };
    },

    progressBarHeight() {
      return Math.min(20, this.item.area.h);
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Component.vue?vue&type=script&lang=js&
 /* harmony default export */ const shapes_Componentvue_type_script_lang_js_ = (Componentvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Component.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  shapes_Componentvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/shapes/Component.vue"
/* harmony default export */ const Component = (component.exports);

/***/ }),

/***/ 7533:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ Connector)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/Connector.vue?vue&type=template&id=5d2c0bba&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "g",
    [
      _c("advanced-fill", {
        attrs: {
          fillId: "fill-pattern-" + _vm.item.id,
          fill: _vm.item.shapeProps.fill,
          area: _vm.item.area,
        },
      }),
      _vm._v(" "),
      _c("path", {
        staticStyle: { "stroke-linejoin": "round" },
        attrs: {
          d: _vm.shapePath,
          "stroke-width": _vm.item.shapeProps.strokeSize + "px",
          stroke: _vm.item.shapeProps.strokeColor,
          "stroke-dasharray": _vm.strokeDashArray,
          fill: _vm.svgFill,
        },
      }),
      _vm._v(" "),
      !_vm.item.shapeProps.fat
        ? _c(
            "g",
            _vm._l(_vm.caps, function (cap) {
              return _c("path", {
                attrs: {
                  d: cap.path,
                  "data-item-id": _vm.item.id,
                  stroke: _vm.item.shapeProps.strokeColor,
                  "stroke-width": _vm.item.shapeProps.strokeSize,
                  fill: cap.hollow ? "none" : _vm.item.shapeProps.strokeColor,
                  "stroke-linejoin": "round",
                },
              })
            }),
            0
          )
        : _vm._e(),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Connector.vue?vue&type=template&id=5d2c0bba&

// EXTERNAL MODULE: ./node_modules/lodash/forEach.js
var forEach = __webpack_require__(4486);
var forEach_default = /*#__PURE__*/__webpack_require__.n(forEach);
// EXTERNAL MODULE: ./src/ui/components/editor/items/StrokePattern.js
var StrokePattern = __webpack_require__(4502);
// EXTERNAL MODULE: ./src/ui/components/editor/EventBus.js
var EventBus = __webpack_require__(536);
// EXTERNAL MODULE: ./src/ui/logger.js
var logger = __webpack_require__(2017);
// EXTERNAL MODULE: ./src/ui/myMath.js
var myMath = __webpack_require__(3590);
// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/ConnectorCaps.js
var ConnectorCaps = __webpack_require__(125);
// EXTERNAL MODULE: ./src/ui/utils.js
var utils = __webpack_require__(4691);
// EXTERNAL MODULE: ./src/ui/components/editor/items/AdvancedFill.vue + 4 modules
var AdvancedFill = __webpack_require__(6777);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/Connector.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//










const log = new logger/* Logger */.Yd('Connector');

function getPointOnItemPath(item, shadowSvgPath, positionOnPath, schemeContainer) {
  if (shadowSvgPath) {
    const point = shadowSvgPath.getPointAtLength(positionOnPath);
    return schemeContainer.worldPointOnItem(point.x, point.y, item);
  } // returning the center of item if it failed to find its path


  return schemeContainer.worldPointOnItem(item.area.w / 2, item.area.h / 2, item);
}

function round(value) {
  return myMath/* default.roundPrecise2 */.Z.roundPrecise2(value);
}

const UP = 0,
      DOWN = 1,
      LEFT = 2,
      RIGHT = 3,
      ANY = 4,
      VERTICAL = 5,
      HORIZONTAL = 6;
const directionInversions = [DOWN, UP, RIGHT, LEFT, ANY];

function identifyDirection(x, y) {
  if (x <= -0.5) {
    return LEFT;
  }

  if (x >= 0.5) {
    return RIGHT;
  }

  if (y <= -0.5) {
    return UP;
  }

  if (y >= 0.5) {
    return DOWN;
  }
}

const directionClockWiseTurns = [[0, 0, -1, 1], [0, 0, 1, -1], [1, -1, 0, 0], [-1, 1, 0, 0]];

function isTurnClockWise(direction1, direction2) {
  return directionClockWiseTurns[direction1][direction2] > 0;
}

function directionType(direction) {
  if (direction === RIGHT || direction === LEFT) {
    return HORIZONTAL;
  }

  if (direction === UP || direction === DOWN) {
    return VERTICAL;
  }

  return ANY;
}

function invertDirection(direction) {
  return directionInversions[direction];
}

function stepV(y1, y2) {
  return {
    way: y2 > y1 ? DOWN : UP,
    value: Math.abs(y2 - y1)
  };
}

function stepH(x1, x2) {
  return {
    way: x2 > x1 ? RIGHT : LEFT,
    value: Math.abs(x2 - x1)
  };
}

const lineV2V = (x1, y1, x2, y2) => {
  const ym = (y1 + y2) / 2;
  return [stepV(y1, ym), stepH(x1, x2), stepV(ym, y2)];
};

const lineH2V = (x1, y1, x2, y2) => {
  return [stepH(x1, x2), stepV(y1, y2)];
};

const lineV2H = (x1, y1, x2, y2) => {
  return [stepV(y1, y2), stepH(x1, x2)];
};

const lineH2H = (x1, y1, x2, y2) => {
  const xm = (x1 + x2) / 2;
  return [stepH(x1, xm), stepV(y1, y2), stepH(xm, x2)];
};

function findWayToThePoint(x1, y1, previousDirection, x2, y2, preferedDirection) {
  const restrictedDirection = invertDirection(previousDirection);
  let possibleDirections = [];
  const dx = x2 - x1;
  const dy = y2 - y1;

  if (!myMath/* default.tooSmall */.Z.tooSmall(dx)) {
    possibleDirections.push(x2 > x1 ? RIGHT : LEFT);
  }

  if (!myMath/* default.tooSmall */.Z.tooSmall(dy)) {
    possibleDirections.push(y2 > y1 ? DOWN : UP);
  }

  if (possibleDirections.length === 2) {
    if (possibleDirections[0] === restrictedDirection) {
      possibleDirections = [possibleDirections[1], possibleDirections[0]];
    } else if (preferedDirection === possibleDirections[0] && possibleDirections[1] !== restrictedDirection) {
      possibleDirections = [possibleDirections[1], possibleDirections[0]];
    } else if (preferedDirection === ANY && possibleDirections[1] === previousDirection) {
      possibleDirections = [possibleDirections[1], possibleDirections[0]];
    }
  }

  const previousDirectionType = directionType(previousDirection);
  const firstDirectionType = directionType(possibleDirections[0]);
  const preferedDirectionType = directionType(preferedDirection);

  if (firstDirectionType === preferedDirectionType || previousDirectionType === preferedDirectionType) {
    if (preferedDirectionType === VERTICAL) {
      if (y2 < y1 && previousDirection !== DOWN || y2 > y1 && previousDirection !== UP) {
        return lineV2V(x1, y1, x2, y2);
      }
    } else {
      if (x2 < x1 && previousDirection !== RIGHT || x2 > x1 && previousDirection !== LEFT) {
        return lineH2H(x1, y1, x2, y2);
      }
    }
  }

  if (firstDirectionType === HORIZONTAL) {
    return lineH2V(x1, y1, x2, y2);
  } else {
    return lineV2H(x1, y1, x2, y2);
  }
}

function movePointWithStep(x, y, stepWay, stepValue) {
  if (stepWay === RIGHT) {
    x = x + stepValue;
  } else if (stepWay === LEFT) {
    x = x - stepValue;
  } else if (stepWay === UP) {
    y = y - stepValue;
  } else if (stepWay === DOWN) {
    y = y + stepValue;
  }

  return {
    x,
    y
  };
}

function computeStepPathAndCaps(item, useCut, roundCuts) {
  const points = utils/* default.clone */.Z.clone(item.shapeProps.points);
  const caps = []; // identifying a required direction of first and last points

  let firstPointDirection = UP;
  let lastPointDirection = ANY;

  if (points[0].hasOwnProperty('bx')) {
    firstPointDirection = identifyDirection(points[0].bx, points[0].by);
  }

  const lastPoint = points[points.length - 1];

  if (lastPoint.hasOwnProperty('bx')) {
    lastPointDirection = identifyDirection(lastPoint.bx, lastPoint.by);
  }

  if (item.shapeProps.sourceCap && item.shapeProps.sourceCap !== 'empty') {
    const wayPoint = movePointWithStep(0, 0, firstPointDirection, item.shapeProps.sourceCapSize);
    const cap = computeCapByPosition(points[0].x, points[0].y, points[0].x + wayPoint.x, points[0].y + wayPoint.y, item.shapeProps.sourceCapSize, item.shapeProps.sourceCap);

    if (cap) {
      if (!cap.prolongLine) {
        points[0].x = cap.entryPoint.x;
        points[0].y = cap.entryPoint.y;
      }

      caps.push(cap);
    }
  }

  const pathSteps = [];
  let currentDirection = firstPointDirection;
  let currentPoint = points[0];

  const applySteps = steps => {
    forEach_default()(steps, step => {
      pathSteps.push(step);
      currentPoint = movePointWithStep(currentPoint.x, currentPoint.y, step.way, step.value);
    });
    currentDirection = steps[steps.length - 1].way;
  };

  for (let i = 1; i < points.length - 1; i++) {
    applySteps(findWayToThePoint(currentPoint.x, currentPoint.y, currentDirection, points[i].x, points[i].y, ANY));
  }

  applySteps(findWayToThePoint(currentPoint.x, currentPoint.y, currentDirection, lastPoint.x, lastPoint.y, invertDirection(lastPointDirection)));
  let path = `M ${points[0].x} ${points[0].y}`;
  currentPoint = points[0];

  if (!useCut) {
    forEach_default()(pathSteps, (step, i) => {
      const nextPoint = movePointWithStep(currentPoint.x, currentPoint.y, step.way, step.value);
      let cap = null;

      if (i === pathSteps.length - 1 && item.shapeProps.destinationCap && item.shapeProps.destinationCap !== 'empty') {
        cap = computeCapByPosition(nextPoint.x, nextPoint.y, currentPoint.x, currentPoint.y, item.shapeProps.destinationCapSize, item.shapeProps.destinationCap);
      }

      if (cap) {
        path += ` L ${cap.entryPoint.x} ${cap.entryPoint.y}`;
        caps.push(cap);
      } else {
        path += ` L ${nextPoint.x} ${nextPoint.y}`;
        currentPoint = nextPoint;
      }
    });
    return {
      path,
      caps
    };
  } // using cuts


  const maxStepCut = Math.max(0, item.shapeProps.stepSize);
  let previousCut = 0;

  for (let i = 0; i < pathSteps.length - 1; i++) {
    const step = pathSteps[i];
    const nextStep = pathSteps[i + 1];
    const minStepValue = Math.min(step.value, nextStep.value);

    if (minStepValue > 1 && nextStep.way !== step.way) {
      const cut = Math.min(maxStepCut, minStepValue / 2);
      const nextPhantomPoint = movePointWithStep(currentPoint.x, currentPoint.y, step.way, step.value - previousCut);
      const nextPoint = movePointWithStep(currentPoint.x, currentPoint.y, step.way, step.value - cut - previousCut);
      const cutExitPoint = movePointWithStep(nextPhantomPoint.x, nextPhantomPoint.y, nextStep.way, cut);

      if (roundCuts) {
        const sweepFlag = isTurnClockWise(step.way, nextStep.way) ? 1 : 0;
        path += ` L ${nextPoint.x} ${nextPoint.y} A ${cut} ${cut} 0 0 ${sweepFlag} ${cutExitPoint.x} ${cutExitPoint.y}`;
      } else {
        path += ` L ${nextPoint.x} ${nextPoint.y} L ${cutExitPoint.x} ${cutExitPoint.y}`;
      }

      previousCut = cut;
      currentPoint = cutExitPoint;
    } else {
      const nextPoint = movePointWithStep(currentPoint.x, currentPoint.y, step.way, step.value - previousCut);
      path += ` L ${nextPoint.x} ${nextPoint.y}`;
      currentPoint = nextPoint;
      previousCut = 0;
    }
  }

  const step = pathSteps[pathSteps.length - 1];
  const nextPoint = movePointWithStep(currentPoint.x, currentPoint.y, step.way, step.value - previousCut);
  let cap = null;

  if (item.shapeProps.destinationCap && item.shapeProps.destinationCap !== 'empty') {
    cap = computeCapByPosition(nextPoint.x, nextPoint.y, currentPoint.x, currentPoint.y, item.shapeProps.destinationCapSize, item.shapeProps.destinationCap);
  }

  if (cap) {
    path += ` L ${cap.entryPoint.x} ${cap.entryPoint.y}`;

    if (cap.prolongLine) {
      path += ` L ${nextPoint.x} ${nextPoint.y}`;
    }

    caps.push(cap);
  } else {
    path += ` L ${nextPoint.x} ${nextPoint.y}`;
  }

  return {
    path,
    caps
  };
}

function computeSmoothPath(item) {
  const points = utils/* default.clone */.Z.clone(item.shapeProps.points);

  if (points.length < 2) {
    return {
      path: null,
      caps: []
    };
  }

  let path = '';
  const caps = [];
  let firstCap = null;
  let lastCap = null;
  let previousPoint = null;

  if (item.shapeProps.sourceCap && item.shapeProps.sourceCap !== 'empty') {
    let x2 = points[1].x,
        y2 = points[1].y;

    if (typeof points[0].bx !== 'undefined') {
      x2 = points[0].x + points[0].bx * item.shapeProps.sourceCapSize;
      y2 = points[0].y + points[0].by * item.shapeProps.sourceCapSize;
    }

    firstCap = computeCapByPosition(points[0].x, points[0].y, x2, y2, item.shapeProps.sourceCapSize, item.shapeProps.sourceCap);

    if (firstCap) {
      points[0].x = firstCap.entryPoint.x;
      points[0].y = firstCap.entryPoint.y;
      caps.push(firstCap);
    }
  }

  if (item.shapeProps.destinationCap && item.shapeProps.destinationCap !== 'empty') {
    const id = points.length - 1;
    let x2 = points[id - 1].x,
        y2 = points[id - 1].y;

    if (typeof points[id].bx !== 'undefined') {
      x2 = points[id].x + points[id].bx * item.shapeProps.destinationCapSize;
      y2 = points[id].y + points[id].by * item.shapeProps.destinationCapSize;
    }

    lastCap = computeCapByPosition(points[id].x, points[id].y, x2, y2, item.shapeProps.destinationCapSize, item.shapeProps.destinationCap, item.shapeProps.fill);

    if (lastCap) {
      points[id].x = lastCap.entryPoint.x;
      points[id].y = lastCap.entryPoint.y;
      caps.push(lastCap);
    }
  } // special situation, it is easier to handle it separately


  if (points.length === 2 && item.shapeProps.sourceItem && item.shapeProps.destinationItem && typeof points[0].bx !== 'undefined' && typeof points[1].bx !== 'undefined') {
    const k = myMath/* default.distanceBetweenPoints */.Z.distanceBetweenPoints(points[0].x, points[0].y, points[1].x, points[1].y) / 3;
    let path = '';

    if (firstCap && firstCap.prolongLine) {
      path = `M ${round(item.shapeProps.points[0].x)} ${round(item.shapeProps.points[0].y)} ` + `L ${round(points[0].x)} ${round(points[0].y)} `;
    } else {
      path = `M ${round(points[0].x)} ${round(points[0].y)} `;
    }

    path += `C ${round(points[0].x + k * points[0].bx)} ${round(points[0].y + k * points[0].by)}` + ` ${round(points[1].x + k * points[1].bx)}  ${round(points[1].y + k * points[1].by)}` + ` ${round(points[1].x)} ${round(points[1].y)} `;

    if (lastCap && lastCap.prolongLine) {
      const p = item.shapeProps.points[item.shapeProps.points.length - 1];
      path += `L ${round(p.x)} ${round(p.y)}`;
    }

    return {
      path,
      caps
    };
  }

  const vectors = [];
  forEach_default()(points, (point, i) => {
    let prevPoint = point;

    if (i > 0) {
      prevPoint = points[i - 1];
    }

    let nextPoint = point;

    if (i < points.length - 1) {
      nextPoint = points[i + 1];
    }

    let x = nextPoint.x - prevPoint.x;
    let y = nextPoint.y - prevPoint.y;
    const d = Math.sqrt(x * x + y * y);

    if (d > 0.00001) {
      x = x / d;
      y = y / d;
    }

    vectors[i] = {
      x,
      y
    };
  }); // tested different values and this one works best so far

  const smoothingFactor = 3.5;
  forEach_default()(points, (point, i) => {
    if (i === 0) {
      if (firstCap && firstCap.prolongLine) {
        path = `M ${round(item.shapeProps.points[0].x)} ${round(item.shapeProps.points[0].y)} ` + `L ${round(point.x)} ${round(point.y)} `;
      } else {
        path = `M ${round(point.x)} ${round(point.y)} `;
      }
    } else if (i === 1 && item.shapeProps.sourceItem && typeof previousPoint.bx !== 'undefined') {
      const k = myMath/* default.distanceBetweenPoints */.Z.distanceBetweenPoints(previousPoint.x, previousPoint.y, point.x, point.y) / smoothingFactor;
      let vx = 0;
      let vy = 0;

      if (i < points.length - 1) {
        vx = vectors[i].x;
        vy = vectors[i].y;
      }

      path += ` C ${round(previousPoint.x + k * previousPoint.bx)} ${round(previousPoint.y + k * previousPoint.by)} ${round(point.x - k * vx)} ${round(point.y - k * vy)} ${round(point.x)} ${round(point.y)}`;
    } else if (i === points.length - 1 && item.shapeProps.destinationItem && typeof point.bx !== 'undefined') {
      const k = myMath/* default.distanceBetweenPoints */.Z.distanceBetweenPoints(previousPoint.x, previousPoint.y, point.x, point.y) / smoothingFactor;
      let vx = 0;
      let vy = 0;

      if (i > 1) {
        vx = vectors[i - 1].x;
        vy = vectors[i - 1].y;
      }

      path += ` C ${round(previousPoint.x + k * vx)} ${round(previousPoint.y + k * vy)}  ${round(point.x + k * point.bx)} ${round(point.y + k * point.by)} ${round(point.x)} ${round(point.y)}`;
    } else {
      const k = myMath/* default.distanceBetweenPoints */.Z.distanceBetweenPoints(previousPoint.x, previousPoint.y, point.x, point.y) / smoothingFactor;
      let pvx = vectors[i - 1].x;
      let pvy = vectors[i - 1].y;
      let vx = vectors[i].x;
      let vy = vectors[i].y;
      path += ` C ${round(previousPoint.x + k * pvx)} ${round(previousPoint.y + k * pvy)}  ${round(point.x - k * vx)} ${round(point.y - k * vy)} ${round(point.x)} ${round(point.y)}`;
    }

    previousPoint = point;
  });

  if (lastCap && lastCap.prolongLine) {
    const p = item.shapeProps.points[item.shapeProps.points.length - 1];
    path += `L ${p.x} ${p.y}`;
  }

  return {
    path,
    caps
  };
}

function computeFatPath(item) {
  if (item.shapeProps.points.length < 2) {
    return '';
  }

  let path = '';
  const V = [];
  const W = [];
  const A = [];
  const B = [];
  const Pa = [];
  const Pb = [];
  forEach_default()(item.shapeProps.points, (point, i) => {
    if (i < item.shapeProps.points.length - 1) {
      const nextPoint = item.shapeProps.points[i + 1];
      V[i] = {
        x: nextPoint.x - point.x,
        y: nextPoint.y - point.y
      };
      const dSquared = V[i].x * V[i].x + V[i].y * V[i].y;

      if (dSquared > 0.001) {
        const d = Math.sqrt(dSquared);
        W[i] = {
          x: V[i].x / d,
          y: V[i].y / d
        };
      } else {
        W[i] = V[i];
      } // rotating W by 90 degrees


      A[i] = {
        x: W[i].y * item.shapeProps.fatWidth,
        y: -W[i].x * item.shapeProps.fatWidth
      };
      B[i] = {
        x: -A[i].x,
        y: -A[i].y
      };
      Pa[i] = {
        x: point.x + A[i].x,
        y: point.y + A[i].y
      };
      Pb[i] = {
        x: point.x + B[i].x,
        y: point.y + B[i].y
      };
    }
  });
  const alpha = []; // ratios for triangle

  const M = 3;
  const K = 2;
  let shouldDrawEndArrow = false;
  let shouldDrawSourceArrow = false; // first creating left edge

  forEach_default()(item.shapeProps.points, (point, i) => {
    if (i === 0) {
      const d = V[0].x * V[0].x + V[0].y * V[0].y;
      const arrowLength = item.shapeProps.fatWidth * M;

      if (item.shapeProps.sourceCap === 'triangle' && Math.sqrt(d) > arrowLength) {
        shouldDrawSourceArrow = true;
        const Sx = point.x + W[0].x * item.shapeProps.fatWidth * M;
        const Sy = point.y + W[0].y * item.shapeProps.fatWidth * M;
        path += ` M ${round(point.x)} ${round(point.y)}  L ${Sx + A[0].x * K} ${Sy + A[0].y * K} L ${Sx + A[0].x} ${Sy + A[0].y}`;
      } else {
        path = `M ${round(Pa[i].x)} ${round(Pa[i].y)}`;
      }

      return;
    }

    if (i > 0 && i < item.shapeProps.points.length - 1) {
      alpha[i] = myMath/* default.angleBetweenVectors */.Z.angleBetweenVectors(V[i].x, V[i].y, -V[i - 1].x, -V[i - 1].y);

      if (alpha[i] < 0) {
        // should merge left points
        const intersection = myMath/* default.linesIntersection */.Z.linesIntersection(myMath/* default.createLineEquation */.Z.createLineEquation(Pa[i - 1].x, Pa[i - 1].y, Pa[i - 1].x + V[i - 1].x, Pa[i - 1].y + V[i - 1].y), myMath/* default.createLineEquation */.Z.createLineEquation(Pa[i].x, Pa[i].y, Pa[i].x + V[i].x, Pa[i].y + V[i].y));

        if (intersection && alpha[i] < -0.1) {
          path += ` L ${intersection.x} ${intersection.y}`;
        } else {
          path += ` L ${Pa[i].x} ${Pa[i].y}`;
        }
      } else {
        // should not merge left points
        path += ` L ${point.x + A[i - 1].x} ${point.y + A[i - 1].y}  L ${point.x + A[i].x} ${point.y + A[i].y}`;
      }
    } // last point


    if (i === item.shapeProps.points.length - 1 && i > 0) {
      const d = V[i - 1].x * V[i - 1].x + V[i - 1].y * V[i - 1].y;
      const arrowLength = item.shapeProps.fatWidth * M;

      if (item.shapeProps.destinationCap === 'triangle' && Math.sqrt(d) > arrowLength) {
        shouldDrawEndArrow = true;
        const Sx = point.x - W[i - 1].x * arrowLength;
        const Sy = point.y - W[i - 1].y * arrowLength;
        path += ` L ${Sx + A[i - 1].x} ${Sy + A[i - 1].y} L ${Sx + A[i - 1].x * K} ${Sy + A[i - 1].y * K} L ${point.x} ${point.y}`;
      } else {
        path += ` L ${point.x + A[i - 1].x} ${point.y + A[i - 1].y}`;
      }
    }
  });

  for (let i = item.shapeProps.points.length - 1; i >= 0; i--) {
    const point = item.shapeProps.points[i];

    if (i === item.shapeProps.points.length - 1) {
      if (shouldDrawEndArrow) {
        const Sx = point.x - W[i - 1].x * item.shapeProps.fatWidth * M;
        const Sy = point.y - W[i - 1].y * item.shapeProps.fatWidth * M;
        path += ` L ${Sx + B[i - 1].x * K} ${Sy + B[i - 1].y * K} L ${Sx + B[i - 1].x} ${Sy + B[i - 1].y}`;
      } else {
        path += ` L ${point.x + B[i - 1].x} ${point.y + B[i - 1].y}`;
      }
    } else if (i > 0) {
      if (alpha[i] > 0) {
        // should merge right points
        const intersection = myMath/* default.linesIntersection */.Z.linesIntersection(myMath/* default.createLineEquation */.Z.createLineEquation(Pb[i - 1].x, Pb[i - 1].y, Pb[i - 1].x + V[i - 1].x, Pb[i - 1].y + V[i - 1].y), myMath/* default.createLineEquation */.Z.createLineEquation(Pb[i].x, Pb[i].y, Pb[i].x + V[i].x, Pb[i].y + V[i].y));

        if (intersection && alpha[i] > 0.1) {
          path += ` L ${intersection.x} ${intersection.y}`;
        } else {
          path += ` L ${Pb[i].x} ${Pb[i].y}`;
        }
      } else {
        // should not merge right points
        path += ` L ${point.x + B[i].x} ${point.y + B[i].y} L ${point.x + B[i - 1].x} ${point.y + B[i - 1].y}`;
      }
    } else if (i === 0) {
      if (shouldDrawSourceArrow) {
        const Sx = point.x + W[0].x * item.shapeProps.fatWidth * M;
        const Sy = point.y + W[0].y * item.shapeProps.fatWidth * M;
        path += ` L ${Sx + B[0].x} ${Sy + B[0].y} L ${Sx + B[0].x * K} ${Sy + B[0].y * K} Z`;
      } else {
        path += `L ${point.x + B[i].x} ${point.y + B[i].y} z`;
      }
    }
  }

  return path;
}

function computeLinearPathAndCaps(item) {
  let path = '';
  const caps = [];
  forEach_default()(item.shapeProps.points, (point, i) => {
    if (i === 0) {
      let cap = null;

      if (item.shapeProps.sourceCap && item.shapeProps.sourceCap !== 'empty') {
        const nextPoint = item.shapeProps.points[1];
        cap = computeCapByPosition(point.x, point.y, nextPoint.x, nextPoint.y, item.shapeProps.sourceCapSize, item.shapeProps.sourceCap);
      }

      if (cap) {
        if (cap.prolongLine) {
          path = `M ${point.x} ${point.y} L ${cap.entryPoint.x} ${cap.entryPoint.y} `;
        } else {
          path = `M ${cap.entryPoint.x} ${cap.entryPoint.y} `;
        }

        caps.push(cap);
      } else {
        path = `M ${point.x} ${point.y} `;
      }
    } else if (i === item.shapeProps.points.length - 1) {
      let cap = null;

      if (item.shapeProps.destinationCap && item.shapeProps.destinationCap !== 'empty') {
        const prevPoint = item.shapeProps.points[i - 1];
        cap = computeCapByPosition(point.x, point.y, prevPoint.x, prevPoint.y, item.shapeProps.destinationCapSize, item.shapeProps.destinationCap);
      }

      if (cap) {
        path += `L ${cap.entryPoint.x} ${cap.entryPoint.y} `;

        if (cap.prolongLine) {
          path += `L ${point.x} ${point.y} `;
        }

        caps.push(cap);
      } else {
        path += `L ${point.x} ${point.y} `;
      }
    } else {
      path += ` L ${point.x} ${point.y} `;
    }
  });
  return {
    path,
    caps
  };
}

function computePathAndCaps(item) {
  if (item.shapeProps.points.length < 2) {
    return null;
  }

  if (item.shapeProps.fat) {
    return {
      path: computeFatPath(item),
      caps: []
    };
  }

  if (item.shapeProps.smoothing === 'smooth') {
    return computeSmoothPath(item);
  } else if (item.shapeProps.smoothing === 'step') {
    return computeStepPathAndCaps(item, false, false);
  } else if (item.shapeProps.smoothing === 'step-cut') {
    return computeStepPathAndCaps(item, true, false);
  } else if (item.shapeProps.smoothing === 'step-smooth') {
    return computeStepPathAndCaps(item, true, true);
  } else {
    return computeLinearPathAndCaps(item);
  }
}

;

function computeRawPath(item) {
  const pathAndCaps = computePathAndCaps(item);

  if (pathAndCaps) {
    return pathAndCaps.path;
  }

  return null;
}

function computeCapByPosition(x1, y1, x2, y2, capSize, capType) {
  if (capType !== 'empty') {
    const dx = x2 - x1;
    const dy = y2 - y1;
    const squaredD = dx * dx + dy * dy;

    if (squaredD > 0.0001) {
      const d = Math.sqrt(squaredD);
      return (0,ConnectorCaps/* createConnectorCap */.g)(x1, y1, dx * capSize / d, dy * capSize / d, capType);
    }
  }

  return null;
}

const DST_READJUST_CTX = Symbol('dstReadjustCtx');
const SRC_READJUST_CTX = Symbol('srcReadjustCtx');

function realignNormal(point, secondPoint) {
  if (point.hasOwnProperty('bx') && point.hasOwnProperty('by') && secondPoint) {
    const dx = secondPoint.x - point.x;
    const dy = secondPoint.y - point.y;
    const angle = myMath/* default.cosineAngleBetweenVectors */.Z.cosineAngleBetweenVectors(point.bx, point.by, dx, dy) * 180 / Math.PI;

    if (angle > 90) {
      // inverting the normal
      point.bx = -point.bx;
      point.by = -point.by;
    }
  }
}

;
/**
 * @param {SchemeContainer} schemeContainer
 * @param {Item} item
 * @param {CurvePoint} curvePoint
 * @param {CurvePoint} secondCurvePoint - for source edge it would be second, for destination edge it would the the one before last
 * @param {String} attachmentItemSelector
 * @param {Number} attachmentItemPosition
 * @param {ItemModificationContext} context
 * @param {Boolean} isSource 
 * @param {Function} callback - function which is used to pass changed attachment item position
 */

function readjustCurveAttachment(schemeContainer, item, curvePoint, secondCurvePoint, attachmentItemSelector, attachmentItemPosition, context, isSource, callback) {
  const attachmentItem = schemeContainer.findFirstElementBySelector(attachmentItemSelector);

  if (attachmentItem && attachmentItem.id !== item.id && attachmentItem.shape) {
    if (attachmentItemPosition < 0) {
      // this means that connector is attached to item pin
      const pinIndex = Math.round(-attachmentItemPosition - 1);
      const pinPoint = schemeContainer.getItemWorldPinPoint(attachmentItem, pinIndex);

      if (pinPoint) {
        const localPinPoint = schemeContainer.localPointOnItem(pinPoint.x, pinPoint.y, item);
        const newPoint = {
          t: 'L',
          x: localPinPoint.x,
          y: localPinPoint.y
        };

        if (pinPoint.hasOwnProperty('nx')) {
          newPoint.bx = pinPoint.nx;
          newPoint.by = pinPoint.ny;
        }

        callback(newPoint, attachmentItemPosition);
      }

      return;
    }

    const shadowSvgPath = schemeContainer.getSvgOutlineOfItem(attachmentItem);

    if (!shadowSvgPath) {
      return;
    }

    let oldPoint = null;
    let worldOldPoint = null;
    let metaCtxKey = SRC_READJUST_CTX;

    if (!isSource) {
      metaCtxKey = DST_READJUST_CTX;
    }

    if (context && context.id) {
      if (item.meta[metaCtxKey] && item.meta[metaCtxKey].id === context.id) {
        oldPoint = item.meta[metaCtxKey].oldPoint;
        worldOldPoint = item.meta[metaCtxKey].worldOldPoint;
      } else {
        oldPoint = curvePoint;
        worldOldPoint = schemeContainer.worldPointOnItem(oldPoint.x, oldPoint.y, item);
        item.meta[metaCtxKey] = {
          id: context.id,
          oldPoint,
          worldOldPoint
        };
      }
    } else {
      oldPoint = item.shapeProps.points[item.shapeProps.points.length - 1];
      worldOldPoint = schemeContainer.worldPointOnItem(oldPoint.x, oldPoint.y, item);
    }

    let attachmentPoint = null;
    let distanceOnPath = attachmentItemPosition;

    if (context && (context.rotated || context.resized)) {
      const localToAttachmentItemOldPoint = schemeContainer.localPointOnItem(worldOldPoint.x, worldOldPoint.y, attachmentItem);
      const closestPointOnPath = myMath/* default.closestPointOnPath */.Z.closestPointOnPath(localToAttachmentItemOldPoint.x, localToAttachmentItemOldPoint.y, shadowSvgPath); // readjusting destination attachment to try to keep it in the same world point while the item is rotated, resized or moved

      distanceOnPath = closestPointOnPath.distance;
      const attachmentWorldPoint = getPointOnItemPath(attachmentItem, shadowSvgPath, distanceOnPath, schemeContainer);
      attachmentPoint = schemeContainer.localPointOnItem(attachmentWorldPoint.x, attachmentWorldPoint.y, item);
    } else {
      const attachmentWorldPoint = getPointOnItemPath(attachmentItem, shadowSvgPath, attachmentItemPosition, schemeContainer);
      attachmentPoint = schemeContainer.localPointOnItem(attachmentWorldPoint.x, attachmentWorldPoint.y, item);
    }

    const normal = schemeContainer.calculateNormalOnPointInItemOutline(attachmentItem, distanceOnPath, shadowSvgPath);
    const newPoint = {
      t: oldPoint.t,
      x: attachmentPoint.x,
      y: attachmentPoint.y,
      bx: normal.x,
      by: normal.y
    };
    callback(newPoint, distanceOnPath);
  }
}
/**
 * @property {Item} item 
 * @property {Object} schemeContainer 
 * @property {Boolean} isSoft 
 * @property {ItemModificationContext} context 
 * @property {Number} precision - number of digits after point which it should round to
 */


function readjustItem(item, schemeContainer, isSoft, context, precision) {
  log.info('readjustItem', item.id, item.name, {
    item,
    isSoft,
    context
  }, precision);

  if (!isSoft) {
    readjustItemArea(item, precision);
  }

  if (item.shapeProps.sourceItem) {
    readjustCurveAttachment(schemeContainer, item, item.shapeProps.points[0], item.shapeProps.points[1], item.shapeProps.sourceItem, item.shapeProps.sourceItemPosition, context, true, (newPoint, newSourceItemPosition) => {
      item.shapeProps.points[0] = newPoint;
      item.shapeProps.sourceItemPosition = newSourceItemPosition;
    });
  }

  if (item.shapeProps.destinationItem && item.shapeProps.points.length > 1) {
    readjustCurveAttachment(schemeContainer, item, item.shapeProps.points[item.shapeProps.points.length - 1], item.shapeProps.points[item.shapeProps.points.length - 2], item.shapeProps.destinationItem, item.shapeProps.destinationItemPosition, context, false, (newPoint, newDestinationItemPosition) => {
      item.shapeProps.points[item.shapeProps.points.length - 1] = newPoint;
      item.shapeProps.destinationItemPosition = newDestinationItemPosition;
    });
  }

  if (item.shapeProps.sourceItem && item.shapeProps.points.length > 1) {
    realignNormal(item.shapeProps.points[0], item.shapeProps.points[1]);
  }

  if (item.shapeProps.destinationItem && item.shapeProps.points.length > 1) {
    realignNormal(item.shapeProps.points[item.shapeProps.points.length - 1], item.shapeProps.points[item.shapeProps.points.length - 2]);
  }

  return true;
}

function readjustItemArea(item, precision) {
  log.info('readjustItemArea', item.id, item.name, {
    item
  }, precision);

  if (item.shapeProps.points.length < 1) {
    return;
  }

  const worldPoints = [];
  forEach_default()(item.shapeProps.points, point => {
    worldPoints.push(worldPointOnItem(point.x, point.y, item));
  });
  let minX = worldPoints[0].x,
      minY = worldPoints[0].y,
      maxX = worldPoints[0].x,
      maxY = worldPoints[0].y;
  forEach_default()(worldPoints, p => {
    minX = Math.min(minX, p.x);
    minY = Math.min(minY, p.y);
    maxX = Math.max(maxX, p.x);
    maxY = Math.max(maxY, p.y);
  });
  const newPoints = [];
  forEach_default()(worldPoints, p => {
    newPoints.push({
      x: p.x - minX,
      y: p.y - minY
    });
  });
  item.shapeProps.points = newPoints;
  item.area.r = 0;
  item.area.w = Math.max(0, maxX - minX);
  item.area.h = Math.max(0, maxY - minY);
  const position = myMath/* default.findTranslationMatchingWorldPoint */.Z.findTranslationMatchingWorldPoint(minX, minY, 0, 0, item.area, item.meta.transformMatrix);
  item.area.x = position.x;
  item.area.y = position.y;
}

function getSnappers(item) {
  const snappers = [];
  forEach_default()(item.shapeProps.points, point => {
    const worldPoint = worldPointOnItem(point.x, point.y, item);
    snappers.push({
      item,
      snapperType: 'horizontal',
      value: worldPoint.y
    });
    snappers.push({
      item,
      snapperType: 'vertical',
      value: worldPoint.x
    });
  });
  return snappers;
}

function worldPointOnItem(x, y, item) {
  return myMath/* default.worldPointInArea */.Z.worldPointInArea(x, y, item.area, item.meta && item.meta.transformMatrix ? item.meta.transformMatrix : null);
}

const menuItemPoints = [{
  "t": "L",
  "x": 4,
  "y": 88
}, {
  "t": "L",
  "x": 136,
  "y": 4
}];
const groupName = 'Connections';
/* harmony default export */ const Connectorvue_type_script_lang_js_ = ({
  props: ['item'],
  components: {
    AdvancedFill: AdvancedFill/* default */.Z
  },
  shapeConfig: {
    shapeType: 'vue',
    id: 'connector',
    computePath: computeRawPath,
    readjustItem,
    getSnappers,
    menuItems: [{
      group: groupName,
      name: 'Empty Connector',
      iconUrl: '/assets/images/items/connector-empty.svg',
      item: {
        shapeProps: {
          fat: false,
          sourceCap: 'empty',
          destinationCap: 'empty',
          points: menuItemPoints
        }
      }
    }, {
      group: groupName,
      name: 'Step Connector',
      iconUrl: '/assets/images/items/connector-step.svg',
      item: {
        shapeProps: {
          fat: false,
          sourceCap: 'empty',
          destinationCap: 'empty',
          smoothing: 'step',
          points: [{
            x: 4,
            y: 88
          }, {
            x: 70,
            y: 51
          }, {
            x: 136,
            y: 4
          }]
        }
      }
    }, {
      group: groupName,
      name: 'Step Connector',
      iconUrl: '/assets/images/items/connector-step-smooth.svg',
      item: {
        shapeProps: {
          fat: false,
          sourceCap: 'empty',
          destinationCap: 'empty',
          smoothing: 'step-smooth',
          points: [{
            x: 4,
            y: 88
          }, {
            x: 70,
            y: 51
          }, {
            x: 136,
            y: 4
          }]
        }
      }
    }, {
      group: groupName,
      name: 'Triangle Connector',
      iconUrl: '/assets/images/items/connector-triangle.svg',
      item: {
        shapeProps: {
          fat: false,
          sourceCap: 'empty',
          destinationCap: 'triangle',
          points: menuItemPoints
        }
      }
    }, {
      group: groupName,
      name: 'Triangle Connector',
      iconUrl: '/assets/images/items/connector-triangle-white.svg',
      item: {
        shapeProps: {
          fat: false,
          sourceCap: 'empty',
          destinationCap: 'triangle-h',
          points: menuItemPoints
        }
      }
    }, {
      group: groupName,
      name: 'Arrow Connector',
      iconUrl: '/assets/images/items/connector-arrow.svg',
      item: {
        shapeProps: {
          fat: false,
          sourceCap: 'empty',
          destinationCap: 'arrow',
          points: menuItemPoints
        }
      }
    }, {
      group: groupName,
      name: 'Triangle Connector (Both Sides)',
      iconUrl: '/assets/images/items/connector-triangle-both.svg',
      item: {
        shapeProps: {
          fat: false,
          sourceCap: 'triangle',
          destinationCap: 'triangle',
          points: menuItemPoints
        }
      }
    }, {
      group: groupName,
      name: 'Triangle Connector (Both Sides)',
      iconUrl: '/assets/images/items/connector-triangle-white-both.svg',
      item: {
        shapeProps: {
          fat: false,
          sourceCap: 'triangle-h',
          destinationCap: 'triangle-h',
          points: menuItemPoints
        }
      }
    }, {
      group: groupName,
      name: 'Arrow Connector (Both Sides)',
      iconUrl: '/assets/images/items/connector-arrow-both.svg',
      item: {
        shapeProps: {
          fat: false,
          sourceCap: 'arrow',
          destinationCap: 'arrow',
          points: menuItemPoints
        }
      }
    }, {
      group: groupName,
      name: 'Fat Connector',
      iconUrl: '/assets/images/items/connector-arrow-fat.svg',
      item: {
        shapeProps: {
          sourceCap: 'empty',
          destinationCap: 'triangle',
          points: menuItemPoints,
          fat: true,
          fatWidth: 10
        }
      }
    }, {
      group: groupName,
      name: 'Fat Connector (Both Arrows)',
      iconUrl: '/assets/images/items/connector-arrow-fat-both.svg',
      item: {
        shapeProps: {
          sourceCap: 'triangle',
          destinationCap: 'triangle',
          points: menuItemPoints,
          fat: true,
          fatWidth: 10
        }
      }
    }],

    /**
     * Disabling any text slots for curve items. Otherwise users will be confused when they double click on it in edit mode.
     */
    getTextSlots() {
      return [];
    },

    getPins(item) {
      return forEach_default()(item.shapeProps.points, point => {
        return {
          x: point.x,
          y: point.y
        };
      });
    },

    editorProps: {
      description: 'rich'
    },
    controlPoints: {
      make(item, pointId) {
        if (!pointId) {
          const controlPoints = {};
          forEach_default()(item.shapeProps.points, (point, pointIndex) => {
            controlPoints[pointIndex] = {
              x: point.x,
              y: point.y,
              isEdgeStart: pointIndex === 0,
              isEdgeEnd: pointIndex === item.shapeProps.points.length - 1
            };
          });
          return controlPoints;
        } else {
          const pId = parseInt(pointId);

          if (item.shapeProps.points[pointId]) {
            return {
              x: item.shapeProps.points[pointId].x,
              y: item.shapeProps.points[pointId].y,
              isEdgeStart: pId === 0,
              isEdgeEnd: pId === item.shapeProps.points.length - 1
            };
          }
        }
      },

      handleDrag(item, pointId, originalX, originalY, dx, dy, snapper, schemeContainer) {//do nothing as control point dragging is handled in StateDragItem.js
      }

    },
    args: {
      strokeColor: {
        type: 'color',
        value: 'rgba(30,30,30,1.0)',
        name: 'Stroke color'
      },
      strokeSize: {
        type: 'number',
        value: 2,
        name: 'Stroke size'
      },
      strokePattern: {
        type: 'stroke-pattern',
        value: 'solid',
        name: 'Stroke pattern'
      },
      points: {
        type: 'path-points',
        value: [],
        name: 'Path points',
        hidden: true
      },
      sourceCap: {
        type: 'path-cap',
        value: 'empty',
        name: 'Source Cap'
      },
      sourceCapSize: {
        type: 'number',
        value: 20,
        name: 'Source Cap Size'
      },
      destinationCap: {
        type: 'path-cap',
        value: 'empty',
        name: 'Destination Cap'
      },
      destinationCapSize: {
        type: 'number',
        value: 20,
        name: 'Destination Cap Size'
      },
      smoothing: {
        type: 'choice',
        value: 'smooth',
        options: ['linear', 'smooth', 'step', 'step-cut', 'step-smooth'],
        name: 'Smoothing Type'
      },
      stepSize: {
        type: 'number',
        value: 10,
        name: 'Step size',
        depends: {
          smoothing: ['step-cut', 'step-smooth']
        }
      },
      fat: {
        type: 'boolean',
        value: false,
        name: 'Fat'
      },
      fill: {
        type: 'advanced-color',
        value: {
          type: 'solid',
          color: 'rgba(255,255,255,1.0)'
        },
        name: 'Fill',
        depends: {
          fat: true
        }
      },
      fatWidth: {
        type: 'number',
        value: 10,
        name: 'Fat Width',
        min: 1,
        max: 1000,
        depends: {
          fat: true
        }
      },
      sourceItem: {
        type: 'element',
        value: null,
        name: 'Source Item',
        description: 'Attach this curve to an item as a source',
        hidden: true
      },
      destinationItem: {
        type: 'element',
        value: null,
        name: 'Destination Item',
        description: 'Attach this curve to an item as a destination',
        hidden: true
      },
      sourceItemPosition: {
        type: 'number',
        value: 0,
        name: 'Position On Source Item',
        description: 'Distance on the path of the item where this curve should be attached to',
        hidden: true
      },
      destinationItemPosition: {
        type: 'number',
        value: 0,
        name: 'Position On Source Item',
        description: 'Distance on the path of the item where this curve should be attached to',
        hidden: true
      }
    }
  },

  mounted() {
    EventBus/* default.subscribeForItemChanged */.Z.subscribeForItemChanged(this.item.id, this.onItemChange);
  },

  beforeDestroy() {
    EventBus/* default.unsubscribeForItemChanged */.Z.unsubscribeForItemChanged(this.item.id, this.onItemChange);
  },

  data() {
    const pathAndCaps = computePathAndCaps(this.item);
    return {
      shapePath: pathAndCaps ? pathAndCaps.path : null,
      caps: pathAndCaps ? pathAndCaps.caps : null
    };
  },

  methods: {
    onItemChange() {
      log.info('onItemChange', this.item.id, this.item.name, this.item);
      const pathAndCaps = computePathAndCaps(this.item);

      if (pathAndCaps) {
        this.shapePath = pathAndCaps.path;
        this.caps = pathAndCaps.caps;
      }

      log.info('computed path and caps', this.item.id, this.item.name, this.shapePath, this.caps);
      this.$forceUpdate();
    }

  },
  computed: {
    strokeDashArray() {
      return StrokePattern/* default.createDashArray */.Z.createDashArray(this.item.shapeProps.strokePattern, this.item.shapeProps.strokeSize);
    },

    svgFill() {
      if (this.item.shapeProps.fat) {
        return AdvancedFill/* default.computeSvgFill */.Z.computeSvgFill(this.item.shapeProps.fill, `fill-pattern-${this.item.id}`);
      }

      return 'none';
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Connector.vue?vue&type=script&lang=js&
 /* harmony default export */ const shapes_Connectorvue_type_script_lang_js_ = (Connectorvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Connector.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  shapes_Connectorvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/shapes/Connector.vue"
/* harmony default export */ const Connector = (component.exports);

/***/ }),

/***/ 3942:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ Dummy)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/Dummy.vue?vue&type=template&id=61556915&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "g",
    { attrs: { "data-preview-ignore": "true" } },
    [
      _c("advanced-fill", {
        attrs: {
          fillId: "fill-pattern-" + _vm.item.id,
          fill: _vm.item.shapeProps.fill,
          area: _vm.item.area,
        },
      }),
      _vm._v(" "),
      _vm.item.shapeProps.showName
        ? _c(
            "foreignObject",
            { attrs: { x: 0, y: -20, width: _vm.item.area.w, height: 20 } },
            [
              _c(
                "div",
                {
                  staticStyle: {
                    "font-size": "12px",
                    "font-weight": "bold",
                    display: "table-cell",
                    padding: "2px 5px",
                    height: "20px",
                    "font-family": "Arial, Helvetica, sans-serif",
                    "text-align": "left",
                    "vertical-align": "bottom",
                    "white-space": "normal",
                  },
                  style: {
                    background: _vm.item.shapeProps.strokeColor,
                    color: "white",
                  },
                  attrs: { "data-item-id": _vm.item.id },
                },
                [
                  _vm._v(
                    "\n            " + _vm._s(_vm.item.name) + "\n        "
                  ),
                ]
              ),
            ]
          )
        : _vm._e(),
      _vm._v(" "),
      _c("path", {
        attrs: {
          d: _vm.shapePath,
          "stroke-width": _vm.item.shapeProps.strokeSize + "px",
          stroke: _vm.item.shapeProps.strokeColor,
          "stroke-dasharray": _vm.strokeDashArray,
          fill: _vm.fill,
        },
      }),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Dummy.vue?vue&type=template&id=61556915&

// EXTERNAL MODULE: ./src/ui/components/editor/items/AdvancedFill.vue + 4 modules
var AdvancedFill = __webpack_require__(6777);
// EXTERNAL MODULE: ./src/ui/components/editor/items/StrokePattern.js
var StrokePattern = __webpack_require__(4502);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/Dummy.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



function computePath(item) {
  const W = item.area.w;
  const H = item.area.h;
  const R = Math.min(item.shapeProps.cornerRadius, item.area.w / 2, item.area.h / 2);
  return `M ${W - R} ${H}  L ${R} ${H} a ${R} ${R} 0 0 1 ${-R} ${-R}  L 0 ${R}  a ${R} ${R} 0 0 1 ${R} ${-R}   L ${W - R} 0   a ${R} ${R} 0 0 1 ${R} ${R}  L ${W} ${H - R}   a ${R} ${R} 0 0 1 ${-R} ${R} Z`;
}

/* harmony default export */ const Dummyvue_type_script_lang_js_ = ({
  props: ['item'],
  shapeConfig: {
    shapeType: 'vue',
    id: 'dummy',
    menuItems: [{
      group: 'General',
      name: 'Dummy',
      iconUrl: '/assets/images/items/dummy.svg',
      description: `
                Dummy item can be used in order to group mulitple items together.
                It is only visible in the edit mode and completely transparent in view mode.
            `,
      item: {
        shapeProps: {
          cornerRadius: 0
        }
      }
    }],
    components: {
      AdvancedFill: AdvancedFill/* default */.Z
    },

    // it doesn't support text slots
    getTextSlots(item) {
      return [];
    },

    computePath,
    editorProps: {
      // flag to specify that it should only be rendered in edit mode
      onlyEditMode: true
    },
    args: {
      fill: {
        name: 'Fill',
        type: 'advanced-color',
        value: {
          type: 'solid',
          color: 'rgba(159, 227, 249, 0.1)'
        }
      },
      strokeColor: {
        name: 'Stroke',
        type: 'color',
        value: 'rgba(50, 175, 209, 1)'
      },
      strokeSize: {
        name: 'Stroke Size',
        type: 'number',
        value: 1
      },
      strokePattern: {
        type: 'stroke-pattern',
        value: 'dashed',
        name: 'Stroke pattern'
      },
      cornerRadius: {
        type: 'number',
        value: 0,
        name: 'Corner radius'
      },
      showName: {
        type: 'boolean',
        value: true,
        name: 'Display Name'
      }
    }
  },
  computed: {
    shapePath() {
      return computePath(this.item);
    },

    strokeDashArray() {
      return StrokePattern/* default.createDashArray */.Z.createDashArray(this.item.shapeProps.strokePattern, this.item.shapeProps.strokeSize);
    },

    fill() {
      return AdvancedFill/* default.computeStandardFill */.Z.computeStandardFill(this.item);
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Dummy.vue?vue&type=script&lang=js&
 /* harmony default export */ const shapes_Dummyvue_type_script_lang_js_ = (Dummyvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Dummy.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  shapes_Dummyvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/shapes/Dummy.vue"
/* harmony default export */ const Dummy = (component.exports);

/***/ }),

/***/ 9758:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ FramePlayer)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/FramePlayer.vue?vue&type=template&id=a1ddaf4a&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "g",
    [
      _vm._l(_vm.buttons, function (button, buttonIndex) {
        return _c(
          "g",
          {
            on: {
              click: function ($event) {
                return _vm.onClickedButton(buttonIndex)
              },
              mouseover: function ($event) {
                return _vm.onMouseOverButton(buttonIndex)
              },
              mouseout: function ($event) {
                return _vm.onMouseOutButton(buttonIndex)
              },
            },
          },
          [
            _c("circle", {
              staticStyle: {
                "-webkit-transition": "fill 200ms linear",
                "-ms-transition": "fill 200ms linear",
                transition: "fill 200ms linear",
              },
              attrs: {
                cx:
                  _vm.leftOffset +
                  buttonIndex * (_vm.buttonSize + _vm.buttonSpaceSize) +
                  _vm.buttonSize / 2,
                cy: _vm.buttonSize / 2 + _vm.topOffset,
                r: _vm.buttonSize / 2,
                fill: button.fillColor,
                stroke: _vm.item.shapeProps.strokeColor,
                "stroke-width": "1",
              },
            }),
            _vm._v(" "),
            _c(
              "foreignObject",
              {
                attrs: {
                  x:
                    _vm.leftOffset +
                    buttonIndex * (_vm.buttonSize + _vm.buttonSpaceSize),
                  y: _vm.topOffset,
                  width: _vm.buttonSize,
                  height: _vm.buttonSize,
                },
              },
              [
                _c(
                  "div",
                  {
                    staticStyle: {
                      width: "100%",
                      height: "100%",
                      "text-align": "center",
                      "vertical-align": "middle",
                    },
                    attrs: { xmlns: "http://www.w3.org/1999/xhtml" },
                  },
                  [
                    _c("i", {
                      class: [_vm.isPlaying ? button.iconPlaying : button.icon],
                      style: {
                        "font-size": _vm.buttonFontSize,
                        color: _vm.item.shapeProps.strokeColor,
                      },
                    }),
                  ]
                ),
              ]
            ),
            _vm._v(" "),
            _c("circle", {
              staticStyle: { cursor: "pointer" },
              attrs: {
                cx:
                  _vm.leftOffset +
                  buttonIndex * (_vm.buttonSize + _vm.buttonSpaceSize) +
                  _vm.buttonSize / 2,
                cy: _vm.buttonSize / 2 + _vm.topOffset,
                r: _vm.buttonSize / 2,
                fill: "rgba(255, 255, 255, 0)",
                stroke: "rgba(255, 255, 255, 0)",
                "stroke-width": "1",
              },
            }),
          ]
        )
      }),
      _vm._v(" "),
      _vm.currentSection
        ? _c(
            "foreignObject",
            {
              attrs: {
                x: "0",
                y: _vm.buttonSize + 6 + _vm.topOffset,
                width: _vm.item.area.w,
                height: "60",
                xmlns: "http://www.w3.org/1999/xhtml",
              },
            },
            [
              _c("div", { style: _vm.framesTextStyle }, [
                _c("div", [
                  _vm._v(
                    _vm._s(_vm.currentSection.number) +
                      " / " +
                      _vm._s(_vm.totalSections)
                  ),
                ]),
                _vm._v(" "),
                _vm.shoulShowCurrentSectionName
                  ? _c("div", [_vm._v(_vm._s(_vm.currentSection.name))])
                  : _vm._e(),
              ]),
            ]
          )
        : _vm._e(),
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/FramePlayer.vue?vue&type=template&id=a1ddaf4a&

// EXTERNAL MODULE: ./node_modules/lodash/forEach.js
var forEach = __webpack_require__(4486);
var forEach_default = /*#__PURE__*/__webpack_require__.n(forEach);
// EXTERNAL MODULE: ./src/ui/components/editor/EventBus.js
var EventBus = __webpack_require__(536);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/FramePlayer.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ const FramePlayervue_type_script_lang_js_ = ({
  props: ['item'],
  shapeConfig: {
    shapeType: 'vue',
    id: 'frame_player',
    menuItems: [{
      group: 'General',
      name: 'Frame Player',
      iconUrl: '/assets/images/items/frame-player.svg',
      size: {
        w: 140,
        h: 100
      },
      item: {
        textSlots: {
          title: {
            text: '<b>Frame Player</b>',
            color: '#000000',
            fontSize: 14
          }
        }
      }
    }],

    getPins(item) {
      return [];
    },

    getTextSlots(item) {
      return [{
        name: 'title',
        area: {
          x: 0,
          y: 0,
          w: item.area.w,
          h: Math.max(0, item.area.h - 60)
        }
      }];
    },

    computePath(item) {
      const w = item.area.w;
      const h = item.area.h;
      return `M 0 0   L ${w} 0  L ${w} ${h}  L 0 ${h} z`;
    },

    editorProps: {
      ignoreEventLayer: true
    },
    args: {
      totalFrames: {
        type: 'number',
        value: 5,
        name: 'Total frames'
      },
      fps: {
        type: 'number',
        value: 1,
        name: 'Frames per second'
      },
      fillColor: {
        type: 'color',
        value: 'rgba(220, 220, 220, 1.0)',
        name: 'Fill color'
      },
      hoverFillColor: {
        type: 'color',
        value: 'rgba(190, 190, 190, 1.0)',
        name: 'Hover fill color'
      },
      strokeColor: {
        type: 'color',
        value: 'rgba(30,30,30,1.0)',
        name: 'Stroke color'
      },
      animations: {
        type: 'animations',
        value: [],
        name: 'Animations',
        hidden: true
      },
      functions: {
        type: 'animation-functions',
        value: {},
        name: 'Animation Functions',
        hidden: true
      },
      sections: {
        type: 'animation-sections',
        value: [],
        name: 'Sections',
        hidden: true
      }
    }
  },

  beforeMount() {
    EventBus/* default.emitFramePlayerPrepared */.Z.emitFramePlayerPrepared(this.item, this.createFrameCallbacks());
  },

  data() {
    const sectionsMapping = [];
    const map = new Map();
    const sectionsByNumber = new Map();
    this.item.shapeProps.sections.sort((a, b) => a.frame - b.frame);
    forEach_default()(this.item.shapeProps.sections, (section, idx) => {
      const sectionInfo = {
        number: idx + 1,
        name: section.value,
        frame: section.frame
      };
      map.set(section.frame, sectionInfo);
      sectionsByNumber.set(sectionInfo.number, sectionInfo);
    });
    let firstSection = null;
    let currentSection = null;

    for (let i = 0; i < this.item.shapeProps.totalFrames; i++) {
      const frame = i + 1;

      if (map.has(frame)) {
        currentSection = map.get(frame);

        if (!firstSection) {
          firstSection = currentSection;
        }
      }

      sectionsMapping[i] = currentSection;
    }

    let buttons = [{
      icon: 'fas fa-play',
      iconPlaying: 'fas fa-pause',
      click: () => {
        this.onClickedTogglePlay();
      }
    }];

    if (this.item.shapeProps.sections.length > 0) {
      buttons = [{
        icon: 'fas fa-fast-backward',
        iconPlaying: 'fas fa-fast-backward',
        click: () => {
          this.onClickedToBegin();
        }
      }, {
        icon: 'fas fa-step-backward',
        iconPlaying: 'fas fa-step-backward',
        click: () => {
          this.onClickedLeft();
        }
      }].concat(buttons).concat([{
        icon: 'fas fa-step-forward',
        iconPlaying: 'fas fa-step-forward',
        click: () => {
          this.onClickPlayToNext();
        }
      }, {
        icon: 'fas fa-fast-forward',
        iconPlaying: 'fas fa-fast-forward',
        click: () => {
          this.onClickFastRight();
        }
      }]);
    }

    ;
    buttons.forEach(button => {
      button.fillColor = this.item.shapeProps.fillColor;
    });
    return {
      currentFrame: 1,
      isPlaying: false,
      intervalId: null,
      buttonSize: 20,
      buttonSpaceSize: 4,
      buttonFontSize: '10px',
      sectionsMapping,
      sectionsByNumber,
      currentSection: firstSection,
      totalSections: this.item.shapeProps.sections.length,
      buttons
    };
  },

  methods: {
    onClickedButton(buttonIndex) {
      this.buttons[buttonIndex].click();
    },

    onClickedToBegin() {
      const firstSection = this.sectionsByNumber.get(1);

      if (firstSection) {
        this.currentFrame = 1;
        this.currentSection = firstSection;
        this.emitCurrentFrameEvent();
      }
    },

    onClickFastRight() {
      if (this.currentSection) {
        const nextSection = this.sectionsByNumber.get(this.currentSection.number + 1);

        if (nextSection) {
          const nextFrame = nextSection.frame;

          if (nextFrame >= 0) {
            this.currentFrame = nextFrame;
            this.currentSection = nextSection;
            this.emitCurrentFrameEvent();
          }
        }
      }
    },

    onClickedLeft() {
      if (this.currentSection) {
        const prevSection = this.sectionsByNumber.get(this.currentSection.number - 1);

        if (prevSection) {
          const prevFrame = prevSection.frame;

          if (prevFrame >= 0) {
            this.currentFrame = prevFrame;
            this.currentSection = prevSection;
            this.emitCurrentFrameEvent();
          }
        }
      }
    },

    createFrameCallbacks() {
      return {
        onFrame: frame => {
          this.currentFrame = frame;

          if (frame <= this.sectionsMapping.length && frame > 0) {
            this.currentSection = this.sectionsMapping[frame - 1];
          }
        },
        onFinish: () => {
          this.isPlaying = false;
        }
      };
    },

    onClickPlayToNext() {
      if (this.currentSection) {
        let stopFrame = -1;
        const nextSection = this.sectionsByNumber.get(this.currentSection.number + 1);

        if (nextSection) {
          const nextFrame = nextSection.frame;

          if (nextFrame <= this.item.shapeProps.totalFrames) {
            stopFrame = nextFrame;
          }
        }

        this.$emit('frame-animator', {
          operation: 'play',
          item: this.item,
          frame: this.currentFrame,
          stopFrame: stopFrame,
          callbacks: this.createFrameCallbacks()
        });
      }
    },

    onClickedTogglePlay() {
      if (!this.isPlaying) {
        this.isPlaying = true;
        let startingFrame = this.currentFrame;

        if (this.currentFrame >= this.item.shapeProps.totalFrames) {
          startingFrame = 1;
        }

        this.$emit('frame-animator', {
          operation: 'play',
          item: this.item,
          frame: startingFrame,
          callbacks: this.createFrameCallbacks()
        });
      } else {
        this.$emit('frame-animator', {
          operation: 'stop',
          item: this.item
        });
      }
    },

    emitCurrentFrameEvent() {
      this.$emit('frame-animator', {
        operation: 'setFrame',
        item: this.item,
        frame: this.currentFrame
      });
    },

    onMouseOverButton(idx) {
      forEach_default()(this.buttons, (button, i) => {
        if (i === idx) {
          button.fillColor = this.item.shapeProps.hoverFillColor;
        } else {
          button.fillColor = this.item.shapeProps.fillColor;
        }
      });
    },

    onMouseOutButton(idx) {
      this.buttons[idx].fillColor = this.item.shapeProps.fillColor;
    }

  },
  computed: {
    leftOffset() {
      return this.item.area.w / 2 - (this.buttonSize * (this.buttons.length / 2) + this.buttonSpaceSize * (this.buttons.length - 1) / 2);
    },

    framesTextStyle() {
      return {
        'color': this.item.textSlots.title.color,
        'font-size': `${this.item.textSlots.title.fontSize}px`,
        'text-align': 'center'
      };
    },

    topOffset() {
      return Math.max(0, this.item.area.h - 60);
    },

    shoulShowCurrentSectionName() {
      if (this.currentSection) {
        return '' + this.currentSection.number !== this.currentSection.name;
      }

      return false;
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/FramePlayer.vue?vue&type=script&lang=js&
 /* harmony default export */ const shapes_FramePlayervue_type_script_lang_js_ = (FramePlayervue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/FramePlayer.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  shapes_FramePlayervue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/shapes/FramePlayer.vue"
/* harmony default export */ const FramePlayer = (component.exports);

/***/ }),

/***/ 4310:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ HUD)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/HUD.vue?vue&type=template&id=4c23a724&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "g",
    { attrs: { "data-preview-ignore": "true" } },
    [
      _c("advanced-fill", {
        attrs: {
          fillId: "fill-pattern-" + _vm.item.id,
          fill: _vm.item.shapeProps.fill,
          area: _vm.item.area,
        },
      }),
      _vm._v(" "),
      _c(
        "foreignObject",
        { attrs: { x: 0, y: -20, width: _vm.item.area.w, height: 20 } },
        [
          _c(
            "div",
            {
              staticStyle: {
                "font-size": "12px",
                "font-weight": "bold",
                display: "table-cell",
                padding: "2px 5px",
                height: "20px",
                "font-family": "Arial, Helvetica, sans-serif",
                "text-align": "left",
                "vertical-align": "bottom",
                "white-space": "normal",
              },
              style: {
                background: _vm.item.shapeProps.strokeColor,
                color: "white",
              },
              attrs: { "data-item-id": _vm.item.id },
            },
            [_vm._v("\n            " + _vm._s(_vm.item.name) + "\n        ")]
          ),
        ]
      ),
      _vm._v(" "),
      _c("path", {
        attrs: {
          d: _vm.shapePath,
          "stroke-width": _vm.item.shapeProps.strokeSize + "px",
          stroke: _vm.item.shapeProps.strokeColor,
          "stroke-dasharray": _vm.strokeDashArray,
          fill: _vm.fill,
        },
      }),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/HUD.vue?vue&type=template&id=4c23a724&

// EXTERNAL MODULE: ./src/ui/components/editor/items/AdvancedFill.vue + 4 modules
var AdvancedFill = __webpack_require__(6777);
// EXTERNAL MODULE: ./src/ui/components/editor/items/StrokePattern.js
var StrokePattern = __webpack_require__(4502);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/HUD.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



function computePath(item) {
  const W = item.area.w;
  const H = item.area.h;
  return `M ${W} ${H}  L 0 ${H} L 0 ${0}  L ${W} 0  L ${W} ${H} Z`;
}

/* harmony default export */ const HUDvue_type_script_lang_js_ = ({
  props: ['item'],
  shapeConfig: {
    shapeType: 'vue',
    components: {
      AdvancedFill: AdvancedFill/* default */.Z
    },
    id: 'hud',
    menuItems: [{
      group: 'General',
      name: 'HUD',
      iconUrl: '/assets/images/items/hud.svg',
      description: `
                HUD stands for Heads Up Display. 
                When going into view mode, HUD item will always be rendered in the viewport.
                This lets you design your own menu on top of the scheme which will always stay in the same place even if you drag screen`
    }],

    // it doesn't support text slots
    getTextSlots(item) {
      return [];
    },

    computePath,
    editorProps: {
      // flag to specify that it should only be rendered in edit mode
      onlyEditMode: true
    },
    args: {
      fill: {
        name: 'Fill',
        type: 'advanced-color',
        value: {
          type: 'solid',
          color: 'rgba(159, 227, 249, 0.1)'
        }
      },
      strokeColor: {
        name: 'Stroke',
        type: 'color',
        value: 'rgba(50, 175, 209, 1)'
      },
      strokeSize: {
        name: 'Stroke Size',
        type: 'number',
        value: 1
      },
      strokePattern: {
        type: 'stroke-pattern',
        value: 'dashed',
        name: 'Stroke pattern'
      },
      horizontalPosition: {
        type: 'choice',
        value: 'left',
        options: ['left', 'right', 'center'],
        name: 'Horizontal Position'
      },
      verticalPosition: {
        type: 'choice',
        value: 'top',
        options: ['top', 'bottom', 'center'],
        name: 'Vertical Position'
      }
    }
  },
  computed: {
    shapePath() {
      return computePath(this.item);
    },

    strokeDashArray() {
      return StrokePattern/* default.createDashArray */.Z.createDashArray(this.item.shapeProps.strokePattern, this.item.shapeProps.strokeSize);
    },

    fill() {
      return AdvancedFill/* default.computeStandardFill */.Z.computeStandardFill(this.item);
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/HUD.vue?vue&type=script&lang=js&
 /* harmony default export */ const shapes_HUDvue_type_script_lang_js_ = (HUDvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/HUD.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  shapes_HUDvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/shapes/HUD.vue"
/* harmony default export */ const HUD = (component.exports);

/***/ }),

/***/ 2709:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ Image)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/Image.vue?vue&type=template&id=fcff0770&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "g",
    [
      _c("advanced-fill", {
        attrs: {
          fillId: "fill-pattern-" + _vm.item.id,
          fill: _vm.item.shapeProps.fill,
          area: _vm.titleArea,
        },
      }),
      _vm._v(" "),
      _c("advanced-fill", {
        attrs: {
          fillId: "titlefill-pattern-" + _vm.item.id,
          fill: _vm.item.shapeProps.titleFill,
          area: _vm.item.area,
        },
      }),
      _vm._v(" "),
      _vm.item.shapeProps.showTitle
        ? _c("rect", {
            attrs: {
              x: 0,
              y: 0,
              width: _vm.item.area.w,
              height: _vm.item.shapeProps.titleHeight,
              "stroke-width": _vm.item.shapeProps.strokeSize + "px",
              stroke: _vm.item.shapeProps.strokeColor,
              fill: _vm.svgTitleFill,
            },
          })
        : _vm._e(),
      _vm._v(" "),
      _vm.item.shapeProps.showTitle
        ? _c("rect", {
            attrs: {
              x: _vm.imageX,
              y: _vm.imageY,
              width: _vm.imageWidth,
              height: _vm.imageHeight,
              "stroke-width": 0,
              stroke: "none",
              fill: _vm.svgFill,
            },
          })
        : _vm._e(),
      _vm._v(" "),
      _c("g", { attrs: { transform: "translate(0 " + _vm.imageY + ")" } }, [
        _vm.item.shapeProps.image
          ? _c("defs", [
              _c(
                "clipPath",
                { attrs: { id: "image-crop-clip-path-" + _vm.item.id } },
                [
                  _c("path", {
                    attrs: {
                      d:
                        "M 0 0  L " +
                        _vm.item.area.w +
                        " 0   L " +
                        _vm.item.area.w +
                        " " +
                        _vm.item.area.h +
                        "  L 0 " +
                        _vm.item.area.h +
                        " Z",
                      "data-item-id": _vm.item.id,
                      "stroke-width": "0px",
                      stroke: "rgba(255, 255, 255, 0)",
                      fill: "rgba(255, 255, 255, 0)",
                    },
                  }),
                ]
              ),
              _vm._v(" "),
              _c(
                "pattern",
                {
                  attrs: {
                    id: "image-fill-" + _vm.item.id,
                    patternUnits: "userSpaceOnUse",
                    width: _vm.imageWidth,
                    height: _vm.imageHeight,
                  },
                },
                [
                  _c("image", {
                    attrs: {
                      "xlink:href": _vm.item.shapeProps.image,
                      x: -_vm.item.shapeProps.crop.x * _vm.imageWidth,
                      y: -_vm.item.shapeProps.crop.y * _vm.imageHeight,
                      width:
                        _vm.imageWidth *
                        (1 +
                          _vm.item.shapeProps.crop.x +
                          _vm.item.shapeProps.crop.w),
                      height:
                        _vm.imageHeight *
                        (1 +
                          _vm.item.shapeProps.crop.y +
                          _vm.item.shapeProps.crop.h),
                      preserveAspectRatio: _vm.imagePreserveAspectRatio,
                    },
                  }),
                ]
              ),
            ])
          : _vm._e(),
        _vm._v(" "),
        _c(
          "g",
          {
            style: {
              "clip-path": "url(#image-crop-clip-path-" + _vm.item.id + ")",
            },
          },
          [
            _vm.item.shapeProps.image
              ? _c("rect", {
                  attrs: {
                    x: 0,
                    y: 0,
                    width: _vm.imageWidth,
                    height: _vm.imageHeight,
                    "stroke-width": _vm.item.shapeProps.strokeSize + "px",
                    stroke: _vm.item.shapeProps.strokeColor,
                    fill: "url(#image-fill-" + _vm.item.id + ")",
                  },
                })
              : _vm._e(),
          ]
        ),
      ]),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Image.vue?vue&type=template&id=fcff0770&

// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/ShapeDefaults.js
var ShapeDefaults = __webpack_require__(9498);
// EXTERNAL MODULE: ./src/ui/components/editor/items/AdvancedFill.vue + 4 modules
var AdvancedFill = __webpack_require__(6777);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/Image.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



const computePath = item => {
  const W = item.area.w;
  const H = item.area.h;
  return `M 0 0  L ${W} 0  L ${W} ${H} L 0 ${H} Z`;
};

/* harmony default export */ const Imagevue_type_script_lang_js_ = ({
  props: ['item'],
  components: {
    AdvancedFill: AdvancedFill/* default */.Z
  },
  shapeConfig: {
    shapeType: 'vue',
    id: 'image',
    menuItems: [{
      group: 'General',
      name: 'Image',
      imageProperty: 'shapeProps.image',
      iconUrl: '/assets/images/items/image.svg',
      description: 'It lets you upload an image or specify a link to external image',
      item: {
        shapeProps: {
          image: '/assets/images/missing-scheme-preview.png'
        }
      }
    }],

    getPins(item) {
      return (0,ShapeDefaults/* getStandardRectPins */.F)(item);
    },

    computePath,

    getTextSlots(item) {
      return [{
        name: "title",
        area: {
          x: 0,
          y: 0,
          w: item.area.w,
          h: Math.max(0, item.shapeProps.titleHeight)
        }
      }];
    },

    editorProps: {},
    args: {
      image: {
        type: 'image',
        name: 'Image'
      },
      stretch: {
        type: 'boolean',
        value: false,
        name: 'Stretch'
      },
      strokeColor: {
        type: 'color',
        value: 'rgba(80, 80, 80, 1.0)',
        name: 'Stroke color'
      },
      strokeSize: {
        type: 'number',
        value: 0,
        name: 'Stroke size'
      },
      showTitle: {
        type: 'boolean',
        value: false,
        name: 'Title'
      },
      crop: {
        type: 'crop-area',
        value: {
          x: 0,
          y: 0,
          w: 0,
          h: 0
        },
        name: 'Crop',
        hidden: true
      },
      titleHeight: {
        type: 'number',
        value: 36,
        name: 'Title height',
        min: 0,
        depends: {
          showTitle: true
        }
      },
      titleFill: {
        type: 'advanced-color',
        value: {
          type: 'solid',
          color: 'rgba(240,240,240,1.0)'
        },
        name: 'Title Background',
        depends: {
          showTitle: true
        }
      },
      fill: {
        type: 'advanced-color',
        value: {
          type: 'solid',
          color: 'rgba(240,240,240,1.0)'
        },
        name: 'Background',
        depends: {
          showTitle: true
        }
      }
    }
  },
  computed: {
    shapePath() {
      return computePath(this.item);
    },

    svgTitleFill() {
      return AdvancedFill/* default.computeStandardFillForValue */.Z.computeStandardFillForValue(this.item.shapeProps.titleFill, `titlefill-pattern-${this.item.id}`);
    },

    svgFill() {
      return AdvancedFill/* default.computeStandardFill */.Z.computeStandardFill(this.item);
    },

    imagePreserveAspectRatio() {
      if (!this.item.shapeProps.stretch) {
        return 'xMidYMid meet';
      }

      return 'none';
    },

    titleArea() {
      return {
        x: 0,
        y: 0,
        w: this.item.area.w,
        h: this.item.shapeProps.titleHeight
      };
    },

    imageX() {
      return 0;
    },

    imageY() {
      if (this.item.shapeProps.showTitle) {
        return this.item.shapeProps.titleHeight;
      }

      return 0;
    },

    imageWidth() {
      return this.item.area.w;
    },

    imageHeight() {
      if (this.item.shapeProps.showTitle) {
        return Math.max(0, this.item.area.h - this.item.shapeProps.titleHeight);
      }

      return this.item.area.h;
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Image.vue?vue&type=script&lang=js&
 /* harmony default export */ const shapes_Imagevue_type_script_lang_js_ = (Imagevue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Image.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  shapes_Imagevue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/shapes/Image.vue"
/* harmony default export */ const Image = (component.exports);

/***/ }),

/***/ 7025:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ Link)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/Link.vue?vue&type=template&id=44b9011d&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("g", [
    !_vm.hideTextSlot
      ? _c(
          "a",
          {
            staticClass: "item-link",
            attrs: {
              "xlink:href": _vm.item.shapeProps.url,
              target: _vm.target,
            },
            on: { click: _vm.onLinkClick },
          },
          [
            _vm.item.shapeProps.showIcon
              ? _c(
                  "foreignObject",
                  {
                    style: _vm.iconStyle,
                    attrs: {
                      x: "0",
                      y: "0",
                      width: _vm.textOffset,
                      height: _vm.item.area.h,
                    },
                  },
                  [
                    _c(
                      "div",
                      { attrs: { xmlns: "http://www.w3.org/1999/xhtml" } },
                      [_c("i", { class: _vm.iconClass })]
                    ),
                  ]
                )
              : _vm._e(),
            _vm._v(" "),
            _vm.textWidth > 0
              ? _c(
                  "foreignObject",
                  {
                    style: _vm.linkStyle,
                    attrs: {
                      x: _vm.textOffset,
                      y: "0",
                      width: _vm.textWidth,
                      height: _vm.item.area.h,
                    },
                  },
                  [
                    _c("div", {
                      attrs: { xmlns: "http://www.w3.org/1999/xhtml" },
                      domProps: { innerHTML: _vm._s(_vm.linkHtml) },
                    }),
                  ]
                )
              : _vm._e(),
          ]
        )
      : _vm._e(),
  ])
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Link.vue?vue&type=template&id=44b9011d&

// EXTERNAL MODULE: ./node_modules/lodash/map.js
var map = __webpack_require__(5161);
var map_default = /*#__PURE__*/__webpack_require__.n(map);
// EXTERNAL MODULE: ./src/ui/components/editor/LinkTypes.js
var LinkTypes = __webpack_require__(9874);
// EXTERNAL MODULE: ./src/htmlSanitize.js
var htmlSanitize = __webpack_require__(3762);
var htmlSanitize_default = /*#__PURE__*/__webpack_require__.n(htmlSanitize);
// EXTERNAL MODULE: ./src/ui/components/editor/EventBus.js
var EventBus = __webpack_require__(536);
// EXTERNAL MODULE: ./src/ui/components/editor/text/ItemText.js
var ItemText = __webpack_require__(5635);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/Link.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//





/* harmony default export */ const Linkvue_type_script_lang_js_ = ({
  props: ['item'],
  shapeConfig: {
    shapeType: 'vue',
    id: 'link',
    menuItems: [{
      group: 'General',
      name: 'Link',
      iconUrl: '/assets/images/items/link.svg',
      item: {
        textSlots: {
          link: {
            text: 'Link',
            fontSize: 16,
            padding: {
              left: 0,
              top: 0,
              bottom: 0,
              right: 0
            },
            color: '#047EFB',
            halign: 'left',
            valign: 'top'
          }
        }
      }
    }],

    computePath(item) {
      const w = item.area.w;
      const h = item.area.h;
      return `M 0 0   L ${w} 0  L ${w} ${h}  L 0 ${h} z`;
    },

    editorProps: {
      ignoreEventLayer: true,
      customTextRendering: true
    },

    getTextSlots(item) {
      return [{
        name: 'link',
        area: {
          x: 0,
          y: 0,
          w: item.area.w,
          h: item.area.h
        }
      }];
    },

    args: {
      url: {
        type: 'string',
        value: '',
        name: 'URL'
      },
      otherTab: {
        type: 'boolean',
        value: false,
        name: 'In Other Tab',
        description: 'Open the link in another tab'
      },
      underline: {
        type: 'boolean',
        value: true,
        name: 'Underline'
      },
      showIcon: {
        type: 'boolean',
        value: true,
        name: 'Show Icon'
      },
      icon: {
        type: 'choice',
        value: 'default',
        name: 'Icon',
        options: map_default()(LinkTypes/* default.knownTypes */.Z.knownTypes, linkType => linkType.name)
      },
      iconColor: {
        type: 'color',
        value: '#666666',
        name: 'Color',
        depends: {
          showIcon: true
        }
      }
    }
  },

  beforeMount() {
    EventBus/* default.subscribeForItemChanged */.Z.subscribeForItemChanged(this.item.id, this.onItemChanged);
    EventBus/* default.$on */.Z.$on(EventBus/* default.ITEM_TEXT_SLOT_EDIT_TRIGGERED */.Z.ITEM_TEXT_SLOT_EDIT_TRIGGERED, this.onItemTextSlotEditTriggered);
    EventBus/* default.$on */.Z.$on(EventBus/* default.ITEM_TEXT_SLOT_EDIT_CANCELED */.Z.ITEM_TEXT_SLOT_EDIT_CANCELED, this.onItemTextSlotEditCanceled);
  },

  beforeDestroy() {
    EventBus/* default.unsubscribeForItemChanged */.Z.unsubscribeForItemChanged(this.item.id, this.onItemChanged);
    EventBus/* default.$off */.Z.$off(EventBus/* default.ITEM_TEXT_SLOT_EDIT_TRIGGERED */.Z.ITEM_TEXT_SLOT_EDIT_TRIGGERED, this.onItemTextSlotEditTriggered);
    EventBus/* default.$off */.Z.$off(EventBus/* default.ITEM_TEXT_SLOT_EDIT_CANCELED */.Z.ITEM_TEXT_SLOT_EDIT_CANCELED, this.onItemTextSlotEditCanceled);
  },

  data() {
    return {
      linkStyle: this.createLinkStyle(),
      hideTextSlot: false
    };
  },

  methods: {
    createLinkStyle() {
      const style = (0,ItemText/* generateTextStyle */.A)(this.item.textSlots.link);
      style['text-decoration'] = this.item.shapeProps.underline ? 'underline' : 'none';
      return style;
    },

    onLinkClick(event) {
      if (this.item.shapeProps.url.startsWith('/')) {
        window.location = url;
        event.preventDefault();
      }

      return false;
    },

    calculateTextOffset() {
      if (this.item.shapeProps.showIcon) {
        return this.item.textSlots.link.fontSize * 1.4;
      }

      return 0;
    },

    onItemChanged() {
      this.linkStyle = this.createLinkStyle();
    },

    onItemTextSlotEditTriggered(item, slotName, area, markupDisabled) {
      if (item.id === this.item.id) {
        this.hideTextSlot = true;
      }
    },

    onItemTextSlotEditCanceled(item, slotName) {
      if (item.id === this.item.id) {
        this.hideTextSlot = false;
      }
    }

  },
  computed: {
    target() {
      if (this.item.shapeProps.otherTab) {
        return '_blank';
      }

      return '_self';
    },

    iconStyle() {
      return {
        'color': this.item.shapeProps.iconColor,
        'padding-top': this.linkStyle['padding-left'],
        'padding-bottom': this.linkStyle['padding-left']
      };
    },

    linkHtml() {
      return htmlSanitize_default()(this.item.textSlots.link.text);
    },

    textOffset() {
      return this.calculateTextOffset();
    },

    textWidth() {
      return this.item.area.w - this.calculateTextOffset();
    },

    iconClass() {
      return LinkTypes/* default.findTypeByNameOrDefault */.Z.findTypeByNameOrDefault(this.item.shapeProps.icon).cssClass;
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Link.vue?vue&type=script&lang=js&
 /* harmony default export */ const shapes_Linkvue_type_script_lang_js_ = (Linkvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Link.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  shapes_Linkvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/shapes/Link.vue"
/* harmony default export */ const Link = (component.exports);

/***/ }),

/***/ 3057:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ Path)
});

// UNUSED EXPORTS: simplifyPathPoints

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/Path.vue?vue&type=template&id=471ea7c8&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "g",
    [
      _c("advanced-fill", {
        attrs: {
          fillId: "fill-pattern-" + _vm.item.id,
          fill: _vm.item.shapeProps.fill,
          area: _vm.item.area,
        },
      }),
      _vm._v(" "),
      _c("path", {
        staticStyle: { "stroke-linejoin": "round" },
        attrs: {
          d: _vm.shapePath,
          "stroke-width": _vm.item.shapeProps.strokeSize + "px",
          stroke: _vm.item.shapeProps.strokeColor,
          "stroke-dasharray": _vm.strokeDashArray,
          fill: _vm.fill,
        },
      }),
      _vm._v(" "),
      _vm._l(_vm.caps, function (cap) {
        return _c("path", {
          attrs: {
            d: cap.path,
            "data-item-id": _vm.item.id,
            stroke: _vm.item.shapeProps.strokeColor,
            "stroke-width": _vm.item.shapeProps.strokeSize,
            fill: cap.fill,
            "stroke-linejoin": "round",
          },
        })
      }),
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Path.vue?vue&type=template&id=471ea7c8&

// EXTERNAL MODULE: ./src/ui/components/editor/items/AdvancedFill.vue + 4 modules
var AdvancedFill = __webpack_require__(6777);
// EXTERNAL MODULE: ./src/ui/components/editor/items/StrokePattern.js
var StrokePattern = __webpack_require__(4502);
// EXTERNAL MODULE: ./src/ui/components/editor/EventBus.js
var EventBus = __webpack_require__(536);
// EXTERNAL MODULE: ./src/ui/logger.js
var logger = __webpack_require__(2017);
// EXTERNAL MODULE: ./src/ui/myMath.js
var ui_myMath = __webpack_require__(3590);
// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/ConnectorCaps.js
var ConnectorCaps = __webpack_require__(125);
// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/StandardCurves.js
var StandardCurves = __webpack_require__(8270);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/Path.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//








const log = new logger/* Logger */.Yd('Path');

function worldPointOnItem(x, y, item) {
  return ui_myMath/* default.worldPointInArea */.Z.worldPointInArea(x, y, item.area, item.meta && item.meta.transformMatrix ? item.meta.transformMatrix : null);
}

function computePath(item) {
  let svgPath = '';
  item.shapeProps.paths.forEach(path => {
    const segmentPath = (0,StandardCurves/* computeCurvePath */.FI)(item.area.w, item.area.h, path.points, path.closed);

    if (segmentPath) {
      svgPath += segmentPath + ' ';
    }
  });
  return svgPath;
}

;
/**
 * Takes points of the path and simplifies them (tries to delete as many points as possible)
 * @property {Array} points - points of the path 
 * @property {Number} epsilon - minimum distance of the points to keep (used in Ramer-Douglas-Peucker algorithm)
 * @returns {Array} simplified path points 
 */

function simplifyPathPoints(points, epsilon) {
  if (!epsilon) {
    epsilon = 5;
  } // first we need to break the curve into smaller curves based on the point breaks


  const curves = [];
  let currentPathPoints = [];
  curves.push(currentPathPoints);
  points.forEach((point, i) => {
    if (point.break) {
      currentPathPoints = [];
      curves.push(currentPathPoints);
    }

    currentPathPoints.push(point);
  });
  let newPoints = [];
  curves.forEach((curvePoints, i) => {
    const simplifiedPoints = myMath.smoothPathPoints(myMath.simplifyPathPointsUsingRDP(curvePoints, epsilon));

    if (i > 0 && curvePoints.length > 0) {
      curvePoints[0].break = true;
    }

    newPoints = newPoints.concat(simplifiedPoints);
  });
  return newPoints;
}
/**
 * @property {Item} item 
 * @property {Object} schemeContainer 
 * @property {Boolean} isSoft 
 * @property {ItemModificationContext} context 
 * @property {Number} precision - number of digits after point which it should round to
 */

function readjustItem(item, schemeContainer, isSoft, context, precision) {
  log.info('readjustItem', item.id, item.name, {
    item,
    isSoft,
    context
  }, precision);

  if (!isSoft) {// readjustItemArea(item, precision);
  }

  return true;
}

function getSnappers(item) {
  const snappers = [];
  item.shapeProps.paths.forEach(path => {
    path.points.forEach(point => {
      const worldPoint = worldPointOnItem(point.x, point.y, item);
      snappers.push({
        item,
        snapperType: 'horizontal',
        value: worldPoint.y
      });
      snappers.push({
        item,
        snapperType: 'vertical',
        value: worldPoint.x
      });
    });
  });
  return snappers;
}

/* harmony default export */ const Pathvue_type_script_lang_js_ = ({
  props: ['item'],
  components: {
    AdvancedFill: AdvancedFill/* default */.Z
  },
  shapeConfig: {
    shapeType: 'vue',
    id: 'path',
    menuItems: [],
    computePath,
    readjustItem,
    getSnappers,

    getPins(item) {
      return [];
    },

    /**
     * Disabling any text slots for path items. Otherwise users will be confused when they double click on it in edit mode.
     */
    getTextSlots() {
      return [];
    },

    editorProps: {
      description: 'rich'
    },
    controlPoints: null,
    args: {
      fill: {
        type: 'advanced-color',
        value: {
          type: 'none'
        },
        name: 'Fill'
      },
      strokeColor: {
        type: 'color',
        value: 'rgba(30,30,30,1.0)',
        name: 'Stroke color'
      },
      strokeSize: {
        type: 'number',
        value: 2,
        name: 'Stroke size'
      },
      strokePattern: {
        type: 'stroke-pattern',
        value: 'solid',
        name: 'Stroke pattern'
      },
      paths: {
        type: 'path-array',
        value: [],
        name: 'Paths',
        hidden: true
      },
      sourceCap: {
        type: 'path-cap',
        value: 'empty',
        name: 'Source Cap'
      },
      sourceCapSize: {
        type: 'number',
        value: 20,
        name: 'Source Cap Size'
      },
      sourceCapFill: {
        type: 'color',
        value: 'rgba(30,30,30,1.0)',
        name: 'Source Cap Fill'
      },
      destinationCap: {
        type: 'path-cap',
        value: 'empty',
        name: 'Destination Cap'
      },
      destinationCapSize: {
        type: 'number',
        value: 20,
        name: 'Destination Cap Size'
      },
      destinationCapFill: {
        type: 'color',
        value: 'rgba(30,30,30,1.0)',
        name: 'Destination Cap Fill'
      }
    }
  },

  mounted() {
    EventBus/* default.subscribeForItemChanged */.Z.subscribeForItemChanged(this.item.id, this.onItemChange);
  },

  beforeDestroy() {
    EventBus/* default.unsubscribeForItemChanged */.Z.unsubscribeForItemChanged(this.item.id, this.onItemChange);
  },

  data() {
    const shapePath = computePath(this.item);
    return {
      shapePath: shapePath,
      caps: this.computeCaps(shapePath)
    };
  },

  methods: {
    onItemChange() {
      log.info('onItemChange', this.item.id, this.item.name, this.item);
      this.shapePath = computePath(this.item);
      this.caps = this.computeCaps(this.shapePath);
      log.info('computed path and caps', this.item.id, this.item.name, this.shapePath, this.caps);
      this.$forceUpdate();
    },

    computeCaps(svgPath) {
      const caps = [];
      let sourceCap = this.item.shapeProps.sourceCap || 'empty';
      let destinationCap = this.item.shapeProps.destinationCap || 'empty';

      if (sourceCap === 'empty' && destinationCap === 'empty') {
        return caps;
      }

      const shadowSvgPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      shadowSvgPath.setAttribute('d', svgPath);
      const totalLength = shadowSvgPath.getTotalLength();

      if (totalLength < 3) {
        return caps;
      }

      let cap = this.computeCapByPosition(shadowSvgPath, 0, this.item.shapeProps.sourceCapSize, sourceCap, this.item.shapeProps.sourceCapFill);

      if (cap) {
        caps.push(cap);
      }

      cap = this.computeCapByPosition(shadowSvgPath, totalLength, totalLength - this.item.shapeProps.destinationCapSize, destinationCap, this.item.shapeProps.destinationCapFill);

      if (cap) {
        caps.push(cap);
      }

      return caps;
    },

    computeCapByPosition(shadowSvgPath, d1, d2, capType, capFill) {
      if (capType !== 'empty') {
        const p1 = shadowSvgPath.getPointAtLength(d1);
        const p2 = shadowSvgPath.getPointAtLength(d2);
        const squaredD = (p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y);

        if (squaredD > 0.01) {
          return (0,ConnectorCaps/* createConnectorCap */.g)(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y, capType, capFill);
        }
      }

      return null;
    }

  },
  computed: {
    strokeDashArray() {
      return StrokePattern/* default.createDashArray */.Z.createDashArray(this.item.shapeProps.strokePattern, this.item.shapeProps.strokeSize);
    },

    fill() {
      return AdvancedFill/* default.computeStandardFill */.Z.computeStandardFill(this.item);
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Path.vue?vue&type=script&lang=js&
 /* harmony default export */ const shapes_Pathvue_type_script_lang_js_ = (Pathvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/Path.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  shapes_Pathvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/shapes/Path.vue"
/* harmony default export */ const Path = (component.exports);

/***/ }),

/***/ 2584:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ StickyNote)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/StickyNote.vue?vue&type=template&id=d61a6444&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "g",
    [
      _c("advanced-fill", {
        attrs: {
          fillId: "fill-pattern-" + _vm.item.id,
          fill: _vm.item.shapeProps.fill,
          area: _vm.item.area,
        },
      }),
      _vm._v(" "),
      _c(
        "defs",
        [
          _c(
            "linearGradient",
            {
              attrs: {
                id: "sticky-note-gradient-" + _vm.item.id,
                x1: "50%",
                y1: "100%",
                x2: "50%",
                y2: "0%",
              },
            },
            [
              _c("stop", {
                staticStyle: { "stop-color": "rgba(196, 196, 196, 0.14)" },
                attrs: { offset: "0%" },
              }),
              _vm._v(" "),
              _c("stop", {
                staticStyle: { "stop-color": "rgba(128, 128, 128, 0.4)" },
                attrs: { offset: "80.56%" },
              }),
              _vm._v(" "),
              _c("stop", {
                staticStyle: { "stop-color": "rgba(0, 0, 0, 0.23)" },
                attrs: { offset: "87.22%" },
              }),
              _vm._v(" "),
              _c("stop", {
                staticStyle: { "stop-color": "rgba(0, 0, 0, 0.3)" },
                attrs: { offset: "100%" },
              }),
            ],
            1
          ),
        ],
        1
      ),
      _vm._v(" "),
      _c("defs", [
        _c(
          "filter",
          { attrs: { id: "sticky-note-shadow-filter-" + _vm.item.id } },
          [
            _c("feGaussianBlur", {
              attrs: { in: "SourceGraphic", stdDeviation: "4" },
            }),
          ],
          1
        ),
      ]),
      _vm._v(" "),
      _c(
        "g",
        {
          style: { opacity: 0.2 },
          attrs: {
            filter: "url(#sticky-note-shadow-filter-" + _vm.item.id + ")",
          },
        },
        [
          _c("path", {
            attrs: {
              d: _vm.shadowPath,
              stroke: "none",
              fill: "rgba(0, 0, 0, 1)",
            },
          }),
        ]
      ),
      _vm._v(" "),
      _c("path", {
        attrs: { d: _vm.shapePath, stroke: "none", fill: _vm.svgFill },
      }),
      _vm._v(" "),
      _c("path", {
        style: { opacity: 0.5, "mix-blend-mode": "multiply" },
        attrs: {
          d: _vm.shapePath,
          stroke: "none",
          fill: "url(#sticky-note-gradient-" + _vm.item.id + ")",
        },
      }),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/StickyNote.vue?vue&type=template&id=d61a6444&

// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/ShapeDefaults.js
var ShapeDefaults = __webpack_require__(9498);
// EXTERNAL MODULE: ./src/ui/components/editor/items/AdvancedFill.vue + 4 modules
var AdvancedFill = __webpack_require__(6777);
// EXTERNAL MODULE: ./node_modules/lodash/map.js
var map = __webpack_require__(5161);
var map_default = /*#__PURE__*/__webpack_require__.n(map);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/StickyNote.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




function computePath(item) {
  const W = item.area.w;
  const H = item.area.h;
  return `M ${W} ${H}  L 0 ${H} L 0 0   L ${W} 0 L ${W} ${H} Z`;
}

;
const palette = [{
  name: 'yellow',
  color: 'rgba(240,234,55,1)'
}, {
  name: 'red',
  color: 'rgba(255,98,55,1)'
}, {
  name: 'lime',
  color: 'rgba(175,255,105,1)'
}, {
  name: 'green',
  color: 'rgba(148,255,112,1)'
}, {
  name: 'blue',
  color: 'rgba(116,255,255,1)'
}, {
  name: 'purple',
  color: 'rgba(212,184,255,1)'
}, {
  name: 'pink',
  color: 'rgba(255,184,235,1)'
}, {
  name: 'white',
  color: 'rgba(250,250,250,1)'
}, {
  name: 'grey',
  color: 'rgba(200,200,200,1)'
}];

function generateItemMenu() {
  return map_default()(palette, p => {
    return {
      group: 'Sticky Notes',
      name: `Sticky Note (${p.name})`,
      iconSVG: `<path fill="${p.color}" d="M 1 1  L 41 1  L 41 31  L 1 31 Z"/>`,
      item: {
        shapeProps: {
          fill: {
            type: 'solid',
            color: p.color
          }
        }
      },
      size: {
        w: 180,
        h: 180
      }
    };
  });
}

/* harmony default export */ const StickyNotevue_type_script_lang_js_ = ({
  props: ['item'],
  components: {
    AdvancedFill: AdvancedFill/* default */.Z
  },
  shapeConfig: {
    shapeType: 'vue',
    id: 'sticky_note',
    menuItems: generateItemMenu(),

    getPins(item) {
      return (0,ShapeDefaults/* getStandardRectPins */.F)(item);
    },

    getTextSlots(item) {
      return [{
        name: 'body',
        area: {
          x: 0,
          y: 0,
          w: item.area.w,
          h: item.area.h
        }
      }];
    },

    computePath,
    args: {
      fill: {
        type: 'advanced-color',
        value: {
          type: 'solid',
          color: 'rgba(240, 234, 55, 1.0)'
        },
        name: 'Fill'
      }
    }
  },

  data() {
    return {};
  },

  computed: {
    shapePath() {
      return computePath(this.item);
    },

    shadowPath() {
      const x0 = this.item.area.w * 0.1;
      const x1 = this.item.area.w * 0.99;
      const y0 = this.item.area.h * 0.1;
      const y1 = this.item.area.h * 0.99;
      const w = this.item.area.w * 1.03;
      const h = this.item.area.h * 1.03;
      return `M ${x0} ${y0}  L ${x1} ${y0} L ${w} ${h}  L ${x0} ${y1} Z`;
    },

    svgFill() {
      return AdvancedFill/* default.computeSvgFill */.Z.computeSvgFill(this.item.shapeProps.fill, `fill-pattern-${this.item.id}`);
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/StickyNote.vue?vue&type=script&lang=js&
 /* harmony default export */ const shapes_StickyNotevue_type_script_lang_js_ = (StickyNotevue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/StickyNote.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  shapes_StickyNotevue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/shapes/StickyNote.vue"
/* harmony default export */ const StickyNote = (component.exports);

/***/ }),

/***/ 958:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ UMLActor)
});

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/uml/UMLActor.vue?vue&type=template&id=a9066502&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "g",
    [
      _c("advanced-fill", {
        attrs: {
          fillId: "fill-pattern-" + _vm.item.id,
          fill: _vm.item.shapeProps.fill,
          area: _vm.item.area,
        },
      }),
      _vm._v(" "),
      _c("path", {
        attrs: {
          d:
            "M " +
            _vm.item.area.w / 2 +
            " " +
            _vm.headRadius * 2 +
            "  L " +
            _vm.item.area.w / 2 +
            " " +
            _vm.bodyY +
            "  M 0 " +
            _vm.armY +
            " L " +
            _vm.item.area.w +
            " " +
            _vm.armY +
            "  M 0 " +
            _vm.item.area.h +
            " L " +
            _vm.item.area.w / 2 +
            " " +
            _vm.bodyY +
            " L " +
            _vm.item.area.w +
            " " +
            _vm.item.area.h,
          fill: "none",
          stroke: _vm.item.shapeProps.strokeColor,
          "stroke-width": _vm.item.shapeProps.strokeSize + "px",
        },
      }),
      _vm._v(" "),
      _c("circle", {
        attrs: {
          cx: _vm.item.area.w / 2,
          cy: _vm.headRadius,
          r: _vm.headRadius,
          fill: _vm.fill,
          stroke: _vm.item.shapeProps.strokeColor,
          "stroke-width": _vm.item.shapeProps.strokeSize + "px",
        },
      }),
    ],
    1
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/uml/UMLActor.vue?vue&type=template&id=a9066502&

// EXTERNAL MODULE: ./src/ui/components/editor/items/AdvancedFill.vue + 4 modules
var AdvancedFill = __webpack_require__(6777);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/shapes/uml/UMLActor.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const UMLActorvue_type_script_lang_js_ = ({
  props: ['item'],
  shapeConfig: {
    shapeType: 'vue',
    components: {
      AdvancedFill: AdvancedFill/* default */.Z
    },
    id: 'uml_actor',
    menuItems: [{
      group: 'UML',
      name: 'Actor',
      iconUrl: '/assets/images/items/uml-actor.svg',
      previewArea: {
        x: 0,
        y: 0,
        w: 30,
        h: 90,
        r: 0
      }
    }],

    computePath(item) {
      return `M 0 0  l ${item.area.w} 0  l 0 ${item.area.h}  l ${-item.area.w} 0 z`;
    },

    // it doesn't support text slots
    getTextSlots(item) {
      return [];
    },

    args: {
      fill: {
        name: 'Fill',
        type: 'advanced-color',
        value: {
          type: 'solid',
          color: 'rgba(240, 240, 240, 1.0)'
        }
      },
      strokeColor: {
        name: 'Stroke',
        type: 'color',
        value: 'rgba(0, 0, 0, 1)'
      },
      strokeSize: {
        name: 'Stroke Size',
        type: 'number',
        value: 1
      }
    }
  },
  computed: {
    headRadius() {
      return Math.min(this.item.area.w / 4, this.item.area.h / 8);
    },

    armY() {
      return this.item.area.h / 4;
    },

    bodyY() {
      return this.item.area.h - this.item.area.h / 3;
    },

    fill() {
      return AdvancedFill/* default.computeStandardFill */.Z.computeStandardFill(this.item);
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/uml/UMLActor.vue?vue&type=script&lang=js&
 /* harmony default export */ const uml_UMLActorvue_type_script_lang_js_ = (UMLActorvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/uml/UMLActor.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  uml_UMLActorvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/shapes/uml/UMLActor.vue"
/* harmony default export */ const UMLActor = (component.exports);

/***/ }),

/***/ 1900:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ normalizeComponent)
/* harmony export */ });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ 1094:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
(function (global, factory) {
   true ? module.exports = factory() :
  0;
}(this, function () { 'use strict';

  /*  */

  var emptyObject = Object.freeze({});

  // These helpers produce better VM code in JS engines due to their
  // explicitness and function inlining.
  function isUndef (v) {
    return v === undefined || v === null
  }

  function isDef (v) {
    return v !== undefined && v !== null
  }

  function isTrue (v) {
    return v === true
  }

  function isFalse (v) {
    return v === false
  }

  /**
   * Check if value is primitive.
   */
  function isPrimitive (value) {
    return (
      typeof value === 'string' ||
      typeof value === 'number' ||
      // $flow-disable-line
      typeof value === 'symbol' ||
      typeof value === 'boolean'
    )
  }

  /**
   * Quick object check - this is primarily used to tell
   * Objects from primitive values when we know the value
   * is a JSON-compliant type.
   */
  function isObject (obj) {
    return obj !== null && typeof obj === 'object'
  }

  /**
   * Get the raw type string of a value, e.g., [object Object].
   */
  var _toString = Object.prototype.toString;

  function toRawType (value) {
    return _toString.call(value).slice(8, -1)
  }

  /**
   * Strict object type check. Only returns true
   * for plain JavaScript objects.
   */
  function isPlainObject (obj) {
    return _toString.call(obj) === '[object Object]'
  }

  function isRegExp (v) {
    return _toString.call(v) === '[object RegExp]'
  }

  /**
   * Check if val is a valid array index.
   */
  function isValidArrayIndex (val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val)
  }

  function isPromise (val) {
    return (
      isDef(val) &&
      typeof val.then === 'function' &&
      typeof val.catch === 'function'
    )
  }

  /**
   * Convert a value to a string that is actually rendered.
   */
  function toString (val) {
    return val == null
      ? ''
      : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
        ? JSON.stringify(val, null, 2)
        : String(val)
  }

  /**
   * Convert an input value to a number for persistence.
   * If the conversion fails, return original string.
   */
  function toNumber (val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n
  }

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   */
  function makeMap (
    str,
    expectsLowerCase
  ) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase
      ? function (val) { return map[val.toLowerCase()]; }
      : function (val) { return map[val]; }
  }

  /**
   * Check if a tag is a built-in tag.
   */
  var isBuiltInTag = makeMap('slot,component', true);

  /**
   * Check if an attribute is a reserved attribute.
   */
  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

  /**
   * Remove an item from an array.
   */
  function remove (arr, item) {
    if (arr.length) {
      var index = arr.indexOf(item);
      if (index > -1) {
        return arr.splice(index, 1)
      }
    }
  }

  /**
   * Check whether an object has the property.
   */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn (obj, key) {
    return hasOwnProperty.call(obj, key)
  }

  /**
   * Create a cached version of a pure function.
   */
  function cached (fn) {
    var cache = Object.create(null);
    return (function cachedFn (str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str))
    })
  }

  /**
   * Camelize a hyphen-delimited string.
   */
  var camelizeRE = /-(\w)/g;
  var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
  });

  /**
   * Capitalize a string.
   */
  var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1)
  });

  /**
   * Hyphenate a camelCase string.
   */
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase()
  });

  /**
   * Simple bind polyfill for environments that do not support it,
   * e.g., PhantomJS 1.x. Technically, we don't need this anymore
   * since native bind is now performant enough in most browsers.
   * But removing it would mean breaking code that was able to run in
   * PhantomJS 1.x, so this must be kept for backward compatibility.
   */

  /* istanbul ignore next */
  function polyfillBind (fn, ctx) {
    function boundFn (a) {
      var l = arguments.length;
      return l
        ? l > 1
          ? fn.apply(ctx, arguments)
          : fn.call(ctx, a)
        : fn.call(ctx)
    }

    boundFn._length = fn.length;
    return boundFn
  }

  function nativeBind (fn, ctx) {
    return fn.bind(ctx)
  }

  var bind = Function.prototype.bind
    ? nativeBind
    : polyfillBind;

  /**
   * Convert an Array-like object to a real Array.
   */
  function toArray (list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
      ret[i] = list[i + start];
    }
    return ret
  }

  /**
   * Mix properties into target object.
   */
  function extend (to, _from) {
    for (var key in _from) {
      to[key] = _from[key];
    }
    return to
  }

  /**
   * Merge an Array of Objects into a single Object.
   */
  function toObject (arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }
    return res
  }

  /* eslint-disable no-unused-vars */

  /**
   * Perform no operation.
   * Stubbing args to make Flow happy without leaving useless transpiled code
   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
   */
  function noop (a, b, c) {}

  /**
   * Always return false.
   */
  var no = function (a, b, c) { return false; };

  /* eslint-enable no-unused-vars */

  /**
   * Return the same value.
   */
  var identity = function (_) { return _; };

  /**
   * Generate a string containing static keys from compiler modules.
   */
  function genStaticKeys (modules) {
    return modules.reduce(function (keys, m) {
      return keys.concat(m.staticKeys || [])
    }, []).join(',')
  }

  /**
   * Check if two values are loosely equal - that is,
   * if they are plain objects, do they have the same shape?
   */
  function looseEqual (a, b) {
    if (a === b) { return true }
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
      try {
        var isArrayA = Array.isArray(a);
        var isArrayB = Array.isArray(b);
        if (isArrayA && isArrayB) {
          return a.length === b.length && a.every(function (e, i) {
            return looseEqual(e, b[i])
          })
        } else if (a instanceof Date && b instanceof Date) {
          return a.getTime() === b.getTime()
        } else if (!isArrayA && !isArrayB) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          return keysA.length === keysB.length && keysA.every(function (key) {
            return looseEqual(a[key], b[key])
          })
        } else {
          /* istanbul ignore next */
          return false
        }
      } catch (e) {
        /* istanbul ignore next */
        return false
      }
    } else if (!isObjectA && !isObjectB) {
      return String(a) === String(b)
    } else {
      return false
    }
  }

  /**
   * Return the first index at which a loosely equal value can be
   * found in the array (if value is a plain object, the array must
   * contain an object of the same shape), or -1 if it is not present.
   */
  function looseIndexOf (arr, val) {
    for (var i = 0; i < arr.length; i++) {
      if (looseEqual(arr[i], val)) { return i }
    }
    return -1
  }

  /**
   * Ensure a function is called only once.
   */
  function once (fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    }
  }

  var SSR_ATTR = 'data-server-rendered';

  var ASSET_TYPES = [
    'component',
    'directive',
    'filter'
  ];

  var LIFECYCLE_HOOKS = [
    'beforeCreate',
    'created',
    'beforeMount',
    'mounted',
    'beforeUpdate',
    'updated',
    'beforeDestroy',
    'destroyed',
    'activated',
    'deactivated',
    'errorCaptured',
    'serverPrefetch'
  ];

  /*  */



  var config = ({
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),

    /**
     * Whether to suppress warnings.
     */
    silent: false,

    /**
     * Show production mode tip message on boot?
     */
    productionTip: "development" !== 'production',

    /**
     * Whether to enable devtools
     */
    devtools: "development" !== 'production',

    /**
     * Whether to record perf
     */
    performance: false,

    /**
     * Error handler for watcher errors
     */
    errorHandler: null,

    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,

    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],

    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),

    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,

    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,

    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,

    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,

    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,

    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,

    /**
     * Perform updates asynchronously. Intended to be used by Vue Test Utils
     * This will significantly reduce performance if set to false.
     */
    async: true,

    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
  });

  /*  */

  /**
   * unicode letters used for parsing html tags, component names and property paths.
   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
   * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
   */
  var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

  /**
   * Check if a string starts with $ or _
   */
  function isReserved (str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5F
  }

  /**
   * Define a property.
   */
  function def (obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }

  /**
   * Parse simple path.
   */
  var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
  function parsePath (path) {
    if (bailRE.test(path)) {
      return
    }
    var segments = path.split('.');
    return function (obj) {
      for (var i = 0; i < segments.length; i++) {
        if (!obj) { return }
        obj = obj[segments[i]];
      }
      return obj
    }
  }

  /*  */

  // can we use __proto__?
  var hasProto = '__proto__' in {};

  // Browser environment sniffing
  var inBrowser = typeof window !== 'undefined';
  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
  var isIE = UA && /msie|trident/.test(UA);
  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
  var isEdge = UA && UA.indexOf('edge/') > 0;
  var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
  var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
  var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
  var isPhantomJS = UA && /phantomjs/.test(UA);
  var isFF = UA && UA.match(/firefox\/(\d+)/);

  // Firefox has a "watch" function on Object.prototype...
  var nativeWatch = ({}).watch;

  var supportsPassive = false;
  if (inBrowser) {
    try {
      var opts = {};
      Object.defineProperty(opts, 'passive', ({
        get: function get () {
          /* istanbul ignore next */
          supportsPassive = true;
        }
      })); // https://github.com/facebook/flow/issues/285
      window.addEventListener('test-passive', null, opts);
    } catch (e) {}
  }

  // this needs to be lazy-evaled because vue may be required before
  // vue-server-renderer can set VUE_ENV
  var _isServer;
  var isServerRendering = function () {
    if (_isServer === undefined) {
      /* istanbul ignore if */
      if (!inBrowser && !inWeex && typeof __webpack_require__.g !== 'undefined') {
        // detect presence of vue-server-renderer and avoid
        // Webpack shimming the process
        _isServer = __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';
      } else {
        _isServer = false;
      }
    }
    return _isServer
  };

  // detect devtools
  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

  /* istanbul ignore next */
  function isNative (Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
  }

  var hasSymbol =
    typeof Symbol !== 'undefined' && isNative(Symbol) &&
    typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

  var _Set;
  /* istanbul ignore if */ // $flow-disable-line
  if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
  } else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = /*@__PURE__*/(function () {
      function Set () {
        this.set = Object.create(null);
      }
      Set.prototype.has = function has (key) {
        return this.set[key] === true
      };
      Set.prototype.add = function add (key) {
        this.set[key] = true;
      };
      Set.prototype.clear = function clear () {
        this.set = Object.create(null);
      };

      return Set;
    }());
  }

  /*  */

  var warn = noop;
  var tip = noop;
  var generateComponentTrace = (noop); // work around flow check
  var formatComponentName = (noop);

  {
    var hasConsole = typeof console !== 'undefined';
    var classifyRE = /(?:^|[-_])(\w)/g;
    var classify = function (str) { return str
      .replace(classifyRE, function (c) { return c.toUpperCase(); })
      .replace(/[-_]/g, ''); };

    warn = function (msg, vm) {
      var trace = vm ? generateComponentTrace(vm) : '';

      if (config.warnHandler) {
        config.warnHandler.call(null, msg, vm, trace);
      } else if (hasConsole && (!config.silent)) {
        console.error(("[Vue warn]: " + msg + trace));
      }
    };

    tip = function (msg, vm) {
      if (hasConsole && (!config.silent)) {
        console.warn("[Vue tip]: " + msg + (
          vm ? generateComponentTrace(vm) : ''
        ));
      }
    };

    formatComponentName = function (vm, includeFile) {
      if (vm.$root === vm) {
        return '<Root>'
      }
      var options = typeof vm === 'function' && vm.cid != null
        ? vm.options
        : vm._isVue
          ? vm.$options || vm.constructor.options
          : vm;
      var name = options.name || options._componentTag;
      var file = options.__file;
      if (!name && file) {
        var match = file.match(/([^/\\]+)\.vue$/);
        name = match && match[1];
      }

      return (
        (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
        (file && includeFile !== false ? (" at " + file) : '')
      )
    };

    var repeat = function (str, n) {
      var res = '';
      while (n) {
        if (n % 2 === 1) { res += str; }
        if (n > 1) { str += str; }
        n >>= 1;
      }
      return res
    };

    generateComponentTrace = function (vm) {
      if (vm._isVue && vm.$parent) {
        var tree = [];
        var currentRecursiveSequence = 0;
        while (vm) {
          if (tree.length > 0) {
            var last = tree[tree.length - 1];
            if (last.constructor === vm.constructor) {
              currentRecursiveSequence++;
              vm = vm.$parent;
              continue
            } else if (currentRecursiveSequence > 0) {
              tree[tree.length - 1] = [last, currentRecursiveSequence];
              currentRecursiveSequence = 0;
            }
          }
          tree.push(vm);
          vm = vm.$parent;
        }
        return '\n\nfound in\n\n' + tree
          .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
              ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
              : formatComponentName(vm))); })
          .join('\n')
      } else {
        return ("\n\n(found in " + (formatComponentName(vm)) + ")")
      }
    };
  }

  /*  */

  var uid = 0;

  /**
   * A dep is an observable that can have multiple
   * directives subscribing to it.
   */
  var Dep = function Dep () {
    this.id = uid++;
    this.subs = [];
  };

  Dep.prototype.addSub = function addSub (sub) {
    this.subs.push(sub);
  };

  Dep.prototype.removeSub = function removeSub (sub) {
    remove(this.subs, sub);
  };

  Dep.prototype.depend = function depend () {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };

  Dep.prototype.notify = function notify () {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    if (!config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort(function (a, b) { return a.id - b.id; });
    }
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };

  // The current target watcher being evaluated.
  // This is globally unique because only one watcher
  // can be evaluated at a time.
  Dep.target = null;
  var targetStack = [];

  function pushTarget (target) {
    targetStack.push(target);
    Dep.target = target;
  }

  function popTarget () {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
  }

  /*  */

  var VNode = function VNode (
    tag,
    data,
    children,
    text,
    elm,
    context,
    componentOptions,
    asyncFactory
  ) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = undefined;
    this.context = context;
    this.fnContext = undefined;
    this.fnOptions = undefined;
    this.fnScopeId = undefined;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = undefined;
    this.parent = undefined;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
  };

  var prototypeAccessors = { child: { configurable: true } };

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  prototypeAccessors.child.get = function () {
    return this.componentInstance
  };

  Object.defineProperties( VNode.prototype, prototypeAccessors );

  var createEmptyVNode = function (text) {
    if ( text === void 0 ) text = '';

    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node
  };

  function createTextVNode (val) {
    return new VNode(undefined, undefined, undefined, String(val))
  }

  // optimized shallow clone
  // used for static nodes and slot nodes because they may be reused across
  // multiple renders, cloning them avoids errors when DOM manipulations rely
  // on their elm reference.
  function cloneVNode (vnode) {
    var cloned = new VNode(
      vnode.tag,
      vnode.data,
      // #7975
      // clone children array to avoid mutating original in case of cloning
      // a child.
      vnode.children && vnode.children.slice(),
      vnode.text,
      vnode.elm,
      vnode.context,
      vnode.componentOptions,
      vnode.asyncFactory
    );
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned
  }

  /*
   * not type checking this file because flow doesn't play well with
   * dynamically accessing methods on Array prototype
   */

  var arrayProto = Array.prototype;
  var arrayMethods = Object.create(arrayProto);

  var methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
  ];

  /**
   * Intercept mutating methods and emit events
   */
  methodsToPatch.forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break
        case 'splice':
          inserted = args.slice(2);
          break
      }
      if (inserted) { ob.observeArray(inserted); }
      // notify change
      ob.dep.notify();
      return result
    });
  });

  /*  */

  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

  /**
   * In some cases we may want to disable observation inside a component's
   * update computation.
   */
  var shouldObserve = true;

  function toggleObserving (value) {
    shouldObserve = value;
  }

  /**
   * Observer class that is attached to each observed
   * object. Once attached, the observer converts the target
   * object's property keys into getter/setters that
   * collect dependencies and dispatch updates.
   */
  var Observer = function Observer (value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods);
      } else {
        copyAugment(value, arrayMethods, arrayKeys);
      }
      this.observeArray(value);
    } else {
      this.walk(value);
    }
  };

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  Observer.prototype.walk = function walk (obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
      defineReactive$$1(obj, keys[i]);
    }
  };

  /**
   * Observe a list of Array items.
   */
  Observer.prototype.observeArray = function observeArray (items) {
    for (var i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  };

  // helpers

  /**
   * Augment a target Object or Array by intercepting
   * the prototype chain using __proto__
   */
  function protoAugment (target, src) {
    /* eslint-disable no-proto */
    target.__proto__ = src;
    /* eslint-enable no-proto */
  }

  /**
   * Augment a target Object or Array by defining
   * hidden properties.
   */
  /* istanbul ignore next */
  function copyAugment (target, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      def(target, key, src[key]);
    }
  }

  /**
   * Attempt to create an observer instance for a value,
   * returns the new observer if successfully observed,
   * or the existing observer if the value already has one.
   */
  function observe (value, asRootData) {
    if (!isObject(value) || value instanceof VNode) {
      return
    }
    var ob;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (
      shouldObserve &&
      !isServerRendering() &&
      (Array.isArray(value) || isPlainObject(value)) &&
      Object.isExtensible(value) &&
      !value._isVue
    ) {
      ob = new Observer(value);
    }
    if (asRootData && ob) {
      ob.vmCount++;
    }
    return ob
  }

  /**
   * Define a reactive property on an Object.
   */
  function defineReactive$$1 (
    obj,
    key,
    val,
    customSetter,
    shallow
  ) {
    var dep = new Dep();

    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return
    }

    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
      val = obj[key];
    }

    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter () {
        var value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value
      },
      set: function reactiveSetter (newVal) {
        var value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */
        if (newVal === value || (newVal !== newVal && value !== value)) {
          return
        }
        /* eslint-enable no-self-compare */
        if (customSetter) {
          customSetter();
        }
        // #7981: for accessor properties without setter
        if (getter && !setter) { return }
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        childOb = !shallow && observe(newVal);
        dep.notify();
      }
    });
  }

  /**
   * Set a property on an object. Adds the new property and
   * triggers change notification if the property doesn't
   * already exist.
   */
  function set (target, key, val) {
    if (isUndef(target) || isPrimitive(target)
    ) {
      warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val
    }
    if (key in target && !(key in Object.prototype)) {
      target[key] = val;
      return val
    }
    var ob = (target).__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
      warn(
        'Avoid adding reactive properties to a Vue instance or its root $data ' +
        'at runtime - declare it upfront in the data option.'
      );
      return val
    }
    if (!ob) {
      target[key] = val;
      return val
    }
    defineReactive$$1(ob.value, key, val);
    ob.dep.notify();
    return val
  }

  /**
   * Delete a property and trigger change if necessary.
   */
  function del (target, key) {
    if (isUndef(target) || isPrimitive(target)
    ) {
      warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
    }
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.splice(key, 1);
      return
    }
    var ob = (target).__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
      warn(
        'Avoid deleting properties on a Vue instance or its root $data ' +
        '- just set it to null.'
      );
      return
    }
    if (!hasOwn(target, key)) {
      return
    }
    delete target[key];
    if (!ob) {
      return
    }
    ob.dep.notify();
  }

  /**
   * Collect dependencies on array elements when the array is touched, since
   * we cannot intercept array element access like property getters.
   */
  function dependArray (value) {
    for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
      e = value[i];
      e && e.__ob__ && e.__ob__.dep.depend();
      if (Array.isArray(e)) {
        dependArray(e);
      }
    }
  }

  /*  */

  /**
   * Option overwriting strategies are functions that handle
   * how to merge a parent option value and a child option
   * value into the final value.
   */
  var strats = config.optionMergeStrategies;

  /**
   * Options with restrictions
   */
  {
    strats.el = strats.propsData = function (parent, child, vm, key) {
      if (!vm) {
        warn(
          "option \"" + key + "\" can only be used during instance " +
          'creation with the `new` keyword.'
        );
      }
      return defaultStrat(parent, child)
    };
  }

  /**
   * Helper that recursively merges two data objects together.
   */
  function mergeData (to, from) {
    if (!from) { return to }
    var key, toVal, fromVal;

    var keys = hasSymbol
      ? Reflect.ownKeys(from)
      : Object.keys(from);

    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      // in case the object is already observed...
      if (key === '__ob__') { continue }
      toVal = to[key];
      fromVal = from[key];
      if (!hasOwn(to, key)) {
        set(to, key, fromVal);
      } else if (
        toVal !== fromVal &&
        isPlainObject(toVal) &&
        isPlainObject(fromVal)
      ) {
        mergeData(toVal, fromVal);
      }
    }
    return to
  }

  /**
   * Data
   */
  function mergeDataOrFn (
    parentVal,
    childVal,
    vm
  ) {
    if (!vm) {
      // in a Vue.extend merge, both should be functions
      if (!childVal) {
        return parentVal
      }
      if (!parentVal) {
        return childVal
      }
      // when parentVal & childVal are both present,
      // we need to return a function that returns the
      // merged result of both functions... no need to
      // check if parentVal is a function here because
      // it has to be a function to pass previous merges.
      return function mergedDataFn () {
        return mergeData(
          typeof childVal === 'function' ? childVal.call(this, this) : childVal,
          typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
        )
      }
    } else {
      return function mergedInstanceDataFn () {
        // instance merge
        var instanceData = typeof childVal === 'function'
          ? childVal.call(vm, vm)
          : childVal;
        var defaultData = typeof parentVal === 'function'
          ? parentVal.call(vm, vm)
          : parentVal;
        if (instanceData) {
          return mergeData(instanceData, defaultData)
        } else {
          return defaultData
        }
      }
    }
  }

  strats.data = function (
    parentVal,
    childVal,
    vm
  ) {
    if (!vm) {
      if (childVal && typeof childVal !== 'function') {
        warn(
          'The "data" option should be a function ' +
          'that returns a per-instance value in component ' +
          'definitions.',
          vm
        );

        return parentVal
      }
      return mergeDataOrFn(parentVal, childVal)
    }

    return mergeDataOrFn(parentVal, childVal, vm)
  };

  /**
   * Hooks and props are merged as arrays.
   */
  function mergeHook (
    parentVal,
    childVal
  ) {
    var res = childVal
      ? parentVal
        ? parentVal.concat(childVal)
        : Array.isArray(childVal)
          ? childVal
          : [childVal]
      : parentVal;
    return res
      ? dedupeHooks(res)
      : res
  }

  function dedupeHooks (hooks) {
    var res = [];
    for (var i = 0; i < hooks.length; i++) {
      if (res.indexOf(hooks[i]) === -1) {
        res.push(hooks[i]);
      }
    }
    return res
  }

  LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeHook;
  });

  /**
   * Assets
   *
   * When a vm is present (instance creation), we need to do
   * a three-way merge between constructor options, instance
   * options and parent options.
   */
  function mergeAssets (
    parentVal,
    childVal,
    vm,
    key
  ) {
    var res = Object.create(parentVal || null);
    if (childVal) {
      assertObjectType(key, childVal, vm);
      return extend(res, childVal)
    } else {
      return res
    }
  }

  ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
  });

  /**
   * Watchers.
   *
   * Watchers hashes should not overwrite one
   * another, so we merge them as arrays.
   */
  strats.watch = function (
    parentVal,
    childVal,
    vm,
    key
  ) {
    // work around Firefox's Object.prototype.watch...
    if (parentVal === nativeWatch) { parentVal = undefined; }
    if (childVal === nativeWatch) { childVal = undefined; }
    /* istanbul ignore if */
    if (!childVal) { return Object.create(parentVal || null) }
    {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) { return childVal }
    var ret = {};
    extend(ret, parentVal);
    for (var key$1 in childVal) {
      var parent = ret[key$1];
      var child = childVal[key$1];
      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }
      ret[key$1] = parent
        ? parent.concat(child)
        : Array.isArray(child) ? child : [child];
    }
    return ret
  };

  /**
   * Other object hashes.
   */
  strats.props =
  strats.methods =
  strats.inject =
  strats.computed = function (
    parentVal,
    childVal,
    vm,
    key
  ) {
    if (childVal && "development" !== 'production') {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) { return childVal }
    var ret = Object.create(null);
    extend(ret, parentVal);
    if (childVal) { extend(ret, childVal); }
    return ret
  };
  strats.provide = mergeDataOrFn;

  /**
   * Default strategy.
   */
  var defaultStrat = function (parentVal, childVal) {
    return childVal === undefined
      ? parentVal
      : childVal
  };

  /**
   * Validate component names
   */
  function checkComponents (options) {
    for (var key in options.components) {
      validateComponentName(key);
    }
  }

  function validateComponentName (name) {
    if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
      warn(
        'Invalid component name: "' + name + '". Component names ' +
        'should conform to valid custom element name in html5 specification.'
      );
    }
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
      warn(
        'Do not use built-in or reserved HTML elements as component ' +
        'id: ' + name
      );
    }
  }

  /**
   * Ensure all props option syntax are normalized into the
   * Object-based format.
   */
  function normalizeProps (options, vm) {
    var props = options.props;
    if (!props) { return }
    var res = {};
    var i, val, name;
    if (Array.isArray(props)) {
      i = props.length;
      while (i--) {
        val = props[i];
        if (typeof val === 'string') {
          name = camelize(val);
          res[name] = { type: null };
        } else {
          warn('props must be strings when using array syntax.');
        }
      }
    } else if (isPlainObject(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);
        res[name] = isPlainObject(val)
          ? val
          : { type: val };
      }
    } else {
      warn(
        "Invalid value for option \"props\": expected an Array or an Object, " +
        "but got " + (toRawType(props)) + ".",
        vm
      );
    }
    options.props = res;
  }

  /**
   * Normalize all injections into Object-based format
   */
  function normalizeInject (options, vm) {
    var inject = options.inject;
    if (!inject) { return }
    var normalized = options.inject = {};
    if (Array.isArray(inject)) {
      for (var i = 0; i < inject.length; i++) {
        normalized[inject[i]] = { from: inject[i] };
      }
    } else if (isPlainObject(inject)) {
      for (var key in inject) {
        var val = inject[key];
        normalized[key] = isPlainObject(val)
          ? extend({ from: key }, val)
          : { from: val };
      }
    } else {
      warn(
        "Invalid value for option \"inject\": expected an Array or an Object, " +
        "but got " + (toRawType(inject)) + ".",
        vm
      );
    }
  }

  /**
   * Normalize raw function directives into object format.
   */
  function normalizeDirectives (options) {
    var dirs = options.directives;
    if (dirs) {
      for (var key in dirs) {
        var def$$1 = dirs[key];
        if (typeof def$$1 === 'function') {
          dirs[key] = { bind: def$$1, update: def$$1 };
        }
      }
    }
  }

  function assertObjectType (name, value, vm) {
    if (!isPlainObject(value)) {
      warn(
        "Invalid value for option \"" + name + "\": expected an Object, " +
        "but got " + (toRawType(value)) + ".",
        vm
      );
    }
  }

  /**
   * Merge two option objects into a new one.
   * Core utility used in both instantiation and inheritance.
   */
  function mergeOptions (
    parent,
    child,
    vm
  ) {
    {
      checkComponents(child);
    }

    if (typeof child === 'function') {
      child = child.options;
    }

    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives(child);

    // Apply extends and mixins on the child options,
    // but only if it is a raw options object that isn't
    // the result of another mergeOptions call.
    // Only merged options has the _base property.
    if (!child._base) {
      if (child.extends) {
        parent = mergeOptions(parent, child.extends, vm);
      }
      if (child.mixins) {
        for (var i = 0, l = child.mixins.length; i < l; i++) {
          parent = mergeOptions(parent, child.mixins[i], vm);
        }
      }
    }

    var options = {};
    var key;
    for (key in parent) {
      mergeField(key);
    }
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    function mergeField (key) {
      var strat = strats[key] || defaultStrat;
      options[key] = strat(parent[key], child[key], vm, key);
    }
    return options
  }

  /**
   * Resolve an asset.
   * This function is used because child instances need access
   * to assets defined in its ancestor chain.
   */
  function resolveAsset (
    options,
    type,
    id,
    warnMissing
  ) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
      return
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id)) { return assets[id] }
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if (warnMissing && !res) {
      warn(
        'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
        options
      );
    }
    return res
  }

  /*  */



  function validateProp (
    key,
    propOptions,
    propsData,
    vm
  ) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // boolean casting
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
      if (absent && !hasOwn(prop, 'default')) {
        value = false;
      } else if (value === '' || value === hyphenate(key)) {
        // only cast empty string / same name to boolean if
        // boolean has higher priority
        var stringIndex = getTypeIndex(String, prop.type);
        if (stringIndex < 0 || booleanIndex < stringIndex) {
          value = true;
        }
      }
    }
    // check default value
    if (value === undefined) {
      value = getPropDefaultValue(vm, prop, key);
      // since the default value is a fresh copy,
      // make sure to observe it.
      var prevShouldObserve = shouldObserve;
      toggleObserving(true);
      observe(value);
      toggleObserving(prevShouldObserve);
    }
    {
      assertProp(prop, key, value, vm, absent);
    }
    return value
  }

  /**
   * Get the default value of a prop.
   */
  function getPropDefaultValue (vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
      return undefined
    }
    var def = prop.default;
    // warn against non-factory defaults for Object & Array
    if (isObject(def)) {
      warn(
        'Invalid default value for prop "' + key + '": ' +
        'Props with type Object/Array must use a factory function ' +
        'to return the default value.',
        vm
      );
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm && vm.$options.propsData &&
      vm.$options.propsData[key] === undefined &&
      vm._props[key] !== undefined
    ) {
      return vm._props[key]
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return typeof def === 'function' && getType(prop.type) !== 'Function'
      ? def.call(vm)
      : def
  }

  /**
   * Assert whether a prop is valid.
   */
  function assertProp (
    prop,
    name,
    value,
    vm,
    absent
  ) {
    if (prop.required && absent) {
      warn(
        'Missing required prop: "' + name + '"',
        vm
      );
      return
    }
    if (value == null && !prop.required) {
      return
    }
    var type = prop.type;
    var valid = !type || type === true;
    var expectedTypes = [];
    if (type) {
      if (!Array.isArray(type)) {
        type = [type];
      }
      for (var i = 0; i < type.length && !valid; i++) {
        var assertedType = assertType(value, type[i], vm);
        expectedTypes.push(assertedType.expectedType || '');
        valid = assertedType.valid;
      }
    }

    var haveExpectedTypes = expectedTypes.some(function (t) { return t; });
    if (!valid && haveExpectedTypes) {
      warn(
        getInvalidTypeMessage(name, value, expectedTypes),
        vm
      );
      return
    }
    var validator = prop.validator;
    if (validator) {
      if (!validator(value)) {
        warn(
          'Invalid prop: custom validator check failed for prop "' + name + '".',
          vm
        );
      }
    }
  }

  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;

  function assertType (value, type, vm) {
    var valid;
    var expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
      var t = typeof value;
      valid = t === expectedType.toLowerCase();
      // for primitive wrapper objects
      if (!valid && t === 'object') {
        valid = value instanceof type;
      }
    } else if (expectedType === 'Object') {
      valid = isPlainObject(value);
    } else if (expectedType === 'Array') {
      valid = Array.isArray(value);
    } else {
      try {
        valid = value instanceof type;
      } catch (e) {
        warn('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
        valid = false;
      }
    }
    return {
      valid: valid,
      expectedType: expectedType
    }
  }

  var functionTypeCheckRE = /^\s*function (\w+)/;

  /**
   * Use function string name to check built-in types,
   * because a simple equality check will fail when running
   * across different vms / iframes.
   */
  function getType (fn) {
    var match = fn && fn.toString().match(functionTypeCheckRE);
    return match ? match[1] : ''
  }

  function isSameType (a, b) {
    return getType(a) === getType(b)
  }

  function getTypeIndex (type, expectedTypes) {
    if (!Array.isArray(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
      if (isSameType(expectedTypes[i], type)) {
        return i
      }
    }
    return -1
  }

  function getInvalidTypeMessage (name, value, expectedTypes) {
    var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
      " Expected " + (expectedTypes.map(capitalize).join(', '));
    var expectedType = expectedTypes[0];
    var receivedType = toRawType(value);
    // check if we need to specify expected value
    if (
      expectedTypes.length === 1 &&
      isExplicable(expectedType) &&
      isExplicable(typeof value) &&
      !isBoolean(expectedType, receivedType)
    ) {
      message += " with value " + (styleValue(value, expectedType));
    }
    message += ", got " + receivedType + " ";
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
      message += "with value " + (styleValue(value, receivedType)) + ".";
    }
    return message
  }

  function styleValue (value, type) {
    if (type === 'String') {
      return ("\"" + value + "\"")
    } else if (type === 'Number') {
      return ("" + (Number(value)))
    } else {
      return ("" + value)
    }
  }

  var EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
  function isExplicable (value) {
    return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; })
  }

  function isBoolean () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
  }

  /*  */

  function handleError (err, vm, info) {
    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
    // See: https://github.com/vuejs/vuex/issues/1505
    pushTarget();
    try {
      if (vm) {
        var cur = vm;
        while ((cur = cur.$parent)) {
          var hooks = cur.$options.errorCaptured;
          if (hooks) {
            for (var i = 0; i < hooks.length; i++) {
              try {
                var capture = hooks[i].call(cur, err, vm, info) === false;
                if (capture) { return }
              } catch (e) {
                globalHandleError(e, cur, 'errorCaptured hook');
              }
            }
          }
        }
      }
      globalHandleError(err, vm, info);
    } finally {
      popTarget();
    }
  }

  function invokeWithErrorHandling (
    handler,
    context,
    args,
    vm,
    info
  ) {
    var res;
    try {
      res = args ? handler.apply(context, args) : handler.call(context);
      if (res && !res._isVue && isPromise(res) && !res._handled) {
        res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
        // issue #9511
        // avoid catch triggering multiple times when nested calls
        res._handled = true;
      }
    } catch (e) {
      handleError(e, vm, info);
    }
    return res
  }

  function globalHandleError (err, vm, info) {
    if (config.errorHandler) {
      try {
        return config.errorHandler.call(null, err, vm, info)
      } catch (e) {
        // if the user intentionally throws the original error in the handler,
        // do not log it twice
        if (e !== err) {
          logError(e, null, 'config.errorHandler');
        }
      }
    }
    logError(err, vm, info);
  }

  function logError (err, vm, info) {
    {
      warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
    }
    /* istanbul ignore else */
    if ((inBrowser || inWeex) && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err
    }
  }

  /*  */

  var isUsingMicroTask = false;

  var callbacks = [];
  var pending = false;

  function flushCallbacks () {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // Here we have async deferring wrappers using microtasks.
  // In 2.5 we used (macro) tasks (in combination with microtasks).
  // However, it has subtle problems when state is changed right before repaint
  // (e.g. #6813, out-in transitions).
  // Also, using (macro) tasks in event handler would cause some weird behaviors
  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
  // So we now use microtasks everywhere, again.
  // A major drawback of this tradeoff is that there are some scenarios
  // where microtasks have too high a priority and fire in between supposedly
  // sequential events (e.g. #4521, #6690, which have workarounds)
  // or even between bubbling of the same event (#6566).
  var timerFunc;

  // The nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore next, $flow-disable-line */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    timerFunc = function () {
      p.then(flushCallbacks);
      // In problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) { setTimeout(noop); }
    };
    isUsingMicroTask = true;
  } else if (!isIE && typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
  )) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    var counter = 1;
    var observer = new MutationObserver(flushCallbacks);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
      characterData: true
    });
    timerFunc = function () {
      counter = (counter + 1) % 2;
      textNode.data = String(counter);
    };
    isUsingMicroTask = true;
  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Technically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = function () {
      setImmediate(flushCallbacks);
    };
  } else {
    // Fallback to setTimeout.
    timerFunc = function () {
      setTimeout(flushCallbacks, 0);
    };
  }

  function nextTick (cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      timerFunc();
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      })
    }
  }

  /*  */

  var mark;
  var measure;

  {
    var perf = inBrowser && window.performance;
    /* istanbul ignore if */
    if (
      perf &&
      perf.mark &&
      perf.measure &&
      perf.clearMarks &&
      perf.clearMeasures
    ) {
      mark = function (tag) { return perf.mark(tag); };
      measure = function (name, startTag, endTag) {
        perf.measure(name, startTag, endTag);
        perf.clearMarks(startTag);
        perf.clearMarks(endTag);
        // perf.clearMeasures(name)
      };
    }
  }

  /* not type checking this file because flow doesn't play well with Proxy */

  var initProxy;

  {
    var allowedGlobals = makeMap(
      'Infinity,undefined,NaN,isFinite,isNaN,' +
      'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
      'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
      'require' // for Webpack/Browserify
    );

    var warnNonPresent = function (target, key) {
      warn(
        "Property or method \"" + key + "\" is not defined on the instance but " +
        'referenced during render. Make sure that this property is reactive, ' +
        'either in the data option, or for class-based components, by ' +
        'initializing the property. ' +
        'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
        target
      );
    };

    var warnReservedPrefix = function (target, key) {
      warn(
        "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
        'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
        'prevent conflicts with Vue internals. ' +
        'See: https://vuejs.org/v2/api/#data',
        target
      );
    };

    var hasProxy =
      typeof Proxy !== 'undefined' && isNative(Proxy);

    if (hasProxy) {
      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
      config.keyCodes = new Proxy(config.keyCodes, {
        set: function set (target, key, value) {
          if (isBuiltInModifier(key)) {
            warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
            return false
          } else {
            target[key] = value;
            return true
          }
        }
      });
    }

    var hasHandler = {
      has: function has (target, key) {
        var has = key in target;
        var isAllowed = allowedGlobals(key) ||
          (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
        if (!has && !isAllowed) {
          if (key in target.$data) { warnReservedPrefix(target, key); }
          else { warnNonPresent(target, key); }
        }
        return has || !isAllowed
      }
    };

    var getHandler = {
      get: function get (target, key) {
        if (typeof key === 'string' && !(key in target)) {
          if (key in target.$data) { warnReservedPrefix(target, key); }
          else { warnNonPresent(target, key); }
        }
        return target[key]
      }
    };

    initProxy = function initProxy (vm) {
      if (hasProxy) {
        // determine which proxy handler to use
        var options = vm.$options;
        var handlers = options.render && options.render._withStripped
          ? getHandler
          : hasHandler;
        vm._renderProxy = new Proxy(vm, handlers);
      } else {
        vm._renderProxy = vm;
      }
    };
  }

  /*  */

  var seenObjects = new _Set();

  /**
   * Recursively traverse an object to evoke all converted
   * getters, so that every nested property inside the object
   * is collected as a "deep" dependency.
   */
  function traverse (val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
  }

  function _traverse (val, seen) {
    var i, keys;
    var isA = Array.isArray(val);
    if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
      return
    }
    if (val.__ob__) {
      var depId = val.__ob__.dep.id;
      if (seen.has(depId)) {
        return
      }
      seen.add(depId);
    }
    if (isA) {
      i = val.length;
      while (i--) { _traverse(val[i], seen); }
    } else {
      keys = Object.keys(val);
      i = keys.length;
      while (i--) { _traverse(val[keys[i]], seen); }
    }
  }

  /*  */

  var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once$$1 ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
      name: name,
      once: once$$1,
      capture: capture,
      passive: passive
    }
  });

  function createFnInvoker (fns, vm) {
    function invoker () {
      var arguments$1 = arguments;

      var fns = invoker.fns;
      if (Array.isArray(fns)) {
        var cloned = fns.slice();
        for (var i = 0; i < cloned.length; i++) {
          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
        }
      } else {
        // return handler return value for single handlers
        return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
      }
    }
    invoker.fns = fns;
    return invoker
  }

  function updateListeners (
    on,
    oldOn,
    add,
    remove$$1,
    createOnceHandler,
    vm
  ) {
    var name, def$$1, cur, old, event;
    for (name in on) {
      def$$1 = cur = on[name];
      old = oldOn[name];
      event = normalizeEvent(name);
      if (isUndef(cur)) {
        warn(
          "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
          vm
        );
      } else if (isUndef(old)) {
        if (isUndef(cur.fns)) {
          cur = on[name] = createFnInvoker(cur, vm);
        }
        if (isTrue(event.once)) {
          cur = on[name] = createOnceHandler(event.name, cur, event.capture);
        }
        add(event.name, cur, event.capture, event.passive, event.params);
      } else if (cur !== old) {
        old.fns = cur;
        on[name] = old;
      }
    }
    for (name in oldOn) {
      if (isUndef(on[name])) {
        event = normalizeEvent(name);
        remove$$1(event.name, oldOn[name], event.capture);
      }
    }
  }

  /*  */

  function mergeVNodeHook (def, hookKey, hook) {
    if (def instanceof VNode) {
      def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];

    function wrappedHook () {
      hook.apply(this, arguments);
      // important: remove merged hook to ensure it's called only once
      // and prevent memory leak
      remove(invoker.fns, wrappedHook);
    }

    if (isUndef(oldHook)) {
      // no existing hook
      invoker = createFnInvoker([wrappedHook]);
    } else {
      /* istanbul ignore if */
      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
        // already a merged invoker
        invoker = oldHook;
        invoker.fns.push(wrappedHook);
      } else {
        // existing plain hook
        invoker = createFnInvoker([oldHook, wrappedHook]);
      }
    }

    invoker.merged = true;
    def[hookKey] = invoker;
  }

  /*  */

  function extractPropsFromVNodeData (
    data,
    Ctor,
    tag
  ) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
      return
    }
    var res = {};
    var attrs = data.attrs;
    var props = data.props;
    if (isDef(attrs) || isDef(props)) {
      for (var key in propOptions) {
        var altKey = hyphenate(key);
        {
          var keyInLowerCase = key.toLowerCase();
          if (
            key !== keyInLowerCase &&
            attrs && hasOwn(attrs, keyInLowerCase)
          ) {
            tip(
              "Prop \"" + keyInLowerCase + "\" is passed to component " +
              (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
              " \"" + key + "\". " +
              "Note that HTML attributes are case-insensitive and camelCased " +
              "props need to use their kebab-case equivalents when using in-DOM " +
              "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
            );
          }
        }
        checkProp(res, props, key, altKey, true) ||
        checkProp(res, attrs, key, altKey, false);
      }
    }
    return res
  }

  function checkProp (
    res,
    hash,
    key,
    altKey,
    preserve
  ) {
    if (isDef(hash)) {
      if (hasOwn(hash, key)) {
        res[key] = hash[key];
        if (!preserve) {
          delete hash[key];
        }
        return true
      } else if (hasOwn(hash, altKey)) {
        res[key] = hash[altKey];
        if (!preserve) {
          delete hash[altKey];
        }
        return true
      }
    }
    return false
  }

  /*  */

  // The template compiler attempts to minimize the need for normalization by
  // statically analyzing the template at compile time.
  //
  // For plain HTML markup, normalization can be completely skipped because the
  // generated render function is guaranteed to return Array<VNode>. There are
  // two cases where extra normalization is needed:

  // 1. When the children contains components - because a functional component
  // may return an Array instead of a single root. In this case, just a simple
  // normalization is needed - if any child is an Array, we flatten the whole
  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
  // because functional components already normalize their own children.
  function simpleNormalizeChildren (children) {
    for (var i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children)
      }
    }
    return children
  }

  // 2. When the children contains constructs that always generated nested Arrays,
  // e.g. <template>, <slot>, v-for, or when the children is provided by user
  // with hand-written render functions / JSX. In such cases a full normalization
  // is needed to cater to all possible types of children values.
  function normalizeChildren (children) {
    return isPrimitive(children)
      ? [createTextVNode(children)]
      : Array.isArray(children)
        ? normalizeArrayChildren(children)
        : undefined
  }

  function isTextNode (node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment)
  }

  function normalizeArrayChildren (children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
      c = children[i];
      if (isUndef(c) || typeof c === 'boolean') { continue }
      lastIndex = res.length - 1;
      last = res[lastIndex];
      //  nested
      if (Array.isArray(c)) {
        if (c.length > 0) {
          c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
          // merge adjacent text nodes
          if (isTextNode(c[0]) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + (c[0]).text);
            c.shift();
          }
          res.push.apply(res, c);
        }
      } else if (isPrimitive(c)) {
        if (isTextNode(last)) {
          // merge adjacent text nodes
          // this is necessary for SSR hydration because text nodes are
          // essentially merged when rendered to HTML strings
          res[lastIndex] = createTextVNode(last.text + c);
        } else if (c !== '') {
          // convert primitive to vnode
          res.push(createTextVNode(c));
        }
      } else {
        if (isTextNode(c) && isTextNode(last)) {
          // merge adjacent text nodes
          res[lastIndex] = createTextVNode(last.text + c.text);
        } else {
          // default key for nested array children (likely generated by v-for)
          if (isTrue(children._isVList) &&
            isDef(c.tag) &&
            isUndef(c.key) &&
            isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }
          res.push(c);
        }
      }
    }
    return res
  }

  /*  */

  function initProvide (vm) {
    var provide = vm.$options.provide;
    if (provide) {
      vm._provided = typeof provide === 'function'
        ? provide.call(vm)
        : provide;
    }
  }

  function initInjections (vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
      toggleObserving(false);
      Object.keys(result).forEach(function (key) {
        /* istanbul ignore else */
        {
          defineReactive$$1(vm, key, result[key], function () {
            warn(
              "Avoid mutating an injected value directly since the changes will be " +
              "overwritten whenever the provided component re-renders. " +
              "injection being mutated: \"" + key + "\"",
              vm
            );
          });
        }
      });
      toggleObserving(true);
    }
  }

  function resolveInject (inject, vm) {
    if (inject) {
      // inject is :any because flow is not smart enough to figure out cached
      var result = Object.create(null);
      var keys = hasSymbol
        ? Reflect.ownKeys(inject)
        : Object.keys(inject);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        // #6574 in case the inject object is observed...
        if (key === '__ob__') { continue }
        var provideKey = inject[key].from;
        var source = vm;
        while (source) {
          if (source._provided && hasOwn(source._provided, provideKey)) {
            result[key] = source._provided[provideKey];
            break
          }
          source = source.$parent;
        }
        if (!source) {
          if ('default' in inject[key]) {
            var provideDefault = inject[key].default;
            result[key] = typeof provideDefault === 'function'
              ? provideDefault.call(vm)
              : provideDefault;
          } else {
            warn(("Injection \"" + key + "\" not found"), vm);
          }
        }
      }
      return result
    }
  }

  /*  */



  /**
   * Runtime helper for resolving raw children VNodes into a slot object.
   */
  function resolveSlots (
    children,
    context
  ) {
    if (!children || !children.length) {
      return {}
    }
    var slots = {};
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      var data = child.data;
      // remove slot attribute if the node is resolved as a Vue slot node
      if (data && data.attrs && data.attrs.slot) {
        delete data.attrs.slot;
      }
      // named slots should only be respected if the vnode was rendered in the
      // same context.
      if ((child.context === context || child.fnContext === context) &&
        data && data.slot != null
      ) {
        var name = data.slot;
        var slot = (slots[name] || (slots[name] = []));
        if (child.tag === 'template') {
          slot.push.apply(slot, child.children || []);
        } else {
          slot.push(child);
        }
      } else {
        (slots.default || (slots.default = [])).push(child);
      }
    }
    // ignore slots that contains only whitespace
    for (var name$1 in slots) {
      if (slots[name$1].every(isWhitespace)) {
        delete slots[name$1];
      }
    }
    return slots
  }

  function isWhitespace (node) {
    return (node.isComment && !node.asyncFactory) || node.text === ' '
  }

  /*  */

  function isAsyncPlaceholder (node) {
    return node.isComment && node.asyncFactory
  }

  /*  */

  function normalizeScopedSlots (
    slots,
    normalSlots,
    prevSlots
  ) {
    var res;
    var hasNormalSlots = Object.keys(normalSlots).length > 0;
    var isStable = slots ? !!slots.$stable : !hasNormalSlots;
    var key = slots && slots.$key;
    if (!slots) {
      res = {};
    } else if (slots._normalized) {
      // fast path 1: child component re-render only, parent did not change
      return slots._normalized
    } else if (
      isStable &&
      prevSlots &&
      prevSlots !== emptyObject &&
      key === prevSlots.$key &&
      !hasNormalSlots &&
      !prevSlots.$hasNormal
    ) {
      // fast path 2: stable scoped slots w/ no normal slots to proxy,
      // only need to normalize once
      return prevSlots
    } else {
      res = {};
      for (var key$1 in slots) {
        if (slots[key$1] && key$1[0] !== '$') {
          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
        }
      }
    }
    // expose normal slots on scopedSlots
    for (var key$2 in normalSlots) {
      if (!(key$2 in res)) {
        res[key$2] = proxyNormalSlot(normalSlots, key$2);
      }
    }
    // avoriaz seems to mock a non-extensible $scopedSlots object
    // and when that is passed down this would cause an error
    if (slots && Object.isExtensible(slots)) {
      (slots)._normalized = res;
    }
    def(res, '$stable', isStable);
    def(res, '$key', key);
    def(res, '$hasNormal', hasNormalSlots);
    return res
  }

  function normalizeScopedSlot(normalSlots, key, fn) {
    var normalized = function () {
      var res = arguments.length ? fn.apply(null, arguments) : fn({});
      res = res && typeof res === 'object' && !Array.isArray(res)
        ? [res] // single vnode
        : normalizeChildren(res);
      var vnode = res && res[0];
      return res && (
        !vnode ||
        (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode)) // #9658, #10391
      ) ? undefined
        : res
    };
    // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.
    if (fn.proxy) {
      Object.defineProperty(normalSlots, key, {
        get: normalized,
        enumerable: true,
        configurable: true
      });
    }
    return normalized
  }

  function proxyNormalSlot(slots, key) {
    return function () { return slots[key]; }
  }

  /*  */

  /**
   * Runtime helper for rendering v-for lists.
   */
  function renderList (
    val,
    render
  ) {
    var ret, i, l, keys, key;
    if (Array.isArray(val) || typeof val === 'string') {
      ret = new Array(val.length);
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = render(val[i], i);
      }
    } else if (typeof val === 'number') {
      ret = new Array(val);
      for (i = 0; i < val; i++) {
        ret[i] = render(i + 1, i);
      }
    } else if (isObject(val)) {
      if (hasSymbol && val[Symbol.iterator]) {
        ret = [];
        var iterator = val[Symbol.iterator]();
        var result = iterator.next();
        while (!result.done) {
          ret.push(render(result.value, ret.length));
          result = iterator.next();
        }
      } else {
        keys = Object.keys(val);
        ret = new Array(keys.length);
        for (i = 0, l = keys.length; i < l; i++) {
          key = keys[i];
          ret[i] = render(val[key], key, i);
        }
      }
    }
    if (!isDef(ret)) {
      ret = [];
    }
    (ret)._isVList = true;
    return ret
  }

  /*  */

  /**
   * Runtime helper for rendering <slot>
   */
  function renderSlot (
    name,
    fallbackRender,
    props,
    bindObject
  ) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) {
      // scoped slot
      props = props || {};
      if (bindObject) {
        if (!isObject(bindObject)) {
          warn('slot v-bind without argument expects an Object', this);
        }
        props = extend(extend({}, bindObject), props);
      }
      nodes =
        scopedSlotFn(props) ||
        (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
    } else {
      nodes =
        this.$slots[name] ||
        (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender);
    }

    var target = props && props.slot;
    if (target) {
      return this.$createElement('template', { slot: target }, nodes)
    } else {
      return nodes
    }
  }

  /*  */

  /**
   * Runtime helper for resolving filters
   */
  function resolveFilter (id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity
  }

  /*  */

  function isKeyNotMatch (expect, actual) {
    if (Array.isArray(expect)) {
      return expect.indexOf(actual) === -1
    } else {
      return expect !== actual
    }
  }

  /**
   * Runtime helper for checking keyCodes from config.
   * exposed as Vue.prototype._k
   * passing in eventKeyName as last argument separately for backwards compat
   */
  function checkKeyCodes (
    eventKeyCode,
    key,
    builtInKeyCode,
    eventKeyName,
    builtInKeyName
  ) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
      return isKeyNotMatch(builtInKeyName, eventKeyName)
    } else if (mappedKeyCode) {
      return isKeyNotMatch(mappedKeyCode, eventKeyCode)
    } else if (eventKeyName) {
      return hyphenate(eventKeyName) !== key
    }
    return eventKeyCode === undefined
  }

  /*  */

  /**
   * Runtime helper for merging v-bind="object" into a VNode's data.
   */
  function bindObjectProps (
    data,
    tag,
    value,
    asProp,
    isSync
  ) {
    if (value) {
      if (!isObject(value)) {
        warn(
          'v-bind without argument expects an Object or Array value',
          this
        );
      } else {
        if (Array.isArray(value)) {
          value = toObject(value);
        }
        var hash;
        var loop = function ( key ) {
          if (
            key === 'class' ||
            key === 'style' ||
            isReservedAttribute(key)
          ) {
            hash = data;
          } else {
            var type = data.attrs && data.attrs.type;
            hash = asProp || config.mustUseProp(tag, type, key)
              ? data.domProps || (data.domProps = {})
              : data.attrs || (data.attrs = {});
          }
          var camelizedKey = camelize(key);
          var hyphenatedKey = hyphenate(key);
          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
            hash[key] = value[key];

            if (isSync) {
              var on = data.on || (data.on = {});
              on[("update:" + key)] = function ($event) {
                value[key] = $event;
              };
            }
          }
        };

        for (var key in value) loop( key );
      }
    }
    return data
  }

  /*  */

  /**
   * Runtime helper for rendering static trees.
   */
  function renderStatic (
    index,
    isInFor
  ) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
      return tree
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(
      this._renderProxy,
      null,
      this // for render fns generated for functional component templates
    );
    markStatic(tree, ("__static__" + index), false);
    return tree
  }

  /**
   * Runtime helper for v-once.
   * Effectively it means marking the node as static with a unique key.
   */
  function markOnce (
    tree,
    index,
    key
  ) {
    markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
    return tree
  }

  function markStatic (
    tree,
    key,
    isOnce
  ) {
    if (Array.isArray(tree)) {
      for (var i = 0; i < tree.length; i++) {
        if (tree[i] && typeof tree[i] !== 'string') {
          markStaticNode(tree[i], (key + "_" + i), isOnce);
        }
      }
    } else {
      markStaticNode(tree, key, isOnce);
    }
  }

  function markStaticNode (node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
  }

  /*  */

  function bindObjectListeners (data, value) {
    if (value) {
      if (!isPlainObject(value)) {
        warn(
          'v-on without argument expects an Object value',
          this
        );
      } else {
        var on = data.on = data.on ? extend({}, data.on) : {};
        for (var key in value) {
          var existing = on[key];
          var ours = value[key];
          on[key] = existing ? [].concat(existing, ours) : ours;
        }
      }
    }
    return data
  }

  /*  */

  function resolveScopedSlots (
    fns, // see flow/vnode
    res,
    // the following are added in 2.6
    hasDynamicKeys,
    contentHashKey
  ) {
    res = res || { $stable: !hasDynamicKeys };
    for (var i = 0; i < fns.length; i++) {
      var slot = fns[i];
      if (Array.isArray(slot)) {
        resolveScopedSlots(slot, res, hasDynamicKeys);
      } else if (slot) {
        // marker for reverse proxying v-slot without scope on this.$slots
        if (slot.proxy) {
          slot.fn.proxy = true;
        }
        res[slot.key] = slot.fn;
      }
    }
    if (contentHashKey) {
      (res).$key = contentHashKey;
    }
    return res
  }

  /*  */

  function bindDynamicKeys (baseObj, values) {
    for (var i = 0; i < values.length; i += 2) {
      var key = values[i];
      if (typeof key === 'string' && key) {
        baseObj[values[i]] = values[i + 1];
      } else if (key !== '' && key !== null) {
        // null is a special value for explicitly removing a binding
        warn(
          ("Invalid value for dynamic directive argument (expected string or null): " + key),
          this
        );
      }
    }
    return baseObj
  }

  // helper to dynamically append modifier runtime markers to event names.
  // ensure only append when value is already string, otherwise it will be cast
  // to string and cause the type check to miss.
  function prependModifier (value, symbol) {
    return typeof value === 'string' ? symbol + value : value
  }

  /*  */

  function installRenderHelpers (target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
  }

  /*  */

  function FunctionalRenderContext (
    data,
    props,
    children,
    parent,
    Ctor
  ) {
    var this$1 = this;

    var options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var contextVm;
    if (hasOwn(parent, '_uid')) {
      contextVm = Object.create(parent);
      // $flow-disable-line
      contextVm._original = parent;
    } else {
      // the context vm passed in is a functional context as well.
      // in this case we want to make sure we are able to get a hold to the
      // real context instance.
      contextVm = parent;
      // $flow-disable-line
      parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;

    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
      if (!this$1.$slots) {
        normalizeScopedSlots(
          data.scopedSlots,
          this$1.$slots = resolveSlots(children, parent)
        );
      }
      return this$1.$slots
    };

    Object.defineProperty(this, 'scopedSlots', ({
      enumerable: true,
      get: function get () {
        return normalizeScopedSlots(data.scopedSlots, this.slots())
      }
    }));

    // support for compiled functional template
    if (isCompiled) {
      // exposing $options for renderStatic()
      this.$options = options;
      // pre-resolve slots for renderSlot()
      this.$slots = this.slots();
      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
    }

    if (options._scopeId) {
      this._c = function (a, b, c, d) {
        var vnode = createElement(contextVm, a, b, c, d, needNormalization);
        if (vnode && !Array.isArray(vnode)) {
          vnode.fnScopeId = options._scopeId;
          vnode.fnContext = parent;
        }
        return vnode
      };
    } else {
      this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
    }
  }

  installRenderHelpers(FunctionalRenderContext.prototype);

  function createFunctionalComponent (
    Ctor,
    propsData,
    data,
    contextVm,
    children
  ) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
      for (var key in propOptions) {
        props[key] = validateProp(key, propOptions, propsData || emptyObject);
      }
    } else {
      if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
      if (isDef(data.props)) { mergeProps(props, data.props); }
    }

    var renderContext = new FunctionalRenderContext(
      data,
      props,
      children,
      contextVm,
      Ctor
    );

    var vnode = options.render.call(null, renderContext._c, renderContext);

    if (vnode instanceof VNode) {
      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
    } else if (Array.isArray(vnode)) {
      var vnodes = normalizeChildren(vnode) || [];
      var res = new Array(vnodes.length);
      for (var i = 0; i < vnodes.length; i++) {
        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
      }
      return res
    }
  }

  function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    {
      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
    }
    if (data.slot) {
      (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone
  }

  function mergeProps (to, from) {
    for (var key in from) {
      to[camelize(key)] = from[key];
    }
  }

  /*  */

  /*  */

  /*  */

  /*  */

  // inline hooks to be invoked on component VNodes during patch
  var componentVNodeHooks = {
    init: function init (vnode, hydrating) {
      if (
        vnode.componentInstance &&
        !vnode.componentInstance._isDestroyed &&
        vnode.data.keepAlive
      ) {
        // kept-alive components, treat as a patch
        var mountedNode = vnode; // work around flow
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      } else {
        var child = vnode.componentInstance = createComponentInstanceForVnode(
          vnode,
          activeInstance
        );
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      }
    },

    prepatch: function prepatch (oldVnode, vnode) {
      var options = vnode.componentOptions;
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(
        child,
        options.propsData, // updated props
        options.listeners, // updated listeners
        vnode, // new parent vnode
        options.children // new children
      );
    },

    insert: function insert (vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }
      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          // vue-router#1212
          // During updates, a kept-alive component's child components may
          // change, so directly walking the tree here may call activated hooks
          // on incorrect children. Instead we push them into a queue which will
          // be processed after the whole patch process ended.
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true /* direct */);
        }
      }
    },

    destroy: function destroy (vnode) {
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isDestroyed) {
        if (!vnode.data.keepAlive) {
          componentInstance.$destroy();
        } else {
          deactivateChildComponent(componentInstance, true /* direct */);
        }
      }
    }
  };

  var hooksToMerge = Object.keys(componentVNodeHooks);

  function createComponent (
    Ctor,
    data,
    context,
    children,
    tag
  ) {
    if (isUndef(Ctor)) {
      return
    }

    var baseCtor = context.$options._base;

    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }

    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
      {
        warn(("Invalid Component definition: " + (String(Ctor))), context);
      }
      return
    }

    // async component
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      asyncFactory = Ctor;
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
      if (Ctor === undefined) {
        // return a placeholder node for async component, which is rendered
        // as a comment node but preserves all the raw information for the node.
        // the information will be used for async server-rendering and hydration.
        return createAsyncPlaceholder(
          asyncFactory,
          data,
          context,
          children,
          tag
        )
      }
    }

    data = data || {};

    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);

    // transform component v-model data into props & events
    if (isDef(data.model)) {
      transformModel(Ctor.options, data);
    }

    // extract props
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);

    // functional component
    if (isTrue(Ctor.options.functional)) {
      return createFunctionalComponent(Ctor, propsData, data, context, children)
    }

    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;

    if (isTrue(Ctor.options.abstract)) {
      // abstract components do not keep anything
      // other than props & listeners & slot

      // work around flow
      var slot = data.slot;
      data = {};
      if (slot) {
        data.slot = slot;
      }
    }

    // install component management hooks onto the placeholder node
    installComponentHooks(data);

    // return a placeholder vnode
    var name = Ctor.options.name || tag;
    var vnode = new VNode(
      ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
      data, undefined, undefined, undefined, context,
      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
      asyncFactory
    );

    return vnode
  }

  function createComponentInstanceForVnode (
    // we know it's MountedComponentVNode but flow doesn't
    vnode,
    // activeInstance in lifecycle state
    parent
  ) {
    var options = {
      _isComponent: true,
      _parentVnode: vnode,
      parent: parent
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
      options.render = inlineTemplate.render;
      options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options)
  }

  function installComponentHooks (data) {
    var hooks = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      var existing = hooks[key];
      var toMerge = componentVNodeHooks[key];
      if (existing !== toMerge && !(existing && existing._merged)) {
        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
      }
    }
  }

  function mergeHook$1 (f1, f2) {
    var merged = function (a, b) {
      // flow complains about extra args which is why we use any
      f1(a, b);
      f2(a, b);
    };
    merged._merged = true;
    return merged
  }

  // transform component v-model info (value and callback) into
  // prop and event handler respectively.
  function transformModel (options, data) {
    var prop = (options.model && options.model.prop) || 'value';
    var event = (options.model && options.model.event) || 'input'
    ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    var existing = on[event];
    var callback = data.model.callback;
    if (isDef(existing)) {
      if (
        Array.isArray(existing)
          ? existing.indexOf(callback) === -1
          : existing !== callback
      ) {
        on[event] = [callback].concat(existing);
      }
    } else {
      on[event] = callback;
    }
  }

  /*  */

  var SIMPLE_NORMALIZE = 1;
  var ALWAYS_NORMALIZE = 2;

  // wrapper function for providing a more flexible interface
  // without getting yelled at by flow
  function createElement (
    context,
    tag,
    data,
    children,
    normalizationType,
    alwaysNormalize
  ) {
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType)
  }

  function _createElement (
    context,
    tag,
    data,
    children,
    normalizationType
  ) {
    if (isDef(data) && isDef((data).__ob__)) {
      warn(
        "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
        'Always create fresh vnode data objects in each render!',
        context
      );
      return createEmptyVNode()
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
      tag = data.is;
    }
    if (!tag) {
      // in case of component :is set to falsy value
      return createEmptyVNode()
    }
    // warn against non-primitive key
    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)
    ) {
      {
        warn(
          'Avoid using non-primitive value as key, ' +
          'use string/number value instead.',
          context
        );
      }
    }
    // support single function children as default scoped slot
    if (Array.isArray(children) &&
      typeof children[0] === 'function'
    ) {
      data = data || {};
      data.scopedSlots = { default: children[0] };
      children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
      children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
      var Ctor;
      ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
      if (config.isReservedTag(tag)) {
        // platform built-in elements
        if (isDef(data) && isDef(data.nativeOn) && data.tag !== 'component') {
          warn(
            ("The .native modifier for v-on is only valid on components but it was used on <" + tag + ">."),
            context
          );
        }
        vnode = new VNode(
          config.parsePlatformTagName(tag), data, children,
          undefined, undefined, context
        );
      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
        // component
        vnode = createComponent(Ctor, data, context, children, tag);
      } else {
        // unknown or unlisted namespaced elements
        // check at runtime because it may get assigned a namespace when its
        // parent normalizes children
        vnode = new VNode(
          tag, data, children,
          undefined, undefined, context
        );
      }
    } else {
      // direct component options / constructor
      vnode = createComponent(tag, data, context, children);
    }
    if (Array.isArray(vnode)) {
      return vnode
    } else if (isDef(vnode)) {
      if (isDef(ns)) { applyNS(vnode, ns); }
      if (isDef(data)) { registerDeepBindings(data); }
      return vnode
    } else {
      return createEmptyVNode()
    }
  }

  function applyNS (vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
      // use default namespace inside foreignObject
      ns = undefined;
      force = true;
    }
    if (isDef(vnode.children)) {
      for (var i = 0, l = vnode.children.length; i < l; i++) {
        var child = vnode.children[i];
        if (isDef(child.tag) && (
          isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
          applyNS(child, ns, force);
        }
      }
    }
  }

  // ref #5318
  // necessary to ensure parent re-render when deep bindings like :style and
  // :class are used on slot nodes
  function registerDeepBindings (data) {
    if (isObject(data.style)) {
      traverse(data.style);
    }
    if (isObject(data.class)) {
      traverse(data.class);
    }
  }

  /*  */

  function initRender (vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    var options = vm.$options;
    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;

    /* istanbul ignore else */
    {
      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
        !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
      }, true);
      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
        !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
      }, true);
    }
  }

  var currentRenderingInstance = null;

  function renderMixin (Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);

    Vue.prototype.$nextTick = function (fn) {
      return nextTick(fn, this)
    };

    Vue.prototype._render = function () {
      var vm = this;
      var ref = vm.$options;
      var render = ref.render;
      var _parentVnode = ref._parentVnode;

      if (_parentVnode) {
        vm.$scopedSlots = normalizeScopedSlots(
          _parentVnode.data.scopedSlots,
          vm.$slots,
          vm.$scopedSlots
        );
      }

      // set parent vnode. this allows render functions to have access
      // to the data on the placeholder node.
      vm.$vnode = _parentVnode;
      // render self
      var vnode;
      try {
        // There's no need to maintain a stack because all render fns are called
        // separately from one another. Nested component's render fns are called
        // when parent component is patched.
        currentRenderingInstance = vm;
        vnode = render.call(vm._renderProxy, vm.$createElement);
      } catch (e) {
        handleError(e, vm, "render");
        // return error render result,
        // or previous vnode to prevent render error causing blank component
        /* istanbul ignore else */
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } finally {
        currentRenderingInstance = null;
      }
      // if the returned array contains only a single node, allow it
      if (Array.isArray(vnode) && vnode.length === 1) {
        vnode = vnode[0];
      }
      // return empty vnode in case the render function errored out
      if (!(vnode instanceof VNode)) {
        if (Array.isArray(vnode)) {
          warn(
            'Multiple root nodes returned from render function. Render function ' +
            'should return a single root node.',
            vm
          );
        }
        vnode = createEmptyVNode();
      }
      // set parent
      vnode.parent = _parentVnode;
      return vnode
    };
  }

  /*  */

  function ensureCtor (comp, base) {
    if (
      comp.__esModule ||
      (hasSymbol && comp[Symbol.toStringTag] === 'Module')
    ) {
      comp = comp.default;
    }
    return isObject(comp)
      ? base.extend(comp)
      : comp
  }

  function createAsyncPlaceholder (
    factory,
    data,
    context,
    children,
    tag
  ) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node
  }

  function resolveAsyncComponent (
    factory,
    baseCtor
  ) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
      return factory.errorComp
    }

    if (isDef(factory.resolved)) {
      return factory.resolved
    }

    var owner = currentRenderingInstance;
    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
      // already pending
      factory.owners.push(owner);
    }

    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
      return factory.loadingComp
    }

    if (owner && !isDef(factory.owners)) {
      var owners = factory.owners = [owner];
      var sync = true;
      var timerLoading = null;
      var timerTimeout = null

      ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

      var forceRender = function (renderCompleted) {
        for (var i = 0, l = owners.length; i < l; i++) {
          (owners[i]).$forceUpdate();
        }

        if (renderCompleted) {
          owners.length = 0;
          if (timerLoading !== null) {
            clearTimeout(timerLoading);
            timerLoading = null;
          }
          if (timerTimeout !== null) {
            clearTimeout(timerTimeout);
            timerTimeout = null;
          }
        }
      };

      var resolve = once(function (res) {
        // cache resolved
        factory.resolved = ensureCtor(res, baseCtor);
        // invoke callbacks only if this is not a synchronous resolve
        // (async resolves are shimmed as synchronous during SSR)
        if (!sync) {
          forceRender(true);
        } else {
          owners.length = 0;
        }
      });

      var reject = once(function (reason) {
        warn(
          "Failed to resolve async component: " + (String(factory)) +
          (reason ? ("\nReason: " + reason) : '')
        );
        if (isDef(factory.errorComp)) {
          factory.error = true;
          forceRender(true);
        }
      });

      var res = factory(resolve, reject);

      if (isObject(res)) {
        if (isPromise(res)) {
          // () => Promise
          if (isUndef(factory.resolved)) {
            res.then(resolve, reject);
          }
        } else if (isPromise(res.component)) {
          res.component.then(resolve, reject);

          if (isDef(res.error)) {
            factory.errorComp = ensureCtor(res.error, baseCtor);
          }

          if (isDef(res.loading)) {
            factory.loadingComp = ensureCtor(res.loading, baseCtor);
            if (res.delay === 0) {
              factory.loading = true;
            } else {
              timerLoading = setTimeout(function () {
                timerLoading = null;
                if (isUndef(factory.resolved) && isUndef(factory.error)) {
                  factory.loading = true;
                  forceRender(false);
                }
              }, res.delay || 200);
            }
          }

          if (isDef(res.timeout)) {
            timerTimeout = setTimeout(function () {
              timerTimeout = null;
              if (isUndef(factory.resolved)) {
                reject(
                  "timeout (" + (res.timeout) + "ms)"
                );
              }
            }, res.timeout);
          }
        }
      }

      sync = false;
      // return in case resolved synchronously
      return factory.loading
        ? factory.loadingComp
        : factory.resolved
    }
  }

  /*  */

  function getFirstComponentChild (children) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var c = children[i];
        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
          return c
        }
      }
    }
  }

  /*  */

  /*  */

  function initEvents (vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
      updateComponentListeners(vm, listeners);
    }
  }

  var target;

  function add (event, fn) {
    target.$on(event, fn);
  }

  function remove$1 (event, fn) {
    target.$off(event, fn);
  }

  function createOnceHandler (event, fn) {
    var _target = target;
    return function onceHandler () {
      var res = fn.apply(null, arguments);
      if (res !== null) {
        _target.$off(event, onceHandler);
      }
    }
  }

  function updateComponentListeners (
    vm,
    listeners,
    oldListeners
  ) {
    target = vm;
    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
    target = undefined;
  }

  function eventsMixin (Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
      var vm = this;
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          vm.$on(event[i], fn);
        }
      } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn);
        // optimize hook:event cost by using a boolean flag marked at registration
        // instead of a hash lookup
        if (hookRE.test(event)) {
          vm._hasHookEvent = true;
        }
      }
      return vm
    };

    Vue.prototype.$once = function (event, fn) {
      var vm = this;
      function on () {
        vm.$off(event, on);
        fn.apply(vm, arguments);
      }
      on.fn = fn;
      vm.$on(event, on);
      return vm
    };

    Vue.prototype.$off = function (event, fn) {
      var vm = this;
      // all
      if (!arguments.length) {
        vm._events = Object.create(null);
        return vm
      }
      // array of events
      if (Array.isArray(event)) {
        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
          vm.$off(event[i$1], fn);
        }
        return vm
      }
      // specific event
      var cbs = vm._events[event];
      if (!cbs) {
        return vm
      }
      if (!fn) {
        vm._events[event] = null;
        return vm
      }
      // specific handler
      var cb;
      var i = cbs.length;
      while (i--) {
        cb = cbs[i];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i, 1);
          break
        }
      }
      return vm
    };

    Vue.prototype.$emit = function (event) {
      var vm = this;
      {
        var lowerCaseEvent = event.toLowerCase();
        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
          tip(
            "Event \"" + lowerCaseEvent + "\" is emitted in component " +
            (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
            "Note that HTML attributes are case-insensitive and you cannot use " +
            "v-on to listen to camelCase events when using in-DOM templates. " +
            "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
          );
        }
      }
      var cbs = vm._events[event];
      if (cbs) {
        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
        var args = toArray(arguments, 1);
        var info = "event handler for \"" + event + "\"";
        for (var i = 0, l = cbs.length; i < l; i++) {
          invokeWithErrorHandling(cbs[i], vm, args, vm, info);
        }
      }
      return vm
    };
  }

  /*  */

  var activeInstance = null;
  var isUpdatingChildComponent = false;

  function setActiveInstance(vm) {
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    return function () {
      activeInstance = prevActiveInstance;
    }
  }

  function initLifecycle (vm) {
    var options = vm.$options;

    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }
      parent.$children.push(vm);
    }

    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;

    vm.$children = [];
    vm.$refs = {};

    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
  }

  function lifecycleMixin (Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
      var vm = this;
      var prevEl = vm.$el;
      var prevVnode = vm._vnode;
      var restoreActiveInstance = setActiveInstance(vm);
      vm._vnode = vnode;
      // Vue.prototype.__patch__ is injected in entry points
      // based on the rendering backend used.
      if (!prevVnode) {
        // initial render
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
      } else {
        // updates
        vm.$el = vm.__patch__(prevVnode, vnode);
      }
      restoreActiveInstance();
      // update __vue__ reference
      if (prevEl) {
        prevEl.__vue__ = null;
      }
      if (vm.$el) {
        vm.$el.__vue__ = vm;
      }
      // if parent is an HOC, update its $el as well
      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el;
      }
      // updated hook is called by the scheduler to ensure that children are
      // updated in a parent's updated hook.
    };

    Vue.prototype.$forceUpdate = function () {
      var vm = this;
      if (vm._watcher) {
        vm._watcher.update();
      }
    };

    Vue.prototype.$destroy = function () {
      var vm = this;
      if (vm._isBeingDestroyed) {
        return
      }
      callHook(vm, 'beforeDestroy');
      vm._isBeingDestroyed = true;
      // remove self from parent
      var parent = vm.$parent;
      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm);
      }
      // teardown watchers
      if (vm._watcher) {
        vm._watcher.teardown();
      }
      var i = vm._watchers.length;
      while (i--) {
        vm._watchers[i].teardown();
      }
      // remove reference from data ob
      // frozen object may not have observer.
      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--;
      }
      // call the last hook...
      vm._isDestroyed = true;
      // invoke destroy hooks on current rendered tree
      vm.__patch__(vm._vnode, null);
      // fire destroyed hook
      callHook(vm, 'destroyed');
      // turn off all instance listeners.
      vm.$off();
      // remove __vue__ reference
      if (vm.$el) {
        vm.$el.__vue__ = null;
      }
      // release circular reference (#6759)
      if (vm.$vnode) {
        vm.$vnode.parent = null;
      }
    };
  }

  function mountComponent (
    vm,
    el,
    hydrating
  ) {
    vm.$el = el;
    if (!vm.$options.render) {
      vm.$options.render = createEmptyVNode;
      {
        /* istanbul ignore if */
        if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
          vm.$options.el || el) {
          warn(
            'You are using the runtime-only build of Vue where the template ' +
            'compiler is not available. Either pre-compile the templates into ' +
            'render functions, or use the compiler-included build.',
            vm
          );
        } else {
          warn(
            'Failed to mount component: template or render function not defined.',
            vm
          );
        }
      }
    }
    callHook(vm, 'beforeMount');

    var updateComponent;
    /* istanbul ignore if */
    if (config.performance && mark) {
      updateComponent = function () {
        var name = vm._name;
        var id = vm._uid;
        var startTag = "vue-perf-start:" + id;
        var endTag = "vue-perf-end:" + id;

        mark(startTag);
        var vnode = vm._render();
        mark(endTag);
        measure(("vue " + name + " render"), startTag, endTag);

        mark(startTag);
        vm._update(vnode, hydrating);
        mark(endTag);
        measure(("vue " + name + " patch"), startTag, endTag);
      };
    } else {
      updateComponent = function () {
        vm._update(vm._render(), hydrating);
      };
    }

    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop, {
      before: function before () {
        if (vm._isMounted && !vm._isDestroyed) {
          callHook(vm, 'beforeUpdate');
        }
      }
    }, true /* isRenderWatcher */);
    hydrating = false;

    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
      vm._isMounted = true;
      callHook(vm, 'mounted');
    }
    return vm
  }

  function updateChildComponent (
    vm,
    propsData,
    listeners,
    parentVnode,
    renderChildren
  ) {
    {
      isUpdatingChildComponent = true;
    }

    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren.

    // check if there are dynamic scopedSlots (hand-written or compiled but with
    // dynamic slot names). Static scoped slots compiled from template has the
    // "$stable" marker.
    var newScopedSlots = parentVnode.data.scopedSlots;
    var oldScopedSlots = vm.$scopedSlots;
    var hasDynamicScopedSlot = !!(
      (newScopedSlots && !newScopedSlots.$stable) ||
      (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
      (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
      (!newScopedSlots && vm.$scopedSlots.$key)
    );

    // Any static slot children from the parent may have changed during parent's
    // update. Dynamic scoped slots may also have changed. In such cases, a forced
    // update is necessary to ensure correctness.
    var needsForceUpdate = !!(
      renderChildren ||               // has new static slots
      vm.$options._renderChildren ||  // has old static slots
      hasDynamicScopedSlot
    );

    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render

    if (vm._vnode) { // update child tree's parent
      vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;

    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    vm.$attrs = parentVnode.data.attrs || emptyObject;
    vm.$listeners = listeners || emptyObject;

    // update props
    if (propsData && vm.$options.props) {
      toggleObserving(false);
      var props = vm._props;
      var propKeys = vm.$options._propKeys || [];
      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        var propOptions = vm.$options.props; // wtf flow?
        props[key] = validateProp(key, propOptions, propsData, vm);
      }
      toggleObserving(true);
      // keep a copy of raw propsData
      vm.$options.propsData = propsData;
    }

    // update listeners
    listeners = listeners || emptyObject;
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);

    // resolve slots + force update if has children
    if (needsForceUpdate) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }

    {
      isUpdatingChildComponent = false;
    }
  }

  function isInInactiveTree (vm) {
    while (vm && (vm = vm.$parent)) {
      if (vm._inactive) { return true }
    }
    return false
  }

  function activateChildComponent (vm, direct) {
    if (direct) {
      vm._directInactive = false;
      if (isInInactiveTree(vm)) {
        return
      }
    } else if (vm._directInactive) {
      return
    }
    if (vm._inactive || vm._inactive === null) {
      vm._inactive = false;
      for (var i = 0; i < vm.$children.length; i++) {
        activateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'activated');
    }
  }

  function deactivateChildComponent (vm, direct) {
    if (direct) {
      vm._directInactive = true;
      if (isInInactiveTree(vm)) {
        return
      }
    }
    if (!vm._inactive) {
      vm._inactive = true;
      for (var i = 0; i < vm.$children.length; i++) {
        deactivateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'deactivated');
    }
  }

  function callHook (vm, hook) {
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var handlers = vm.$options[hook];
    var info = hook + " hook";
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        invokeWithErrorHandling(handlers[i], vm, null, vm, info);
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook);
    }
    popTarget();
  }

  /*  */

  var MAX_UPDATE_COUNT = 100;

  var queue = [];
  var activatedChildren = [];
  var has = {};
  var circular = {};
  var waiting = false;
  var flushing = false;
  var index = 0;

  /**
   * Reset the scheduler's state.
   */
  function resetSchedulerState () {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    {
      circular = {};
    }
    waiting = flushing = false;
  }

  // Async edge case #6566 requires saving the timestamp when event listeners are
  // attached. However, calling performance.now() has a perf overhead especially
  // if the page has thousands of event listeners. Instead, we take a timestamp
  // every time the scheduler flushes and use that for all event listeners
  // attached during that flush.
  var currentFlushTimestamp = 0;

  // Async edge case fix requires storing an event listener's attach timestamp.
  var getNow = Date.now;

  // Determine what event timestamp the browser is using. Annoyingly, the
  // timestamp can either be hi-res (relative to page load) or low-res
  // (relative to UNIX epoch), so in order to compare time we have to use the
  // same timestamp type when saving the flush timestamp.
  // All IE versions use low-res event timestamps, and have problematic clock
  // implementations (#9632)
  if (inBrowser && !isIE) {
    var performance = window.performance;
    if (
      performance &&
      typeof performance.now === 'function' &&
      getNow() > document.createEvent('Event').timeStamp
    ) {
      // if the event timestamp, although evaluated AFTER the Date.now(), is
      // smaller than it, it means the event is using a hi-res timestamp,
      // and we need to use the hi-res version for event listener timestamps as
      // well.
      getNow = function () { return performance.now(); };
    }
  }

  /**
   * Flush both queues and run the watchers.
   */
  function flushSchedulerQueue () {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;

    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(function (a, b) { return a.id - b.id; });

    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      if (watcher.before) {
        watcher.before();
      }
      id = watcher.id;
      has[id] = null;
      watcher.run();
      // in dev build, check and stop circular updates.
      if (has[id] != null) {
        circular[id] = (circular[id] || 0) + 1;
        if (circular[id] > MAX_UPDATE_COUNT) {
          warn(
            'You may have an infinite update loop ' + (
              watcher.user
                ? ("in watcher with expression \"" + (watcher.expression) + "\"")
                : "in a component render function."
            ),
            watcher.vm
          );
          break
        }
      }
    }

    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();

    resetSchedulerState();

    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
      devtools.emit('flush');
    }
  }

  function callUpdatedHooks (queue) {
    var i = queue.length;
    while (i--) {
      var watcher = queue[i];
      var vm = watcher.vm;
      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'updated');
      }
    }
  }

  /**
   * Queue a kept-alive component that was activated during patch.
   * The queue will be processed after the entire tree has been patched.
   */
  function queueActivatedComponent (vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
  }

  function callActivatedHooks (queue) {
    for (var i = 0; i < queue.length; i++) {
      queue[i]._inactive = true;
      activateChildComponent(queue[i], true /* true */);
    }
  }

  /**
   * Push a watcher into the watcher queue.
   * Jobs with duplicate IDs will be skipped unless it's
   * pushed when the queue is being flushed.
   */
  function queueWatcher (watcher) {
    var id = watcher.id;
    if (has[id] == null) {
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      // queue the flush
      if (!waiting) {
        waiting = true;

        if (!config.async) {
          flushSchedulerQueue();
          return
        }
        nextTick(flushSchedulerQueue);
      }
    }
  }

  /*  */



  var uid$2 = 0;

  /**
   * A watcher parses an expression, collects dependencies,
   * and fires callback when the expression value changes.
   * This is used for both the $watch() api and directives.
   */
  var Watcher = function Watcher (
    vm,
    expOrFn,
    cb,
    options,
    isRenderWatcher
  ) {
    this.vm = vm;
    if (isRenderWatcher) {
      vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
      this.before = options.before;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$2; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = expOrFn.toString();
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = noop;
        warn(
          "Failed watching path: \"" + expOrFn + "\" " +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        );
      }
    }
    this.value = this.lazy
      ? undefined
      : this.get();
  };

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  Watcher.prototype.get = function get () {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
      } else {
        throw e
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value);
      }
      popTarget();
      this.cleanupDeps();
    }
    return value
  };

  /**
   * Add a dependency to this directive.
   */
  Watcher.prototype.addDep = function addDep (dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };

  /**
   * Clean up for dependency collection.
   */
  Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var i = this.deps.length;
    while (i--) {
      var dep = this.deps[i];
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  Watcher.prototype.update = function update () {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  Watcher.prototype.run = function run () {
    if (this.active) {
      var value = this.get();
      if (
        value !== this.value ||
        // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(value) ||
        this.deep
      ) {
        // set new value
        var oldValue = this.value;
        this.value = value;
        if (this.user) {
          var info = "callback for watcher \"" + (this.expression) + "\"";
          invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  Watcher.prototype.evaluate = function evaluate () {
    this.value = this.get();
    this.dirty = false;
  };

  /**
   * Depend on all deps collected by this watcher.
   */
  Watcher.prototype.depend = function depend () {
    var i = this.deps.length;
    while (i--) {
      this.deps[i].depend();
    }
  };

  /**
   * Remove self from all dependencies' subscriber list.
   */
  Watcher.prototype.teardown = function teardown () {
    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }
      var i = this.deps.length;
      while (i--) {
        this.deps[i].removeSub(this);
      }
      this.active = false;
    }
  };

  /*  */

  var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
  };

  function proxy (target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter () {
      return this[sourceKey][key]
    };
    sharedPropertyDefinition.set = function proxySetter (val) {
      this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function initState (vm) {
    vm._watchers = [];
    var opts = vm.$options;
    if (opts.props) { initProps(vm, opts.props); }
    if (opts.methods) { initMethods(vm, opts.methods); }
    if (opts.data) {
      initData(vm);
    } else {
      observe(vm._data = {}, true /* asRootData */);
    }
    if (opts.computed) { initComputed(vm, opts.computed); }
    if (opts.watch && opts.watch !== nativeWatch) {
      initWatch(vm, opts.watch);
    }
  }

  function initProps (vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = vm._props = {};
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
      toggleObserving(false);
    }
    var loop = function ( key ) {
      keys.push(key);
      var value = validateProp(key, propsOptions, propsData, vm);
      /* istanbul ignore else */
      {
        var hyphenatedKey = hyphenate(key);
        if (isReservedAttribute(hyphenatedKey) ||
            config.isReservedAttr(hyphenatedKey)) {
          warn(
            ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
            vm
          );
        }
        defineReactive$$1(props, key, value, function () {
          if (!isRoot && !isUpdatingChildComponent) {
            warn(
              "Avoid mutating a prop directly since the value will be " +
              "overwritten whenever the parent component re-renders. " +
              "Instead, use a data or computed property based on the prop's " +
              "value. Prop being mutated: \"" + key + "\"",
              vm
            );
          }
        });
      }
      // static props are already proxied on the component's prototype
      // during Vue.extend(). We only need to proxy props defined at
      // instantiation here.
      if (!(key in vm)) {
        proxy(vm, "_props", key);
      }
    };

    for (var key in propsOptions) loop( key );
    toggleObserving(true);
  }

  function initData (vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function'
      ? getData(data, vm)
      : data || {};
    if (!isPlainObject(data)) {
      data = {};
      warn(
        'data functions should return an object:\n' +
        'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
        vm
      );
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
      var key = keys[i];
      {
        if (methods && hasOwn(methods, key)) {
          warn(
            ("Method \"" + key + "\" has already been defined as a data property."),
            vm
          );
        }
      }
      if (props && hasOwn(props, key)) {
        warn(
          "The data property \"" + key + "\" is already declared as a prop. " +
          "Use prop default value instead.",
          vm
        );
      } else if (!isReserved(key)) {
        proxy(vm, "_data", key);
      }
    }
    // observe data
    observe(data, true /* asRootData */);
  }

  function getData (data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
      return data.call(vm, vm)
    } catch (e) {
      handleError(e, vm, "data()");
      return {}
    } finally {
      popTarget();
    }
  }

  var computedWatcherOptions = { lazy: true };

  function initComputed (vm, computed) {
    // $flow-disable-line
    var watchers = vm._computedWatchers = Object.create(null);
    // computed properties are just getters during SSR
    var isSSR = isServerRendering();

    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;
      if (getter == null) {
        warn(
          ("Getter is missing for computed property \"" + key + "\"."),
          vm
        );
      }

      if (!isSSR) {
        // create internal watcher for the computed property.
        watchers[key] = new Watcher(
          vm,
          getter || noop,
          noop,
          computedWatcherOptions
        );
      }

      // component-defined computed properties are already defined on the
      // component prototype. We only need to define computed properties defined
      // at instantiation here.
      if (!(key in vm)) {
        defineComputed(vm, key, userDef);
      } else {
        if (key in vm.$data) {
          warn(("The computed property \"" + key + "\" is already defined in data."), vm);
        } else if (vm.$options.props && key in vm.$options.props) {
          warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
        } else if (vm.$options.methods && key in vm.$options.methods) {
          warn(("The computed property \"" + key + "\" is already defined as a method."), vm);
        }
      }
    }
  }

  function defineComputed (
    target,
    key,
    userDef
  ) {
    var shouldCache = !isServerRendering();
    if (typeof userDef === 'function') {
      sharedPropertyDefinition.get = shouldCache
        ? createComputedGetter(key)
        : createGetterInvoker(userDef);
      sharedPropertyDefinition.set = noop;
    } else {
      sharedPropertyDefinition.get = userDef.get
        ? shouldCache && userDef.cache !== false
          ? createComputedGetter(key)
          : createGetterInvoker(userDef.get)
        : noop;
      sharedPropertyDefinition.set = userDef.set || noop;
    }
    if (sharedPropertyDefinition.set === noop) {
      sharedPropertyDefinition.set = function () {
        warn(
          ("Computed property \"" + key + "\" was assigned to but it has no setter."),
          this
        );
      };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function createComputedGetter (key) {
    return function computedGetter () {
      var watcher = this._computedWatchers && this._computedWatchers[key];
      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value
      }
    }
  }

  function createGetterInvoker(fn) {
    return function computedGetter () {
      return fn.call(this, this)
    }
  }

  function initMethods (vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
      {
        if (typeof methods[key] !== 'function') {
          warn(
            "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
            "Did you reference the function correctly?",
            vm
          );
        }
        if (props && hasOwn(props, key)) {
          warn(
            ("Method \"" + key + "\" has already been defined as a prop."),
            vm
          );
        }
        if ((key in vm) && isReserved(key)) {
          warn(
            "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
            "Avoid defining component methods that start with _ or $."
          );
        }
      }
      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
    }
  }

  function initWatch (vm, watch) {
    for (var key in watch) {
      var handler = watch[key];
      if (Array.isArray(handler)) {
        for (var i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i]);
        }
      } else {
        createWatcher(vm, key, handler);
      }
    }
  }

  function createWatcher (
    vm,
    expOrFn,
    handler,
    options
  ) {
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    if (typeof handler === 'string') {
      handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options)
  }

  function stateMixin (Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () { return this._data };
    var propsDef = {};
    propsDef.get = function () { return this._props };
    {
      dataDef.set = function () {
        warn(
          'Avoid replacing instance root $data. ' +
          'Use nested data properties instead.',
          this
        );
      };
      propsDef.set = function () {
        warn("$props is readonly.", this);
      };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);

    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;

    Vue.prototype.$watch = function (
      expOrFn,
      cb,
      options
    ) {
      var vm = this;
      if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options)
      }
      options = options || {};
      options.user = true;
      var watcher = new Watcher(vm, expOrFn, cb, options);
      if (options.immediate) {
        var info = "callback for immediate watcher \"" + (watcher.expression) + "\"";
        pushTarget();
        invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
        popTarget();
      }
      return function unwatchFn () {
        watcher.teardown();
      }
    };
  }

  /*  */

  var uid$3 = 0;

  function initMixin (Vue) {
    Vue.prototype._init = function (options) {
      var vm = this;
      // a uid
      vm._uid = uid$3++;

      var startTag, endTag;
      /* istanbul ignore if */
      if (config.performance && mark) {
        startTag = "vue-perf-start:" + (vm._uid);
        endTag = "vue-perf-end:" + (vm._uid);
        mark(startTag);
      }

      // a flag to avoid this being observed
      vm._isVue = true;
      // merge options
      if (options && options._isComponent) {
        // optimize internal component instantiation
        // since dynamic options merging is pretty slow, and none of the
        // internal component options needs special treatment.
        initInternalComponent(vm, options);
      } else {
        vm.$options = mergeOptions(
          resolveConstructorOptions(vm.constructor),
          options || {},
          vm
        );
      }
      /* istanbul ignore else */
      {
        initProxy(vm);
      }
      // expose real self
      vm._self = vm;
      initLifecycle(vm);
      initEvents(vm);
      initRender(vm);
      callHook(vm, 'beforeCreate');
      initInjections(vm); // resolve injections before data/props
      initState(vm);
      initProvide(vm); // resolve provide after data/props
      callHook(vm, 'created');

      /* istanbul ignore if */
      if (config.performance && mark) {
        vm._name = formatComponentName(vm, false);
        mark(endTag);
        measure(("vue " + (vm._name) + " init"), startTag, endTag);
      }

      if (vm.$options.el) {
        vm.$mount(vm.$options.el);
      }
    };
  }

  function initInternalComponent (vm, options) {
    var opts = vm.$options = Object.create(vm.constructor.options);
    // doing this because it's faster than dynamic enumeration.
    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;

    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;

    if (options.render) {
      opts.render = options.render;
      opts.staticRenderFns = options.staticRenderFns;
    }
  }

  function resolveConstructorOptions (Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
      var superOptions = resolveConstructorOptions(Ctor.super);
      var cachedSuperOptions = Ctor.superOptions;
      if (superOptions !== cachedSuperOptions) {
        // super option changed,
        // need to resolve new options.
        Ctor.superOptions = superOptions;
        // check if there are any late-modified/attached options (#4976)
        var modifiedOptions = resolveModifiedOptions(Ctor);
        // update base extend options
        if (modifiedOptions) {
          extend(Ctor.extendOptions, modifiedOptions);
        }
        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
        if (options.name) {
          options.components[options.name] = Ctor;
        }
      }
    }
    return options
  }

  function resolveModifiedOptions (Ctor) {
    var modified;
    var latest = Ctor.options;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
      if (latest[key] !== sealed[key]) {
        if (!modified) { modified = {}; }
        modified[key] = latest[key];
      }
    }
    return modified
  }

  function Vue (options) {
    if (!(this instanceof Vue)
    ) {
      warn('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
  }

  initMixin(Vue);
  stateMixin(Vue);
  eventsMixin(Vue);
  lifecycleMixin(Vue);
  renderMixin(Vue);

  /*  */

  function initUse (Vue) {
    Vue.use = function (plugin) {
      var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
      if (installedPlugins.indexOf(plugin) > -1) {
        return this
      }

      // additional parameters
      var args = toArray(arguments, 1);
      args.unshift(this);
      if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args);
      } else if (typeof plugin === 'function') {
        plugin.apply(null, args);
      }
      installedPlugins.push(plugin);
      return this
    };
  }

  /*  */

  function initMixin$1 (Vue) {
    Vue.mixin = function (mixin) {
      this.options = mergeOptions(this.options, mixin);
      return this
    };
  }

  /*  */

  function initExtend (Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;

    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
      extendOptions = extendOptions || {};
      var Super = this;
      var SuperId = Super.cid;
      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId]
      }

      var name = extendOptions.name || Super.options.name;
      if (name) {
        validateComponentName(name);
      }

      var Sub = function VueComponent (options) {
        this._init(options);
      };
      Sub.prototype = Object.create(Super.prototype);
      Sub.prototype.constructor = Sub;
      Sub.cid = cid++;
      Sub.options = mergeOptions(
        Super.options,
        extendOptions
      );
      Sub['super'] = Super;

      // For props and computed properties, we define the proxy getters on
      // the Vue instances at extension time, on the extended prototype. This
      // avoids Object.defineProperty calls for each instance created.
      if (Sub.options.props) {
        initProps$1(Sub);
      }
      if (Sub.options.computed) {
        initComputed$1(Sub);
      }

      // allow further extension/mixin/plugin usage
      Sub.extend = Super.extend;
      Sub.mixin = Super.mixin;
      Sub.use = Super.use;

      // create asset registers, so extended classes
      // can have their private assets too.
      ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type];
      });
      // enable recursive self-lookup
      if (name) {
        Sub.options.components[name] = Sub;
      }

      // keep a reference to the super options at extension time.
      // later at instantiation we can check if Super's options have
      // been updated.
      Sub.superOptions = Super.options;
      Sub.extendOptions = extendOptions;
      Sub.sealedOptions = extend({}, Sub.options);

      // cache constructor
      cachedCtors[SuperId] = Sub;
      return Sub
    };
  }

  function initProps$1 (Comp) {
    var props = Comp.options.props;
    for (var key in props) {
      proxy(Comp.prototype, "_props", key);
    }
  }

  function initComputed$1 (Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
      defineComputed(Comp.prototype, key, computed[key]);
    }
  }

  /*  */

  function initAssetRegisters (Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
      Vue[type] = function (
        id,
        definition
      ) {
        if (!definition) {
          return this.options[type + 's'][id]
        } else {
          /* istanbul ignore if */
          if (type === 'component') {
            validateComponentName(id);
          }
          if (type === 'component' && isPlainObject(definition)) {
            definition.name = definition.name || id;
            definition = this.options._base.extend(definition);
          }
          if (type === 'directive' && typeof definition === 'function') {
            definition = { bind: definition, update: definition };
          }
          this.options[type + 's'][id] = definition;
          return definition
        }
      };
    });
  }

  /*  */





  function getComponentName (opts) {
    return opts && (opts.Ctor.options.name || opts.tag)
  }

  function matches (pattern, name) {
    if (Array.isArray(pattern)) {
      return pattern.indexOf(name) > -1
    } else if (typeof pattern === 'string') {
      return pattern.split(',').indexOf(name) > -1
    } else if (isRegExp(pattern)) {
      return pattern.test(name)
    }
    /* istanbul ignore next */
    return false
  }

  function pruneCache (keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache;
    var keys = keepAliveInstance.keys;
    var _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
      var entry = cache[key];
      if (entry) {
        var name = entry.name;
        if (name && !filter(name)) {
          pruneCacheEntry(cache, key, keys, _vnode);
        }
      }
    }
  }

  function pruneCacheEntry (
    cache,
    key,
    keys,
    current
  ) {
    var entry = cache[key];
    if (entry && (!current || entry.tag !== current.tag)) {
      entry.componentInstance.$destroy();
    }
    cache[key] = null;
    remove(keys, key);
  }

  var patternTypes = [String, RegExp, Array];

  var KeepAlive = {
    name: 'keep-alive',
    abstract: true,

    props: {
      include: patternTypes,
      exclude: patternTypes,
      max: [String, Number]
    },

    methods: {
      cacheVNode: function cacheVNode() {
        var ref = this;
        var cache = ref.cache;
        var keys = ref.keys;
        var vnodeToCache = ref.vnodeToCache;
        var keyToCache = ref.keyToCache;
        if (vnodeToCache) {
          var tag = vnodeToCache.tag;
          var componentInstance = vnodeToCache.componentInstance;
          var componentOptions = vnodeToCache.componentOptions;
          cache[keyToCache] = {
            name: getComponentName(componentOptions),
            tag: tag,
            componentInstance: componentInstance,
          };
          keys.push(keyToCache);
          // prune oldest entry
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode);
          }
          this.vnodeToCache = null;
        }
      }
    },

    created: function created () {
      this.cache = Object.create(null);
      this.keys = [];
    },

    destroyed: function destroyed () {
      for (var key in this.cache) {
        pruneCacheEntry(this.cache, key, this.keys);
      }
    },

    mounted: function mounted () {
      var this$1 = this;

      this.cacheVNode();
      this.$watch('include', function (val) {
        pruneCache(this$1, function (name) { return matches(val, name); });
      });
      this.$watch('exclude', function (val) {
        pruneCache(this$1, function (name) { return !matches(val, name); });
      });
    },

    updated: function updated () {
      this.cacheVNode();
    },

    render: function render () {
      var slot = this.$slots.default;
      var vnode = getFirstComponentChild(slot);
      var componentOptions = vnode && vnode.componentOptions;
      if (componentOptions) {
        // check pattern
        var name = getComponentName(componentOptions);
        var ref = this;
        var include = ref.include;
        var exclude = ref.exclude;
        if (
          // not included
          (include && (!name || !matches(include, name))) ||
          // excluded
          (exclude && name && matches(exclude, name))
        ) {
          return vnode
        }

        var ref$1 = this;
        var cache = ref$1.cache;
        var keys = ref$1.keys;
        var key = vnode.key == null
          // same constructor may get registered as different local components
          // so cid alone is not enough (#3269)
          ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
          : vnode.key;
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance;
          // make current key freshest
          remove(keys, key);
          keys.push(key);
        } else {
          // delay setting the cache until update
          this.vnodeToCache = vnode;
          this.keyToCache = key;
        }

        vnode.data.keepAlive = true;
      }
      return vnode || (slot && slot[0])
    }
  };

  var builtInComponents = {
    KeepAlive: KeepAlive
  };

  /*  */

  function initGlobalAPI (Vue) {
    // config
    var configDef = {};
    configDef.get = function () { return config; };
    {
      configDef.set = function () {
        warn(
          'Do not replace the Vue.config object, set individual fields instead.'
        );
      };
    }
    Object.defineProperty(Vue, 'config', configDef);

    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
      warn: warn,
      extend: extend,
      mergeOptions: mergeOptions,
      defineReactive: defineReactive$$1
    };

    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;

    // 2.6 explicit observable API
    Vue.observable = function (obj) {
      observe(obj);
      return obj
    };

    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
      Vue.options[type + 's'] = Object.create(null);
    });

    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;

    extend(Vue.options.components, builtInComponents);

    initUse(Vue);
    initMixin$1(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
  }

  initGlobalAPI(Vue);

  Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
  });

  Object.defineProperty(Vue.prototype, '$ssrContext', {
    get: function get () {
      /* istanbul ignore next */
      return this.$vnode && this.$vnode.ssrContext
    }
  });

  // expose FunctionalRenderContext for ssr runtime helper installation
  Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
  });

  Vue.version = '2.6.14';

  /*  */

  // these are reserved for web because they are directly compiled away
  // during template compilation
  var isReservedAttr = makeMap('style,class');

  // attributes that should be using props for binding
  var acceptValue = makeMap('input,textarea,option,select,progress');
  var mustUseProp = function (tag, type, attr) {
    return (
      (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
      (attr === 'selected' && tag === 'option') ||
      (attr === 'checked' && tag === 'input') ||
      (attr === 'muted' && tag === 'video')
    )
  };

  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

  var convertEnumeratedValue = function (key, value) {
    return isFalsyAttrValue(value) || value === 'false'
      ? 'false'
      // allow arbitrary string value for contenteditable
      : key === 'contenteditable' && isValidContentEditableValue(value)
        ? value
        : 'true'
  };

  var isBooleanAttr = makeMap(
    'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
    'required,reversed,scoped,seamless,selected,sortable,' +
    'truespeed,typemustmatch,visible'
  );

  var xlinkNS = 'http://www.w3.org/1999/xlink';

  var isXlink = function (name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
  };

  var getXlinkProp = function (name) {
    return isXlink(name) ? name.slice(6, name.length) : ''
  };

  var isFalsyAttrValue = function (val) {
    return val == null || val === false
  };

  /*  */

  function genClassForVnode (vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data) {
        data = mergeClassData(childNode.data, data);
      }
    }
    while (isDef(parentNode = parentNode.parent)) {
      if (parentNode && parentNode.data) {
        data = mergeClassData(data, parentNode.data);
      }
    }
    return renderClass(data.staticClass, data.class)
  }

  function mergeClassData (child, parent) {
    return {
      staticClass: concat(child.staticClass, parent.staticClass),
      class: isDef(child.class)
        ? [child.class, parent.class]
        : parent.class
    }
  }

  function renderClass (
    staticClass,
    dynamicClass
  ) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
      return concat(staticClass, stringifyClass(dynamicClass))
    }
    /* istanbul ignore next */
    return ''
  }

  function concat (a, b) {
    return a ? b ? (a + ' ' + b) : a : (b || '')
  }

  function stringifyClass (value) {
    if (Array.isArray(value)) {
      return stringifyArray(value)
    }
    if (isObject(value)) {
      return stringifyObject(value)
    }
    if (typeof value === 'string') {
      return value
    }
    /* istanbul ignore next */
    return ''
  }

  function stringifyArray (value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
        if (res) { res += ' '; }
        res += stringified;
      }
    }
    return res
  }

  function stringifyObject (value) {
    var res = '';
    for (var key in value) {
      if (value[key]) {
        if (res) { res += ' '; }
        res += key;
      }
    }
    return res
  }

  /*  */

  var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
  };

  var isHTMLTag = makeMap(
    'html,body,base,head,link,meta,style,title,' +
    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
    'embed,object,param,source,canvas,script,noscript,del,ins,' +
    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
    'output,progress,select,textarea,' +
    'details,dialog,menu,menuitem,summary,' +
    'content,element,shadow,template,blockquote,iframe,tfoot'
  );

  // this map is intentionally selective, only covering SVG elements that may
  // contain child elements.
  var isSVG = makeMap(
    'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
    true
  );

  var isPreTag = function (tag) { return tag === 'pre'; };

  var isReservedTag = function (tag) {
    return isHTMLTag(tag) || isSVG(tag)
  };

  function getTagNamespace (tag) {
    if (isSVG(tag)) {
      return 'svg'
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
      return 'math'
    }
  }

  var unknownElementCache = Object.create(null);
  function isUnknownElement (tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
      return true
    }
    if (isReservedTag(tag)) {
      return false
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
      return unknownElementCache[tag]
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
      // http://stackoverflow.com/a/28210364/1070244
      return (unknownElementCache[tag] = (
        el.constructor === window.HTMLUnknownElement ||
        el.constructor === window.HTMLElement
      ))
    } else {
      return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
    }
  }

  var isTextInputType = makeMap('text,number,password,search,email,tel,url');

  /*  */

  /**
   * Query an element selector if it's not an element already.
   */
  function query (el) {
    if (typeof el === 'string') {
      var selected = document.querySelector(el);
      if (!selected) {
        warn(
          'Cannot find element: ' + el
        );
        return document.createElement('div')
      }
      return selected
    } else {
      return el
    }
  }

  /*  */

  function createElement$1 (tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
      return elm
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
      elm.setAttribute('multiple', 'multiple');
    }
    return elm
  }

  function createElementNS (namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName)
  }

  function createTextNode (text) {
    return document.createTextNode(text)
  }

  function createComment (text) {
    return document.createComment(text)
  }

  function insertBefore (parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
  }

  function removeChild (node, child) {
    node.removeChild(child);
  }

  function appendChild (node, child) {
    node.appendChild(child);
  }

  function parentNode (node) {
    return node.parentNode
  }

  function nextSibling (node) {
    return node.nextSibling
  }

  function tagName (node) {
    return node.tagName
  }

  function setTextContent (node, text) {
    node.textContent = text;
  }

  function setStyleScope (node, scopeId) {
    node.setAttribute(scopeId, '');
  }

  var nodeOps = /*#__PURE__*/Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setStyleScope: setStyleScope
  });

  /*  */

  var ref = {
    create: function create (_, vnode) {
      registerRef(vnode);
    },
    update: function update (oldVnode, vnode) {
      if (oldVnode.data.ref !== vnode.data.ref) {
        registerRef(oldVnode, true);
        registerRef(vnode);
      }
    },
    destroy: function destroy (vnode) {
      registerRef(vnode, true);
    }
  };

  function registerRef (vnode, isRemoval) {
    var key = vnode.data.ref;
    if (!isDef(key)) { return }

    var vm = vnode.context;
    var ref = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;
    if (isRemoval) {
      if (Array.isArray(refs[key])) {
        remove(refs[key], ref);
      } else if (refs[key] === ref) {
        refs[key] = undefined;
      }
    } else {
      if (vnode.data.refInFor) {
        if (!Array.isArray(refs[key])) {
          refs[key] = [ref];
        } else if (refs[key].indexOf(ref) < 0) {
          // $flow-disable-line
          refs[key].push(ref);
        }
      } else {
        refs[key] = ref;
      }
    }
  }

  /**
   * Virtual DOM patching algorithm based on Snabbdom by
   * Simon Friis Vindum (@paldepind)
   * Licensed under the MIT License
   * https://github.com/paldepind/snabbdom/blob/master/LICENSE
   *
   * modified by Evan You (@yyx990803)
   *
   * Not type-checking this because this file is perf-critical and the cost
   * of making flow understand it is not worth it.
   */

  var emptyNode = new VNode('', {}, []);

  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

  function sameVnode (a, b) {
    return (
      a.key === b.key &&
      a.asyncFactory === b.asyncFactory && (
        (
          a.tag === b.tag &&
          a.isComment === b.isComment &&
          isDef(a.data) === isDef(b.data) &&
          sameInputType(a, b)
        ) || (
          isTrue(a.isAsyncPlaceholder) &&
          isUndef(b.asyncFactory.error)
        )
      )
    )
  }

  function sameInputType (a, b) {
    if (a.tag !== 'input') { return true }
    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
  }

  function createKeyToOldIdx (children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key;
      if (isDef(key)) { map[key] = i; }
    }
    return map
  }

  function createPatchFunction (backend) {
    var i, j;
    var cbs = {};

    var modules = backend.modules;
    var nodeOps = backend.nodeOps;

    for (i = 0; i < hooks.length; ++i) {
      cbs[hooks[i]] = [];
      for (j = 0; j < modules.length; ++j) {
        if (isDef(modules[j][hooks[i]])) {
          cbs[hooks[i]].push(modules[j][hooks[i]]);
        }
      }
    }

    function emptyNodeAt (elm) {
      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
    }

    function createRmCb (childElm, listeners) {
      function remove$$1 () {
        if (--remove$$1.listeners === 0) {
          removeNode(childElm);
        }
      }
      remove$$1.listeners = listeners;
      return remove$$1
    }

    function removeNode (el) {
      var parent = nodeOps.parentNode(el);
      // element may have already been removed due to v-html / v-text
      if (isDef(parent)) {
        nodeOps.removeChild(parent, el);
      }
    }

    function isUnknownElement$$1 (vnode, inVPre) {
      return (
        !inVPre &&
        !vnode.ns &&
        !(
          config.ignoredElements.length &&
          config.ignoredElements.some(function (ignore) {
            return isRegExp(ignore)
              ? ignore.test(vnode.tag)
              : ignore === vnode.tag
          })
        ) &&
        config.isUnknownElement(vnode.tag)
      )
    }

    var creatingElmInVPre = 0;

    function createElm (
      vnode,
      insertedVnodeQueue,
      parentElm,
      refElm,
      nested,
      ownerArray,
      index
    ) {
      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // This vnode was used in a previous render!
        // now it's used as a new node, overwriting its elm would cause
        // potential patch errors down the road when it's used as an insertion
        // reference node. Instead, we clone the node on-demand before creating
        // associated DOM element for it.
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      vnode.isRootInsert = !nested; // for transition enter check
      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return
      }

      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;
      if (isDef(tag)) {
        {
          if (data && data.pre) {
            creatingElmInVPre++;
          }
          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
            warn(
              'Unknown custom element: <' + tag + '> - did you ' +
              'register the component correctly? For recursive components, ' +
              'make sure to provide the "name" option.',
              vnode.context
            );
          }
        }

        vnode.elm = vnode.ns
          ? nodeOps.createElementNS(vnode.ns, tag)
          : nodeOps.createElement(tag, vnode);
        setScope(vnode);

        /* istanbul ignore if */
        {
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }

        if (data && data.pre) {
          creatingElmInVPre--;
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }

    function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
      var i = vnode.data;
      if (isDef(i)) {
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
          i(vnode, false /* hydrating */);
        }
        // after calling the init hook, if the vnode is a child component
        // it should've created a child instance and mounted it. the child
        // component also has set the placeholder vnode's elm.
        // in that case we can just return the element and be done.
        if (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          insert(parentElm, vnode.elm, refElm);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true
        }
      }
    }

    function initComponent (vnode, insertedVnodeQueue) {
      if (isDef(vnode.data.pendingInsert)) {
        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
        vnode.data.pendingInsert = null;
      }
      vnode.elm = vnode.componentInstance.$el;
      if (isPatchable(vnode)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
        setScope(vnode);
      } else {
        // empty component root.
        // skip all element-related modules except for ref (#3455)
        registerRef(vnode);
        // make sure to invoke the insert hook
        insertedVnodeQueue.push(vnode);
      }
    }

    function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
      var i;
      // hack for #4339: a reactivated component with inner transition
      // does not trigger because the inner node's created hooks are not called
      // again. It's not ideal to involve module-specific logic in here but
      // there doesn't seem to be a better way to do it.
      var innerNode = vnode;
      while (innerNode.componentInstance) {
        innerNode = innerNode.componentInstance._vnode;
        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
          for (i = 0; i < cbs.activate.length; ++i) {
            cbs.activate[i](emptyNode, innerNode);
          }
          insertedVnodeQueue.push(innerNode);
          break
        }
      }
      // unlike a newly created component,
      // a reactivated keep-alive component doesn't insert itself
      insert(parentElm, vnode.elm, refElm);
    }

    function insert (parent, elm, ref$$1) {
      if (isDef(parent)) {
        if (isDef(ref$$1)) {
          if (nodeOps.parentNode(ref$$1) === parent) {
            nodeOps.insertBefore(parent, elm, ref$$1);
          }
        } else {
          nodeOps.appendChild(parent, elm);
        }
      }
    }

    function createChildren (vnode, children, insertedVnodeQueue) {
      if (Array.isArray(children)) {
        {
          checkDuplicateKeys(children);
        }
        for (var i = 0; i < children.length; ++i) {
          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
        }
      } else if (isPrimitive(vnode.text)) {
        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
      }
    }

    function isPatchable (vnode) {
      while (vnode.componentInstance) {
        vnode = vnode.componentInstance._vnode;
      }
      return isDef(vnode.tag)
    }

    function invokeCreateHooks (vnode, insertedVnodeQueue) {
      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
        cbs.create[i$1](emptyNode, vnode);
      }
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (isDef(i.create)) { i.create(emptyNode, vnode); }
        if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
      }
    }

    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope (vnode) {
      var i;
      if (isDef(i = vnode.fnScopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      } else {
        var ancestor = vnode;
        while (ancestor) {
          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
            nodeOps.setStyleScope(vnode.elm, i);
          }
          ancestor = ancestor.parent;
        }
      }
      // for slot content they should also get the scopeId from the host instance.
      if (isDef(i = activeInstance) &&
        i !== vnode.context &&
        i !== vnode.fnContext &&
        isDef(i = i.$options._scopeId)
      ) {
        nodeOps.setStyleScope(vnode.elm, i);
      }
    }

    function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
      for (; startIdx <= endIdx; ++startIdx) {
        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
      }
    }

    function invokeDestroyHook (vnode) {
      var i, j;
      var data = vnode.data;
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
        for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
      }
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }

    function removeVnodes (vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx];
        if (isDef(ch)) {
          if (isDef(ch.tag)) {
            removeAndInvokeRemoveHook(ch);
            invokeDestroyHook(ch);
          } else { // Text node
            removeNode(ch.elm);
          }
        }
      }
    }

    function removeAndInvokeRemoveHook (vnode, rm) {
      if (isDef(rm) || isDef(vnode.data)) {
        var i;
        var listeners = cbs.remove.length + 1;
        if (isDef(rm)) {
          // we have a recursively passed down rm callback
          // increase the listeners count
          rm.listeners += listeners;
        } else {
          // directly removing
          rm = createRmCb(vnode.elm, listeners);
        }
        // recursively invoke hooks on child component root node
        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
          removeAndInvokeRemoveHook(i, rm);
        }
        for (i = 0; i < cbs.remove.length; ++i) {
          cbs.remove[i](vnode, rm);
        }
        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
          i(vnode, rm);
        } else {
          rm();
        }
      } else {
        removeNode(vnode.elm);
      }
    }

    function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

      // removeOnly is a special flag used only by <transition-group>
      // to ensure removed elements stay in correct relative positions
      // during leaving transitions
      var canMove = !removeOnly;

      {
        checkDuplicateKeys(newCh);
      }

      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
        } else if (isUndef(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
          idxInOld = isDef(newStartVnode.key)
            ? oldKeyToIdx[newStartVnode.key]
            : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
          if (isUndef(idxInOld)) { // New element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          } else {
            vnodeToMove = oldCh[idxInOld];
            if (sameVnode(vnodeToMove, newStartVnode)) {
              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
              oldCh[idxInOld] = undefined;
              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
            } else {
              // same key but different element. treat as new element
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
            }
          }
          newStartVnode = newCh[++newStartIdx];
        }
      }
      if (oldStartIdx > oldEndIdx) {
        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
      }
    }

    function checkDuplicateKeys (children) {
      var seenKeys = {};
      for (var i = 0; i < children.length; i++) {
        var vnode = children[i];
        var key = vnode.key;
        if (isDef(key)) {
          if (seenKeys[key]) {
            warn(
              ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
              vnode.context
            );
          } else {
            seenKeys[key] = true;
          }
        }
      }
    }

    function findIdxInOld (node, oldCh, start, end) {
      for (var i = start; i < end; i++) {
        var c = oldCh[i];
        if (isDef(c) && sameVnode(node, c)) { return i }
      }
    }

    function patchVnode (
      oldVnode,
      vnode,
      insertedVnodeQueue,
      ownerArray,
      index,
      removeOnly
    ) {
      if (oldVnode === vnode) {
        return
      }

      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // clone reused vnode
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      var elm = vnode.elm = oldVnode.elm;

      if (isTrue(oldVnode.isAsyncPlaceholder)) {
        if (isDef(vnode.asyncFactory.resolved)) {
          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
        } else {
          vnode.isAsyncPlaceholder = true;
        }
        return
      }

      // reuse element for static trees.
      // note we only do this if the vnode is cloned -
      // if the new node is not cloned it means the render functions have been
      // reset by the hot-reload-api and we need to do a proper re-render.
      if (isTrue(vnode.isStatic) &&
        isTrue(oldVnode.isStatic) &&
        vnode.key === oldVnode.key &&
        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
      ) {
        vnode.componentInstance = oldVnode.componentInstance;
        return
      }

      var i;
      var data = vnode.data;
      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
        i(oldVnode, vnode);
      }

      var oldCh = oldVnode.children;
      var ch = vnode.children;
      if (isDef(data) && isPatchable(vnode)) {
        for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
        if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
      }
      if (isUndef(vnode.text)) {
        if (isDef(oldCh) && isDef(ch)) {
          if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
        } else if (isDef(ch)) {
          {
            checkDuplicateKeys(ch);
          }
          if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
        } else if (isDef(oldCh)) {
          removeVnodes(oldCh, 0, oldCh.length - 1);
        } else if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
      } else if (oldVnode.text !== vnode.text) {
        nodeOps.setTextContent(elm, vnode.text);
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
      }
    }

    function invokeInsertHook (vnode, queue, initial) {
      // delay insert hooks for component root nodes, invoke them after the
      // element is really inserted
      if (isTrue(initial) && isDef(vnode.parent)) {
        vnode.parent.data.pendingInsert = queue;
      } else {
        for (var i = 0; i < queue.length; ++i) {
          queue[i].data.hook.insert(queue[i]);
        }
      }
    }

    var hydrationBailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
      var i;
      var tag = vnode.tag;
      var data = vnode.data;
      var children = vnode.children;
      inVPre = inVPre || (data && data.pre);
      vnode.elm = elm;

      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
        vnode.isAsyncPlaceholder = true;
        return true
      }
      // assert node match
      {
        if (!assertNodeMatch(elm, vnode, inVPre)) {
          return false
        }
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
        if (isDef(i = vnode.componentInstance)) {
          // child component. it should have hydrated its own tree.
          initComponent(vnode, insertedVnodeQueue);
          return true
        }
      }
      if (isDef(tag)) {
        if (isDef(children)) {
          // empty element, allow client to pick up and populate children
          if (!elm.hasChildNodes()) {
            createChildren(vnode, children, insertedVnodeQueue);
          } else {
            // v-html and domProps: innerHTML
            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
              if (i !== elm.innerHTML) {
                /* istanbul ignore if */
                if (typeof console !== 'undefined' &&
                  !hydrationBailed
                ) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('server innerHTML: ', i);
                  console.warn('client innerHTML: ', elm.innerHTML);
                }
                return false
              }
            } else {
              // iterate and compare children lists
              var childrenMatch = true;
              var childNode = elm.firstChild;
              for (var i$1 = 0; i$1 < children.length; i$1++) {
                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                  childrenMatch = false;
                  break
                }
                childNode = childNode.nextSibling;
              }
              // if childNode is not null, it means the actual childNodes list is
              // longer than the virtual children list.
              if (!childrenMatch || childNode) {
                /* istanbul ignore if */
                if (typeof console !== 'undefined' &&
                  !hydrationBailed
                ) {
                  hydrationBailed = true;
                  console.warn('Parent: ', elm);
                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                }
                return false
              }
            }
          }
        }
        if (isDef(data)) {
          var fullInvoke = false;
          for (var key in data) {
            if (!isRenderedModule(key)) {
              fullInvoke = true;
              invokeCreateHooks(vnode, insertedVnodeQueue);
              break
            }
          }
          if (!fullInvoke && data['class']) {
            // ensure collecting deps for deep class bindings for future updates
            traverse(data['class']);
          }
        }
      } else if (elm.data !== vnode.text) {
        elm.data = vnode.text;
      }
      return true
    }

    function assertNodeMatch (node, vnode, inVPre) {
      if (isDef(vnode.tag)) {
        return vnode.tag.indexOf('vue-component') === 0 || (
          !isUnknownElement$$1(vnode, inVPre) &&
          vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
        )
      } else {
        return node.nodeType === (vnode.isComment ? 8 : 3)
      }
    }

    return function patch (oldVnode, vnode, hydrating, removeOnly) {
      if (isUndef(vnode)) {
        if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
        return
      }

      var isInitialPatch = false;
      var insertedVnodeQueue = [];

      if (isUndef(oldVnode)) {
        // empty mount (likely as component), create new root element
        isInitialPatch = true;
        createElm(vnode, insertedVnodeQueue);
      } else {
        var isRealElement = isDef(oldVnode.nodeType);
        if (!isRealElement && sameVnode(oldVnode, vnode)) {
          // patch existing root node
          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
        } else {
          if (isRealElement) {
            // mounting to a real element
            // check if this is server-rendered content and if we can perform
            // a successful hydration.
            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
              oldVnode.removeAttribute(SSR_ATTR);
              hydrating = true;
            }
            if (isTrue(hydrating)) {
              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                invokeInsertHook(vnode, insertedVnodeQueue, true);
                return oldVnode
              } else {
                warn(
                  'The client-side rendered virtual DOM tree is not matching ' +
                  'server-rendered content. This is likely caused by incorrect ' +
                  'HTML markup, for example nesting block-level elements inside ' +
                  '<p>, or missing <tbody>. Bailing hydration and performing ' +
                  'full client-side render.'
                );
              }
            }
            // either not server-rendered, or hydration failed.
            // create an empty node and replace it
            oldVnode = emptyNodeAt(oldVnode);
          }

          // replacing existing element
          var oldElm = oldVnode.elm;
          var parentElm = nodeOps.parentNode(oldElm);

          // create new node
          createElm(
            vnode,
            insertedVnodeQueue,
            // extremely rare edge case: do not insert if old element is in a
            // leaving transition. Only happens when combining transition +
            // keep-alive + HOCs. (#4590)
            oldElm._leaveCb ? null : parentElm,
            nodeOps.nextSibling(oldElm)
          );

          // update parent placeholder node element, recursively
          if (isDef(vnode.parent)) {
            var ancestor = vnode.parent;
            var patchable = isPatchable(vnode);
            while (ancestor) {
              for (var i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](ancestor);
              }
              ancestor.elm = vnode.elm;
              if (patchable) {
                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                  cbs.create[i$1](emptyNode, ancestor);
                }
                // #6513
                // invoke insert hooks that may have been merged by create hooks.
                // e.g. for directives that uses the "inserted" hook.
                var insert = ancestor.data.hook.insert;
                if (insert.merged) {
                  // start at index 1 to avoid re-invoking component mounted hook
                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                    insert.fns[i$2]();
                  }
                }
              } else {
                registerRef(ancestor);
              }
              ancestor = ancestor.parent;
            }
          }

          // destroy old node
          if (isDef(parentElm)) {
            removeVnodes([oldVnode], 0, 0);
          } else if (isDef(oldVnode.tag)) {
            invokeDestroyHook(oldVnode);
          }
        }
      }

      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
      return vnode.elm
    }
  }

  /*  */

  var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives (vnode) {
      updateDirectives(vnode, emptyNode);
    }
  };

  function updateDirectives (oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
      _update(oldVnode, vnode);
    }
  }

  function _update (oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

    var dirsWithInsert = [];
    var dirsWithPostpatch = [];

    var key, oldDir, dir;
    for (key in newDirs) {
      oldDir = oldDirs[key];
      dir = newDirs[key];
      if (!oldDir) {
        // new directive, bind
        callHook$1(dir, 'bind', vnode, oldVnode);
        if (dir.def && dir.def.inserted) {
          dirsWithInsert.push(dir);
        }
      } else {
        // existing directive, update
        dir.oldValue = oldDir.value;
        dir.oldArg = oldDir.arg;
        callHook$1(dir, 'update', vnode, oldVnode);
        if (dir.def && dir.def.componentUpdated) {
          dirsWithPostpatch.push(dir);
        }
      }
    }

    if (dirsWithInsert.length) {
      var callInsert = function () {
        for (var i = 0; i < dirsWithInsert.length; i++) {
          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
        }
      };
      if (isCreate) {
        mergeVNodeHook(vnode, 'insert', callInsert);
      } else {
        callInsert();
      }
    }

    if (dirsWithPostpatch.length) {
      mergeVNodeHook(vnode, 'postpatch', function () {
        for (var i = 0; i < dirsWithPostpatch.length; i++) {
          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
        }
      });
    }

    if (!isCreate) {
      for (key in oldDirs) {
        if (!newDirs[key]) {
          // no longer present, unbind
          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
        }
      }
    }
  }

  var emptyModifiers = Object.create(null);

  function normalizeDirectives$1 (
    dirs,
    vm
  ) {
    var res = Object.create(null);
    if (!dirs) {
      // $flow-disable-line
      return res
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
      dir = dirs[i];
      if (!dir.modifiers) {
        // $flow-disable-line
        dir.modifiers = emptyModifiers;
      }
      res[getRawDirName(dir)] = dir;
      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res
  }

  function getRawDirName (dir) {
    return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
  }

  function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
      try {
        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
      } catch (e) {
        handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
      }
    }
  }

  var baseModules = [
    ref,
    directives
  ];

  /*  */

  function updateAttrs (oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
      return
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
      return
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__)) {
      attrs = vnode.data.attrs = extend({}, attrs);
    }

    for (key in attrs) {
      cur = attrs[key];
      old = oldAttrs[key];
      if (old !== cur) {
        setAttr(elm, key, cur, vnode.data.pre);
      }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
      setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
      if (isUndef(attrs[key])) {
        if (isXlink(key)) {
          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else if (!isEnumeratedAttr(key)) {
          elm.removeAttribute(key);
        }
      }
    }
  }

  function setAttr (el, key, value, isInPre) {
    if (isInPre || el.tagName.indexOf('-') > -1) {
      baseSetAttr(el, key, value);
    } else if (isBooleanAttr(key)) {
      // set attribute for blank value
      // e.g. <option disabled>Select one</option>
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        // technically allowfullscreen is a boolean attribute for <iframe>,
        // but Flash expects a value of "true" when used on <embed> tag
        value = key === 'allowfullscreen' && el.tagName === 'EMBED'
          ? 'true'
          : key;
        el.setAttribute(key, value);
      }
    } else if (isEnumeratedAttr(key)) {
      el.setAttribute(key, convertEnumeratedValue(key, value));
    } else if (isXlink(key)) {
      if (isFalsyAttrValue(value)) {
        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      baseSetAttr(el, key, value);
    }
  }

  function baseSetAttr (el, key, value) {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.
      /* istanbul ignore if */
      if (
        isIE && !isIE9 &&
        el.tagName === 'TEXTAREA' &&
        key === 'placeholder' && value !== '' && !el.__ieph
      ) {
        var blocker = function (e) {
          e.stopImmediatePropagation();
          el.removeEventListener('input', blocker);
        };
        el.addEventListener('input', blocker);
        // $flow-disable-line
        el.__ieph = true; /* IE placeholder patched */
      }
      el.setAttribute(key, value);
    }
  }

  var attrs = {
    create: updateAttrs,
    update: updateAttrs
  };

  /*  */

  function updateClass (oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (
      isUndef(data.staticClass) &&
      isUndef(data.class) && (
        isUndef(oldData) || (
          isUndef(oldData.staticClass) &&
          isUndef(oldData.class)
        )
      )
    ) {
      return
    }

    var cls = genClassForVnode(vnode);

    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
      cls = concat(cls, stringifyClass(transitionClass));
    }

    // set the class
    if (cls !== el._prevClass) {
      el.setAttribute('class', cls);
      el._prevClass = cls;
    }
  }

  var klass = {
    create: updateClass,
    update: updateClass
  };

  /*  */

  var validDivisionCharRE = /[\w).+\-_$\]]/;

  function parseFilters (exp) {
    var inSingle = false;
    var inDouble = false;
    var inTemplateString = false;
    var inRegex = false;
    var curly = 0;
    var square = 0;
    var paren = 0;
    var lastFilterIndex = 0;
    var c, prev, i, expression, filters;

    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);
      if (inSingle) {
        if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
      } else if (inDouble) {
        if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
      } else if (inTemplateString) {
        if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
      } else if (inRegex) {
        if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
      } else if (
        c === 0x7C && // pipe
        exp.charCodeAt(i + 1) !== 0x7C &&
        exp.charCodeAt(i - 1) !== 0x7C &&
        !curly && !square && !paren
      ) {
        if (expression === undefined) {
          // first filter, end of expression
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 0x22: inDouble = true; break         // "
          case 0x27: inSingle = true; break         // '
          case 0x60: inTemplateString = true; break // `
          case 0x28: paren++; break                 // (
          case 0x29: paren--; break                 // )
          case 0x5B: square++; break                // [
          case 0x5D: square--; break                // ]
          case 0x7B: curly++; break                 // {
          case 0x7D: curly--; break                 // }
        }
        if (c === 0x2f) { // /
          var j = i - 1;
          var p = (void 0);
          // find first non-whitespace prev char
          for (; j >= 0; j--) {
            p = exp.charAt(j);
            if (p !== ' ') { break }
          }
          if (!p || !validDivisionCharRE.test(p)) {
            inRegex = true;
          }
        }
      }
    }

    if (expression === undefined) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }

    function pushFilter () {
      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }

    if (filters) {
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i]);
      }
    }

    return expression
  }

  function wrapFilter (exp, filter) {
    var i = filter.indexOf('(');
    if (i < 0) {
      // _f: resolveFilter
      return ("_f(\"" + filter + "\")(" + exp + ")")
    } else {
      var name = filter.slice(0, i);
      var args = filter.slice(i + 1);
      return ("_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args))
    }
  }

  /*  */



  /* eslint-disable no-unused-vars */
  function baseWarn (msg, range) {
    console.error(("[Vue compiler]: " + msg));
  }
  /* eslint-enable no-unused-vars */

  function pluckModuleFunction (
    modules,
    key
  ) {
    return modules
      ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
      : []
  }

  function addProp (el, name, value, range, dynamic) {
    (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
    el.plain = false;
  }

  function addAttr (el, name, value, range, dynamic) {
    var attrs = dynamic
      ? (el.dynamicAttrs || (el.dynamicAttrs = []))
      : (el.attrs || (el.attrs = []));
    attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));
    el.plain = false;
  }

  // add a raw attr (use this in preTransforms)
  function addRawAttr (el, name, value, range) {
    el.attrsMap[name] = value;
    el.attrsList.push(rangeSetItem({ name: name, value: value }, range));
  }

  function addDirective (
    el,
    name,
    rawName,
    value,
    arg,
    isDynamicArg,
    modifiers,
    range
  ) {
    (el.directives || (el.directives = [])).push(rangeSetItem({
      name: name,
      rawName: rawName,
      value: value,
      arg: arg,
      isDynamicArg: isDynamicArg,
      modifiers: modifiers
    }, range));
    el.plain = false;
  }

  function prependModifierMarker (symbol, name, dynamic) {
    return dynamic
      ? ("_p(" + name + ",\"" + symbol + "\")")
      : symbol + name // mark the event as captured
  }

  function addHandler (
    el,
    name,
    value,
    modifiers,
    important,
    warn,
    range,
    dynamic
  ) {
    modifiers = modifiers || emptyObject;
    // warn prevent and passive modifier
    /* istanbul ignore if */
    if (
      warn &&
      modifiers.prevent && modifiers.passive
    ) {
      warn(
        'passive and prevent can\'t be used together. ' +
        'Passive handler can\'t prevent default event.',
        range
      );
    }

    // normalize click.right and click.middle since they don't actually fire
    // this is technically browser-specific, but at least for now browsers are
    // the only target envs that have right/middle clicks.
    if (modifiers.right) {
      if (dynamic) {
        name = "(" + name + ")==='click'?'contextmenu':(" + name + ")";
      } else if (name === 'click') {
        name = 'contextmenu';
        delete modifiers.right;
      }
    } else if (modifiers.middle) {
      if (dynamic) {
        name = "(" + name + ")==='click'?'mouseup':(" + name + ")";
      } else if (name === 'click') {
        name = 'mouseup';
      }
    }

    // check capture modifier
    if (modifiers.capture) {
      delete modifiers.capture;
      name = prependModifierMarker('!', name, dynamic);
    }
    if (modifiers.once) {
      delete modifiers.once;
      name = prependModifierMarker('~', name, dynamic);
    }
    /* istanbul ignore if */
    if (modifiers.passive) {
      delete modifiers.passive;
      name = prependModifierMarker('&', name, dynamic);
    }

    var events;
    if (modifiers.native) {
      delete modifiers.native;
      events = el.nativeEvents || (el.nativeEvents = {});
    } else {
      events = el.events || (el.events = {});
    }

    var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);
    if (modifiers !== emptyObject) {
      newHandler.modifiers = modifiers;
    }

    var handlers = events[name];
    /* istanbul ignore if */
    if (Array.isArray(handlers)) {
      important ? handlers.unshift(newHandler) : handlers.push(newHandler);
    } else if (handlers) {
      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
    } else {
      events[name] = newHandler;
    }

    el.plain = false;
  }

  function getRawBindingAttr (
    el,
    name
  ) {
    return el.rawAttrsMap[':' + name] ||
      el.rawAttrsMap['v-bind:' + name] ||
      el.rawAttrsMap[name]
  }

  function getBindingAttr (
    el,
    name,
    getStatic
  ) {
    var dynamicValue =
      getAndRemoveAttr(el, ':' + name) ||
      getAndRemoveAttr(el, 'v-bind:' + name);
    if (dynamicValue != null) {
      return parseFilters(dynamicValue)
    } else if (getStatic !== false) {
      var staticValue = getAndRemoveAttr(el, name);
      if (staticValue != null) {
        return JSON.stringify(staticValue)
      }
    }
  }

  // note: this only removes the attr from the Array (attrsList) so that it
  // doesn't get processed by processAttrs.
  // By default it does NOT remove it from the map (attrsMap) because the map is
  // needed during codegen.
  function getAndRemoveAttr (
    el,
    name,
    removeFromMap
  ) {
    var val;
    if ((val = el.attrsMap[name]) != null) {
      var list = el.attrsList;
      for (var i = 0, l = list.length; i < l; i++) {
        if (list[i].name === name) {
          list.splice(i, 1);
          break
        }
      }
    }
    if (removeFromMap) {
      delete el.attrsMap[name];
    }
    return val
  }

  function getAndRemoveAttrByRegex (
    el,
    name
  ) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      var attr = list[i];
      if (name.test(attr.name)) {
        list.splice(i, 1);
        return attr
      }
    }
  }

  function rangeSetItem (
    item,
    range
  ) {
    if (range) {
      if (range.start != null) {
        item.start = range.start;
      }
      if (range.end != null) {
        item.end = range.end;
      }
    }
    return item
  }

  /*  */

  /**
   * Cross-platform code generation for component v-model
   */
  function genComponentModel (
    el,
    value,
    modifiers
  ) {
    var ref = modifiers || {};
    var number = ref.number;
    var trim = ref.trim;

    var baseValueExpression = '$$v';
    var valueExpression = baseValueExpression;
    if (trim) {
      valueExpression =
        "(typeof " + baseValueExpression + " === 'string'" +
        "? " + baseValueExpression + ".trim()" +
        ": " + baseValueExpression + ")";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }
    var assignment = genAssignmentCode(value, valueExpression);

    el.model = {
      value: ("(" + value + ")"),
      expression: JSON.stringify(value),
      callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
    };
  }

  /**
   * Cross-platform codegen helper for generating v-model value assignment code.
   */
  function genAssignmentCode (
    value,
    assignment
  ) {
    var res = parseModel(value);
    if (res.key === null) {
      return (value + "=" + assignment)
    } else {
      return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
    }
  }

  /**
   * Parse a v-model expression into a base path and a final key segment.
   * Handles both dot-path and possible square brackets.
   *
   * Possible cases:
   *
   * - test
   * - test[key]
   * - test[test1[key]]
   * - test["a"][key]
   * - xxx.test[a[a].test1[key]]
   * - test.xxx.a["asa"][test1[key]]
   *
   */

  var len, str, chr, index$1, expressionPos, expressionEndPos;



  function parseModel (val) {
    // Fix https://github.com/vuejs/vue/pull/7730
    // allow v-model="obj.val " (trailing whitespace)
    val = val.trim();
    len = val.length;

    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
      index$1 = val.lastIndexOf('.');
      if (index$1 > -1) {
        return {
          exp: val.slice(0, index$1),
          key: '"' + val.slice(index$1 + 1) + '"'
        }
      } else {
        return {
          exp: val,
          key: null
        }
      }
    }

    str = val;
    index$1 = expressionPos = expressionEndPos = 0;

    while (!eof()) {
      chr = next();
      /* istanbul ignore if */
      if (isStringStart(chr)) {
        parseString(chr);
      } else if (chr === 0x5B) {
        parseBracket(chr);
      }
    }

    return {
      exp: val.slice(0, expressionPos),
      key: val.slice(expressionPos + 1, expressionEndPos)
    }
  }

  function next () {
    return str.charCodeAt(++index$1)
  }

  function eof () {
    return index$1 >= len
  }

  function isStringStart (chr) {
    return chr === 0x22 || chr === 0x27
  }

  function parseBracket (chr) {
    var inBracket = 1;
    expressionPos = index$1;
    while (!eof()) {
      chr = next();
      if (isStringStart(chr)) {
        parseString(chr);
        continue
      }
      if (chr === 0x5B) { inBracket++; }
      if (chr === 0x5D) { inBracket--; }
      if (inBracket === 0) {
        expressionEndPos = index$1;
        break
      }
    }
  }

  function parseString (chr) {
    var stringQuote = chr;
    while (!eof()) {
      chr = next();
      if (chr === stringQuote) {
        break
      }
    }
  }

  /*  */

  var warn$1;

  // in some cases, the event used has to be determined at runtime
  // so we used some reserved tokens during compile.
  var RANGE_TOKEN = '__r';
  var CHECKBOX_RADIO_TOKEN = '__c';

  function model (
    el,
    dir,
    _warn
  ) {
    warn$1 = _warn;
    var value = dir.value;
    var modifiers = dir.modifiers;
    var tag = el.tag;
    var type = el.attrsMap.type;

    {
      // inputs with type="file" are read only and setting the input's
      // value will throw an error.
      if (tag === 'input' && type === 'file') {
        warn$1(
          "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
          "File inputs are read only. Use a v-on:change listener instead.",
          el.rawAttrsMap['v-model']
        );
      }
    }

    if (el.component) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false
    } else if (tag === 'select') {
      genSelect(el, value, modifiers);
    } else if (tag === 'input' && type === 'checkbox') {
      genCheckboxModel(el, value, modifiers);
    } else if (tag === 'input' && type === 'radio') {
      genRadioModel(el, value, modifiers);
    } else if (tag === 'input' || tag === 'textarea') {
      genDefaultModel(el, value, modifiers);
    } else if (!config.isReservedTag(tag)) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false
    } else {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "v-model is not supported on this element type. " +
        'If you are working with contenteditable, it\'s recommended to ' +
        'wrap a library dedicated for that purpose inside a custom component.',
        el.rawAttrsMap['v-model']
      );
    }

    // ensure runtime directive metadata
    return true
  }

  function genCheckboxModel (
    el,
    value,
    modifiers
  ) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
    addProp(el, 'checked',
      "Array.isArray(" + value + ")" +
      "?_i(" + value + "," + valueBinding + ")>-1" + (
        trueValueBinding === 'true'
          ? (":(" + value + ")")
          : (":_q(" + value + "," + trueValueBinding + ")")
      )
    );
    addHandler(el, 'change',
      "var $$a=" + value + "," +
          '$$el=$event.target,' +
          "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
      'if(Array.isArray($$a)){' +
        "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
            '$$i=_i($$a,$$v);' +
        "if($$el.checked){$$i<0&&(" + (genAssignmentCode(value, '$$a.concat([$$v])')) + ")}" +
        "else{$$i>-1&&(" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + ")}" +
      "}else{" + (genAssignmentCode(value, '$$c')) + "}",
      null, true
    );
  }

  function genRadioModel (
    el,
    value,
    modifiers
  ) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
    addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
  }

  function genSelect (
    el,
    value,
    modifiers
  ) {
    var number = modifiers && modifiers.number;
    var selectedVal = "Array.prototype.filter" +
      ".call($event.target.options,function(o){return o.selected})" +
      ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
      "return " + (number ? '_n(val)' : 'val') + "})";

    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
    var code = "var $$selectedVal = " + selectedVal + ";";
    code = code + " " + (genAssignmentCode(value, assignment));
    addHandler(el, 'change', code, null, true);
  }

  function genDefaultModel (
    el,
    value,
    modifiers
  ) {
    var type = el.attrsMap.type;

    // warn if v-bind:value conflicts with v-model
    // except for inputs with v-bind:type
    {
      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
      if (value$1 && !typeBinding) {
        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
        warn$1(
          binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " +
          'because the latter already expands to a value binding internally',
          el.rawAttrsMap[binding]
        );
      }
    }

    var ref = modifiers || {};
    var lazy = ref.lazy;
    var number = ref.number;
    var trim = ref.trim;
    var needCompositionGuard = !lazy && type !== 'range';
    var event = lazy
      ? 'change'
      : type === 'range'
        ? RANGE_TOKEN
        : 'input';

    var valueExpression = '$event.target.value';
    if (trim) {
      valueExpression = "$event.target.value.trim()";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }

    var code = genAssignmentCode(value, valueExpression);
    if (needCompositionGuard) {
      code = "if($event.target.composing)return;" + code;
    }

    addProp(el, 'value', ("(" + value + ")"));
    addHandler(el, event, code, null, true);
    if (trim || number) {
      addHandler(el, 'blur', '$forceUpdate()');
    }
  }

  /*  */

  // normalize v-model event tokens that can only be determined at runtime.
  // it's important to place the event as the first in the array because
  // the whole point is ensuring the v-model callback gets called before
  // user-attached handlers.
  function normalizeEvents (on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
      // IE input[type=range] only supports `change` event
      var event = isIE ? 'change' : 'input';
      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
      delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
      delete on[CHECKBOX_RADIO_TOKEN];
    }
  }

  var target$1;

  function createOnceHandler$1 (event, handler, capture) {
    var _target = target$1; // save current target element in closure
    return function onceHandler () {
      var res = handler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, onceHandler, capture, _target);
      }
    }
  }

  // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
  // implementation and does not fire microtasks in between event propagation, so
  // safe to exclude.
  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

  function add$1 (
    name,
    handler,
    capture,
    passive
  ) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    if (useMicrotaskFix) {
      var attachedTimestamp = currentFlushTimestamp;
      var original = handler;
      handler = original._wrapper = function (e) {
        if (
          // no bubbling, should always fire.
          // this is just a safety net in case event.timeStamp is unreliable in
          // certain weird environments...
          e.target === e.currentTarget ||
          // event is fired after handler attachment
          e.timeStamp >= attachedTimestamp ||
          // bail for environments that have buggy event.timeStamp implementations
          // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
          // #9681 QtWebEngine event.timeStamp is negative value
          e.timeStamp <= 0 ||
          // #9448 bail if event is fired in another document in a multi-page
          // electron/nw.js app, since event.timeStamp will be using a different
          // starting reference
          e.target.ownerDocument !== document
        ) {
          return original.apply(this, arguments)
        }
      };
    }
    target$1.addEventListener(
      name,
      handler,
      supportsPassive
        ? { capture: capture, passive: passive }
        : capture
    );
  }

  function remove$2 (
    name,
    handler,
    capture,
    _target
  ) {
    (_target || target$1).removeEventListener(
      name,
      handler._wrapper || handler,
      capture
    );
  }

  function updateDOMListeners (oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
      return
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    target$1 = vnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
    target$1 = undefined;
  }

  var events = {
    create: updateDOMListeners,
    update: updateDOMListeners
  };

  /*  */

  var svgContainer;

  function updateDOMProps (oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
      return
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__)) {
      props = vnode.data.domProps = extend({}, props);
    }

    for (key in oldProps) {
      if (!(key in props)) {
        elm[key] = '';
      }
    }

    for (key in props) {
      cur = props[key];
      // ignore children if the node has textContent or innerHTML,
      // as these will throw away existing DOM nodes and cause removal errors
      // on subsequent patches (#3360)
      if (key === 'textContent' || key === 'innerHTML') {
        if (vnode.children) { vnode.children.length = 0; }
        if (cur === oldProps[key]) { continue }
        // #6601 work around Chrome version <= 55 bug where single textNode
        // replaced by innerHTML/textContent retains its parentNode property
        if (elm.childNodes.length === 1) {
          elm.removeChild(elm.childNodes[0]);
        }
      }

      if (key === 'value' && elm.tagName !== 'PROGRESS') {
        // store value as _value as well since
        // non-string values will be stringified
        elm._value = cur;
        // avoid resetting cursor position when value is the same
        var strCur = isUndef(cur) ? '' : String(cur);
        if (shouldUpdateValue(elm, strCur)) {
          elm.value = strCur;
        }
      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
        // IE doesn't support innerHTML for SVG elements
        svgContainer = svgContainer || document.createElement('div');
        svgContainer.innerHTML = "<svg>" + cur + "</svg>";
        var svg = svgContainer.firstChild;
        while (elm.firstChild) {
          elm.removeChild(elm.firstChild);
        }
        while (svg.firstChild) {
          elm.appendChild(svg.firstChild);
        }
      } else if (
        // skip the update if old and new VDOM state is the same.
        // `value` is handled separately because the DOM value may be temporarily
        // out of sync with VDOM state due to focus, composition and modifiers.
        // This  #4521 by skipping the unnecessary `checked` update.
        cur !== oldProps[key]
      ) {
        // some property updates can throw
        // e.g. `value` on <progress> w/ non-finite value
        try {
          elm[key] = cur;
        } catch (e) {}
      }
    }
  }

  // check platforms/web/util/attrs.js acceptValue


  function shouldUpdateValue (elm, checkVal) {
    return (!elm.composing && (
      elm.tagName === 'OPTION' ||
      isNotInFocusAndDirty(elm, checkVal) ||
      isDirtyWithModifiers(elm, checkVal)
    ))
  }

  function isNotInFocusAndDirty (elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try { notInFocus = document.activeElement !== elm; } catch (e) {}
    return notInFocus && elm.value !== checkVal
  }

  function isDirtyWithModifiers (elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
      if (modifiers.number) {
        return toNumber(value) !== toNumber(newVal)
      }
      if (modifiers.trim) {
        return value.trim() !== newVal.trim()
      }
    }
    return value !== newVal
  }

  var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
  };

  /*  */

  var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
      if (item) {
        var tmp = item.split(propertyDelimiter);
        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return res
  });

  // merge static and dynamic style data on the same vnode
  function normalizeStyleData (data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle
      ? extend(data.staticStyle, style)
      : style
  }

  // normalize possible array / string values into Object
  function normalizeStyleBinding (bindingStyle) {
    if (Array.isArray(bindingStyle)) {
      return toObject(bindingStyle)
    }
    if (typeof bindingStyle === 'string') {
      return parseStyleText(bindingStyle)
    }
    return bindingStyle
  }

  /**
   * parent component style should be after child's
   * so that parent component's style could override it
   */
  function getStyle (vnode, checkChild) {
    var res = {};
    var styleData;

    if (checkChild) {
      var childNode = vnode;
      while (childNode.componentInstance) {
        childNode = childNode.componentInstance._vnode;
        if (
          childNode && childNode.data &&
          (styleData = normalizeStyleData(childNode.data))
        ) {
          extend(res, styleData);
        }
      }
    }

    if ((styleData = normalizeStyleData(vnode.data))) {
      extend(res, styleData);
    }

    var parentNode = vnode;
    while ((parentNode = parentNode.parent)) {
      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
        extend(res, styleData);
      }
    }
    return res
  }

  /*  */

  var cssVarRE = /^--/;
  var importantRE = /\s*!important$/;
  var setProp = function (el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
      el.style.setProperty(name, val);
    } else if (importantRE.test(val)) {
      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
    } else {
      var normalizedName = normalize(name);
      if (Array.isArray(val)) {
        // Support values array created by autoprefixer, e.g.
        // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
        // Set them one by one, and the browser will only set those it can recognize
        for (var i = 0, len = val.length; i < len; i++) {
          el.style[normalizedName] = val[i];
        }
      } else {
        el.style[normalizedName] = val;
      }
    }
  };

  var vendorNames = ['Webkit', 'Moz', 'ms'];

  var emptyStyle;
  var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && (prop in emptyStyle)) {
      return prop
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
      var name = vendorNames[i] + capName;
      if (name in emptyStyle) {
        return name
      }
    }
  });

  function updateStyle (oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;

    if (isUndef(data.staticStyle) && isUndef(data.style) &&
      isUndef(oldData.staticStyle) && isUndef(oldData.style)
    ) {
      return
    }

    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;

    var style = normalizeStyleBinding(vnode.data.style) || {};

    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__)
      ? extend({}, style)
      : style;

    var newStyle = getStyle(vnode, true);

    for (name in oldStyle) {
      if (isUndef(newStyle[name])) {
        setProp(el, name, '');
      }
    }
    for (name in newStyle) {
      cur = newStyle[name];
      if (cur !== oldStyle[name]) {
        // ie9 setting to null has no effect, must use empty string
        setProp(el, name, cur == null ? '' : cur);
      }
    }
  }

  var style = {
    create: updateStyle,
    update: updateStyle
  };

  /*  */

  var whitespaceRE = /\s+/;

  /**
   * Add class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function addClass (el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
      } else {
        el.classList.add(cls);
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      if (cur.indexOf(' ' + cls + ' ') < 0) {
        el.setAttribute('class', (cur + cls).trim());
      }
    }
  }

  /**
   * Remove class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function removeClass (el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
      } else {
        el.classList.remove(cls);
      }
      if (!el.classList.length) {
        el.removeAttribute('class');
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      var tar = ' ' + cls + ' ';
      while (cur.indexOf(tar) >= 0) {
        cur = cur.replace(tar, ' ');
      }
      cur = cur.trim();
      if (cur) {
        el.setAttribute('class', cur);
      } else {
        el.removeAttribute('class');
      }
    }
  }

  /*  */

  function resolveTransition (def$$1) {
    if (!def$$1) {
      return
    }
    /* istanbul ignore else */
    if (typeof def$$1 === 'object') {
      var res = {};
      if (def$$1.css !== false) {
        extend(res, autoCssTransition(def$$1.name || 'v'));
      }
      extend(res, def$$1);
      return res
    } else if (typeof def$$1 === 'string') {
      return autoCssTransition(def$$1)
    }
  }

  var autoCssTransition = cached(function (name) {
    return {
      enterClass: (name + "-enter"),
      enterToClass: (name + "-enter-to"),
      enterActiveClass: (name + "-enter-active"),
      leaveClass: (name + "-leave"),
      leaveToClass: (name + "-leave-to"),
      leaveActiveClass: (name + "-leave-active")
    }
  });

  var hasTransition = inBrowser && !isIE9;
  var TRANSITION = 'transition';
  var ANIMATION = 'animation';

  // Transition property/event sniffing
  var transitionProp = 'transition';
  var transitionEndEvent = 'transitionend';
  var animationProp = 'animation';
  var animationEndEvent = 'animationend';
  if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined &&
      window.onwebkittransitionend !== undefined
    ) {
      transitionProp = 'WebkitTransition';
      transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined &&
      window.onwebkitanimationend !== undefined
    ) {
      animationProp = 'WebkitAnimation';
      animationEndEvent = 'webkitAnimationEnd';
    }
  }

  // binding to window is necessary to make hot reload work in IE in strict mode
  var raf = inBrowser
    ? window.requestAnimationFrame
      ? window.requestAnimationFrame.bind(window)
      : setTimeout
    : /* istanbul ignore next */ function (fn) { return fn(); };

  function nextFrame (fn) {
    raf(function () {
      raf(fn);
    });
  }

  function addTransitionClass (el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
      transitionClasses.push(cls);
      addClass(el, cls);
    }
  }

  function removeTransitionClass (el, cls) {
    if (el._transitionClasses) {
      remove(el._transitionClasses, cls);
    }
    removeClass(el, cls);
  }

  function whenTransitionEnds (
    el,
    expectedType,
    cb
  ) {
    var ref = getTransitionInfo(el, expectedType);
    var type = ref.type;
    var timeout = ref.timeout;
    var propCount = ref.propCount;
    if (!type) { return cb() }
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function () {
      el.removeEventListener(event, onEnd);
      cb();
    };
    var onEnd = function (e) {
      if (e.target === el) {
        if (++ended >= propCount) {
          end();
        }
      }
    };
    setTimeout(function () {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
  }

  var transformRE = /\b(transform|all)(,|$)/;

  function getTransitionInfo (el, expectedType) {
    var styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);

    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0
        ? transitionTimeout > animationTimeout
          ? TRANSITION
          : ANIMATION
        : null;
      propCount = type
        ? type === TRANSITION
          ? transitionDurations.length
          : animationDurations.length
        : 0;
    }
    var hasTransform =
      type === TRANSITION &&
      transformRE.test(styles[transitionProp + 'Property']);
    return {
      type: type,
      timeout: timeout,
      propCount: propCount,
      hasTransform: hasTransform
    }
  }

  function getTimeout (delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }

    return Math.max.apply(null, durations.map(function (d, i) {
      return toMs(d) + toMs(delays[i])
    }))
  }

  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
  // in a locale-dependent way, using a comma instead of a dot.
  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting
  // as a floor function) causing unexpected behaviors
  function toMs (s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000
  }

  /*  */

  function enter (vnode, toggleDisplay) {
    var el = vnode.elm;

    // call leave callback now
    if (isDef(el._leaveCb)) {
      el._leaveCb.cancelled = true;
      el._leaveCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
      return
    }

    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
      return
    }

    var css = data.css;
    var type = data.type;
    var enterClass = data.enterClass;
    var enterToClass = data.enterToClass;
    var enterActiveClass = data.enterActiveClass;
    var appearClass = data.appearClass;
    var appearToClass = data.appearToClass;
    var appearActiveClass = data.appearActiveClass;
    var beforeEnter = data.beforeEnter;
    var enter = data.enter;
    var afterEnter = data.afterEnter;
    var enterCancelled = data.enterCancelled;
    var beforeAppear = data.beforeAppear;
    var appear = data.appear;
    var afterAppear = data.afterAppear;
    var appearCancelled = data.appearCancelled;
    var duration = data.duration;

    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
      context = transitionNode.context;
      transitionNode = transitionNode.parent;
    }

    var isAppear = !context._isMounted || !vnode.isRootInsert;

    if (isAppear && !appear && appear !== '') {
      return
    }

    var startClass = isAppear && appearClass
      ? appearClass
      : enterClass;
    var activeClass = isAppear && appearActiveClass
      ? appearActiveClass
      : enterActiveClass;
    var toClass = isAppear && appearToClass
      ? appearToClass
      : enterToClass;

    var beforeEnterHook = isAppear
      ? (beforeAppear || beforeEnter)
      : beforeEnter;
    var enterHook = isAppear
      ? (typeof appear === 'function' ? appear : enter)
      : enter;
    var afterEnterHook = isAppear
      ? (afterAppear || afterEnter)
      : afterEnter;
    var enterCancelledHook = isAppear
      ? (appearCancelled || enterCancelled)
      : enterCancelled;

    var explicitEnterDuration = toNumber(
      isObject(duration)
        ? duration.enter
        : duration
    );

    if (explicitEnterDuration != null) {
      checkDuration(explicitEnterDuration, 'enter', vnode);
    }

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);

    var cb = el._enterCb = once(function () {
      if (expectsCSS) {
        removeTransitionClass(el, toClass);
        removeTransitionClass(el, activeClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, startClass);
        }
        enterCancelledHook && enterCancelledHook(el);
      } else {
        afterEnterHook && afterEnterHook(el);
      }
      el._enterCb = null;
    });

    if (!vnode.data.show) {
      // remove pending leave element on enter by injecting an insert hook
      mergeVNodeHook(vnode, 'insert', function () {
        var parent = el.parentNode;
        var pendingNode = parent && parent._pending && parent._pending[vnode.key];
        if (pendingNode &&
          pendingNode.tag === vnode.tag &&
          pendingNode.elm._leaveCb
        ) {
          pendingNode.elm._leaveCb();
        }
        enterHook && enterHook(el, cb);
      });
    }

    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
      addTransitionClass(el, startClass);
      addTransitionClass(el, activeClass);
      nextFrame(function () {
        removeTransitionClass(el, startClass);
        if (!cb.cancelled) {
          addTransitionClass(el, toClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitEnterDuration)) {
              setTimeout(cb, explicitEnterDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    if (vnode.data.show) {
      toggleDisplay && toggleDisplay();
      enterHook && enterHook(el, cb);
    }

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }

  function leave (vnode, rm) {
    var el = vnode.elm;

    // call enter callback now
    if (isDef(el._enterCb)) {
      el._enterCb.cancelled = true;
      el._enterCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
      return rm()
    }

    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
      return
    }

    var css = data.css;
    var type = data.type;
    var leaveClass = data.leaveClass;
    var leaveToClass = data.leaveToClass;
    var leaveActiveClass = data.leaveActiveClass;
    var beforeLeave = data.beforeLeave;
    var leave = data.leave;
    var afterLeave = data.afterLeave;
    var leaveCancelled = data.leaveCancelled;
    var delayLeave = data.delayLeave;
    var duration = data.duration;

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);

    var explicitLeaveDuration = toNumber(
      isObject(duration)
        ? duration.leave
        : duration
    );

    if (isDef(explicitLeaveDuration)) {
      checkDuration(explicitLeaveDuration, 'leave', vnode);
    }

    var cb = el._leaveCb = once(function () {
      if (el.parentNode && el.parentNode._pending) {
        el.parentNode._pending[vnode.key] = null;
      }
      if (expectsCSS) {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, leaveClass);
        }
        leaveCancelled && leaveCancelled(el);
      } else {
        rm();
        afterLeave && afterLeave(el);
      }
      el._leaveCb = null;
    });

    if (delayLeave) {
      delayLeave(performLeave);
    } else {
      performLeave();
    }

    function performLeave () {
      // the delayed leave may have already been cancelled
      if (cb.cancelled) {
        return
      }
      // record leaving element
      if (!vnode.data.show && el.parentNode) {
        (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
      }
      beforeLeave && beforeLeave(el);
      if (expectsCSS) {
        addTransitionClass(el, leaveClass);
        addTransitionClass(el, leaveActiveClass);
        nextFrame(function () {
          removeTransitionClass(el, leaveClass);
          if (!cb.cancelled) {
            addTransitionClass(el, leaveToClass);
            if (!userWantsControl) {
              if (isValidDuration(explicitLeaveDuration)) {
                setTimeout(cb, explicitLeaveDuration);
              } else {
                whenTransitionEnds(el, type, cb);
              }
            }
          }
        });
      }
      leave && leave(el, cb);
      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
  }

  // only used in dev mode
  function checkDuration (val, name, vnode) {
    if (typeof val !== 'number') {
      warn(
        "<transition> explicit " + name + " duration is not a valid number - " +
        "got " + (JSON.stringify(val)) + ".",
        vnode.context
      );
    } else if (isNaN(val)) {
      warn(
        "<transition> explicit " + name + " duration is NaN - " +
        'the duration expression might be incorrect.',
        vnode.context
      );
    }
  }

  function isValidDuration (val) {
    return typeof val === 'number' && !isNaN(val)
  }

  /**
   * Normalize a transition hook's argument length. The hook may be:
   * - a merged hook (invoker) with the original in .fns
   * - a wrapped component method (check ._length)
   * - a plain function (.length)
   */
  function getHookArgumentsLength (fn) {
    if (isUndef(fn)) {
      return false
    }
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
      // invoker
      return getHookArgumentsLength(
        Array.isArray(invokerFns)
          ? invokerFns[0]
          : invokerFns
      )
    } else {
      return (fn._length || fn.length) > 1
    }
  }

  function _enter (_, vnode) {
    if (vnode.data.show !== true) {
      enter(vnode);
    }
  }

  var transition = inBrowser ? {
    create: _enter,
    activate: _enter,
    remove: function remove$$1 (vnode, rm) {
      /* istanbul ignore else */
      if (vnode.data.show !== true) {
        leave(vnode, rm);
      } else {
        rm();
      }
    }
  } : {};

  var platformModules = [
    attrs,
    klass,
    events,
    domProps,
    style,
    transition
  ];

  /*  */

  // the directive module should be applied last, after all
  // built-in modules have been applied.
  var modules = platformModules.concat(baseModules);

  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

  /**
   * Not type checking this file because flow doesn't like attaching
   * properties to Elements.
   */

  /* istanbul ignore if */
  if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
      var el = document.activeElement;
      if (el && el.vmodel) {
        trigger(el, 'input');
      }
    });
  }

  var directive = {
    inserted: function inserted (el, binding, vnode, oldVnode) {
      if (vnode.tag === 'select') {
        // #6903
        if (oldVnode.elm && !oldVnode.elm._vOptions) {
          mergeVNodeHook(vnode, 'postpatch', function () {
            directive.componentUpdated(el, binding, vnode);
          });
        } else {
          setSelected(el, binding, vnode.context);
        }
        el._vOptions = [].map.call(el.options, getValue);
      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
        el._vModifiers = binding.modifiers;
        if (!binding.modifiers.lazy) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          el.addEventListener('change', onCompositionEnd);
          /* istanbul ignore if */
          if (isIE9) {
            el.vmodel = true;
          }
        }
      }
    },

    componentUpdated: function componentUpdated (el, binding, vnode) {
      if (vnode.tag === 'select') {
        setSelected(el, binding, vnode.context);
        // in case the options rendered by v-for have changed,
        // it's possible that the value is out-of-sync with the rendered options.
        // detect such cases and filter out values that no longer has a matching
        // option in the DOM.
        var prevOptions = el._vOptions;
        var curOptions = el._vOptions = [].map.call(el.options, getValue);
        if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
          // trigger change event if
          // no matching option found for at least one value
          var needReset = el.multiple
            ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
            : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
          if (needReset) {
            trigger(el, 'change');
          }
        }
      }
    }
  };

  function setSelected (el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE || isEdge) {
      setTimeout(function () {
        actuallySetSelected(el, binding, vm);
      }, 0);
    }
  }

  function actuallySetSelected (el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
      warn(
        "<select multiple v-model=\"" + (binding.expression) + "\"> " +
        "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
        vm
      );
      return
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
      option = el.options[i];
      if (isMultiple) {
        selected = looseIndexOf(value, getValue(option)) > -1;
        if (option.selected !== selected) {
          option.selected = selected;
        }
      } else {
        if (looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i) {
            el.selectedIndex = i;
          }
          return
        }
      }
    }
    if (!isMultiple) {
      el.selectedIndex = -1;
    }
  }

  function hasNoMatchingOption (value, options) {
    return options.every(function (o) { return !looseEqual(o, value); })
  }

  function getValue (option) {
    return '_value' in option
      ? option._value
      : option.value
  }

  function onCompositionStart (e) {
    e.target.composing = true;
  }

  function onCompositionEnd (e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing) { return }
    e.target.composing = false;
    trigger(e.target, 'input');
  }

  function trigger (el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
  }

  /*  */

  // recursively search for possible transition defined inside the component root
  function locateNode (vnode) {
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
      ? locateNode(vnode.componentInstance._vnode)
      : vnode
  }

  var show = {
    bind: function bind (el, ref, vnode) {
      var value = ref.value;

      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      var originalDisplay = el.__vOriginalDisplay =
        el.style.display === 'none' ? '' : el.style.display;
      if (value && transition$$1) {
        vnode.data.show = true;
        enter(vnode, function () {
          el.style.display = originalDisplay;
        });
      } else {
        el.style.display = value ? originalDisplay : 'none';
      }
    },

    update: function update (el, ref, vnode) {
      var value = ref.value;
      var oldValue = ref.oldValue;

      /* istanbul ignore if */
      if (!value === !oldValue) { return }
      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      if (transition$$1) {
        vnode.data.show = true;
        if (value) {
          enter(vnode, function () {
            el.style.display = el.__vOriginalDisplay;
          });
        } else {
          leave(vnode, function () {
            el.style.display = 'none';
          });
        }
      } else {
        el.style.display = value ? el.__vOriginalDisplay : 'none';
      }
    },

    unbind: function unbind (
      el,
      binding,
      vnode,
      oldVnode,
      isDestroy
    ) {
      if (!isDestroy) {
        el.style.display = el.__vOriginalDisplay;
      }
    }
  };

  var platformDirectives = {
    model: directive,
    show: show
  };

  /*  */

  var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
  };

  // in case the child is also an abstract component, e.g. <keep-alive>
  // we want to recursively retrieve the real component to be rendered
  function getRealChild (vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
      return getRealChild(getFirstComponentChild(compOptions.children))
    } else {
      return vnode
    }
  }

  function extractTransitionData (comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
      data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key$1 in listeners) {
      data[camelize(key$1)] = listeners[key$1];
    }
    return data
  }

  function placeholder (h, rawChild) {
    if (/\d-keep-alive$/.test(rawChild.tag)) {
      return h('keep-alive', {
        props: rawChild.componentOptions.propsData
      })
    }
  }

  function hasParentTransition (vnode) {
    while ((vnode = vnode.parent)) {
      if (vnode.data.transition) {
        return true
      }
    }
  }

  function isSameChild (child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag
  }

  var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

  var isVShowDirective = function (d) { return d.name === 'show'; };

  var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,

    render: function render (h) {
      var this$1 = this;

      var children = this.$slots.default;
      if (!children) {
        return
      }

      // filter out text nodes (possible whitespaces)
      children = children.filter(isNotTextNode);
      /* istanbul ignore if */
      if (!children.length) {
        return
      }

      // warn multiple elements
      if (children.length > 1) {
        warn(
          '<transition> can only be used on a single element. Use ' +
          '<transition-group> for lists.',
          this.$parent
        );
      }

      var mode = this.mode;

      // warn invalid mode
      if (mode && mode !== 'in-out' && mode !== 'out-in'
      ) {
        warn(
          'invalid <transition> mode: ' + mode,
          this.$parent
        );
      }

      var rawChild = children[0];

      // if this is a component root node and the component's
      // parent container node also has transition, skip.
      if (hasParentTransition(this.$vnode)) {
        return rawChild
      }

      // apply transition data to child
      // use getRealChild() to ignore abstract components e.g. keep-alive
      var child = getRealChild(rawChild);
      /* istanbul ignore if */
      if (!child) {
        return rawChild
      }

      if (this._leaving) {
        return placeholder(h, rawChild)
      }

      // ensure a key that is unique to the vnode type and to this transition
      // component instance. This key will be used to remove pending leaving nodes
      // during entering.
      var id = "__transition-" + (this._uid) + "-";
      child.key = child.key == null
        ? child.isComment
          ? id + 'comment'
          : id + child.tag
        : isPrimitive(child.key)
          ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
          : child.key;

      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
      var oldRawChild = this._vnode;
      var oldChild = getRealChild(oldRawChild);

      // mark v-show
      // so that the transition module can hand over the control to the directive
      if (child.data.directives && child.data.directives.some(isVShowDirective)) {
        child.data.show = true;
      }

      if (
        oldChild &&
        oldChild.data &&
        !isSameChild(child, oldChild) &&
        !isAsyncPlaceholder(oldChild) &&
        // #6687 component root is a comment node
        !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
      ) {
        // replace old child transition data with fresh one
        // important for dynamic transitions!
        var oldData = oldChild.data.transition = extend({}, data);
        // handle transition mode
        if (mode === 'out-in') {
          // return placeholder node and queue update when leave finishes
          this._leaving = true;
          mergeVNodeHook(oldData, 'afterLeave', function () {
            this$1._leaving = false;
            this$1.$forceUpdate();
          });
          return placeholder(h, rawChild)
        } else if (mode === 'in-out') {
          if (isAsyncPlaceholder(child)) {
            return oldRawChild
          }
          var delayedLeave;
          var performLeave = function () { delayedLeave(); };
          mergeVNodeHook(data, 'afterEnter', performLeave);
          mergeVNodeHook(data, 'enterCancelled', performLeave);
          mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
        }
      }

      return rawChild
    }
  };

  /*  */

  var props = extend({
    tag: String,
    moveClass: String
  }, transitionProps);

  delete props.mode;

  var TransitionGroup = {
    props: props,

    beforeMount: function beforeMount () {
      var this$1 = this;

      var update = this._update;
      this._update = function (vnode, hydrating) {
        var restoreActiveInstance = setActiveInstance(this$1);
        // force removing pass
        this$1.__patch__(
          this$1._vnode,
          this$1.kept,
          false, // hydrating
          true // removeOnly (!important, avoids unnecessary moves)
        );
        this$1._vnode = this$1.kept;
        restoreActiveInstance();
        update.call(this$1, vnode, hydrating);
      };
    },

    render: function render (h) {
      var tag = this.tag || this.$vnode.data.tag || 'span';
      var map = Object.create(null);
      var prevChildren = this.prevChildren = this.children;
      var rawChildren = this.$slots.default || [];
      var children = this.children = [];
      var transitionData = extractTransitionData(this);

      for (var i = 0; i < rawChildren.length; i++) {
        var c = rawChildren[i];
        if (c.tag) {
          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
            children.push(c);
            map[c.key] = c
            ;(c.data || (c.data = {})).transition = transitionData;
          } else {
            var opts = c.componentOptions;
            var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
            warn(("<transition-group> children must be keyed: <" + name + ">"));
          }
        }
      }

      if (prevChildren) {
        var kept = [];
        var removed = [];
        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
          var c$1 = prevChildren[i$1];
          c$1.data.transition = transitionData;
          c$1.data.pos = c$1.elm.getBoundingClientRect();
          if (map[c$1.key]) {
            kept.push(c$1);
          } else {
            removed.push(c$1);
          }
        }
        this.kept = h(tag, null, kept);
        this.removed = removed;
      }

      return h(tag, null, children)
    },

    updated: function updated () {
      var children = this.prevChildren;
      var moveClass = this.moveClass || ((this.name || 'v') + '-move');
      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
        return
      }

      // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.
      children.forEach(callPendingCbs);
      children.forEach(recordPosition);
      children.forEach(applyTranslation);

      // force reflow to put everything in position
      // assign to this to avoid being removed in tree-shaking
      // $flow-disable-line
      this._reflow = document.body.offsetHeight;

      children.forEach(function (c) {
        if (c.data.moved) {
          var el = c.elm;
          var s = el.style;
          addTransitionClass(el, moveClass);
          s.transform = s.WebkitTransform = s.transitionDuration = '';
          el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
            if (e && e.target !== el) {
              return
            }
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener(transitionEndEvent, cb);
              el._moveCb = null;
              removeTransitionClass(el, moveClass);
            }
          });
        }
      });
    },

    methods: {
      hasMove: function hasMove (el, moveClass) {
        /* istanbul ignore if */
        if (!hasTransition) {
          return false
        }
        /* istanbul ignore if */
        if (this._hasMove) {
          return this._hasMove
        }
        // Detect whether an element with the move class applied has
        // CSS transitions. Since the element may be inside an entering
        // transition at this very moment, we make a clone of it and remove
        // all other transition classes applied to ensure only the move class
        // is applied.
        var clone = el.cloneNode();
        if (el._transitionClasses) {
          el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
        }
        addClass(clone, moveClass);
        clone.style.display = 'none';
        this.$el.appendChild(clone);
        var info = getTransitionInfo(clone);
        this.$el.removeChild(clone);
        return (this._hasMove = info.hasTransform)
      }
    }
  };

  function callPendingCbs (c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
      c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
      c.elm._enterCb();
    }
  }

  function recordPosition (c) {
    c.data.newPos = c.elm.getBoundingClientRect();
  }

  function applyTranslation (c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
      c.data.moved = true;
      var s = c.elm.style;
      s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
      s.transitionDuration = '0s';
    }
  }

  var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup
  };

  /*  */

  // install platform specific utils
  Vue.config.mustUseProp = mustUseProp;
  Vue.config.isReservedTag = isReservedTag;
  Vue.config.isReservedAttr = isReservedAttr;
  Vue.config.getTagNamespace = getTagNamespace;
  Vue.config.isUnknownElement = isUnknownElement;

  // install platform runtime directives & components
  extend(Vue.options.directives, platformDirectives);
  extend(Vue.options.components, platformComponents);

  // install platform patch function
  Vue.prototype.__patch__ = inBrowser ? patch : noop;

  // public mount method
  Vue.prototype.$mount = function (
    el,
    hydrating
  ) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating)
  };

  // devtools global hook
  /* istanbul ignore next */
  if (inBrowser) {
    setTimeout(function () {
      if (config.devtools) {
        if (devtools) {
          devtools.emit('init', Vue);
        } else {
          console[console.info ? 'info' : 'log'](
            'Download the Vue Devtools extension for a better development experience:\n' +
            'https://github.com/vuejs/vue-devtools'
          );
        }
      }
      if (config.productionTip !== false &&
        typeof console !== 'undefined'
      ) {
        console[console.info ? 'info' : 'log'](
          "You are running Vue in development mode.\n" +
          "Make sure to turn on production mode when deploying for production.\n" +
          "See more tips at https://vuejs.org/guide/deployment.html"
        );
      }
    }, 0);
  }

  /*  */

  var defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
  var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

  var buildRegex = cached(function (delimiters) {
    var open = delimiters[0].replace(regexEscapeRE, '\\$&');
    var close = delimiters[1].replace(regexEscapeRE, '\\$&');
    return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
  });



  function parseText (
    text,
    delimiters
  ) {
    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
    if (!tagRE.test(text)) {
      return
    }
    var tokens = [];
    var rawTokens = [];
    var lastIndex = tagRE.lastIndex = 0;
    var match, index, tokenValue;
    while ((match = tagRE.exec(text))) {
      index = match.index;
      // push text token
      if (index > lastIndex) {
        rawTokens.push(tokenValue = text.slice(lastIndex, index));
        tokens.push(JSON.stringify(tokenValue));
      }
      // tag token
      var exp = parseFilters(match[1].trim());
      tokens.push(("_s(" + exp + ")"));
      rawTokens.push({ '@binding': exp });
      lastIndex = index + match[0].length;
    }
    if (lastIndex < text.length) {
      rawTokens.push(tokenValue = text.slice(lastIndex));
      tokens.push(JSON.stringify(tokenValue));
    }
    return {
      expression: tokens.join('+'),
      tokens: rawTokens
    }
  }

  /*  */

  function transformNode (el, options) {
    var warn = options.warn || baseWarn;
    var staticClass = getAndRemoveAttr(el, 'class');
    if (staticClass) {
      var res = parseText(staticClass, options.delimiters);
      if (res) {
        warn(
          "class=\"" + staticClass + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div class="{{ val }}">, use <div :class="val">.',
          el.rawAttrsMap['class']
        );
      }
    }
    if (staticClass) {
      el.staticClass = JSON.stringify(staticClass);
    }
    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
    if (classBinding) {
      el.classBinding = classBinding;
    }
  }

  function genData (el) {
    var data = '';
    if (el.staticClass) {
      data += "staticClass:" + (el.staticClass) + ",";
    }
    if (el.classBinding) {
      data += "class:" + (el.classBinding) + ",";
    }
    return data
  }

  var klass$1 = {
    staticKeys: ['staticClass'],
    transformNode: transformNode,
    genData: genData
  };

  /*  */

  function transformNode$1 (el, options) {
    var warn = options.warn || baseWarn;
    var staticStyle = getAndRemoveAttr(el, 'style');
    if (staticStyle) {
      /* istanbul ignore if */
      {
        var res = parseText(staticStyle, options.delimiters);
        if (res) {
          warn(
            "style=\"" + staticStyle + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div style="{{ val }}">, use <div :style="val">.',
            el.rawAttrsMap['style']
          );
        }
      }
      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
    }

    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
    if (styleBinding) {
      el.styleBinding = styleBinding;
    }
  }

  function genData$1 (el) {
    var data = '';
    if (el.staticStyle) {
      data += "staticStyle:" + (el.staticStyle) + ",";
    }
    if (el.styleBinding) {
      data += "style:(" + (el.styleBinding) + "),";
    }
    return data
  }

  var style$1 = {
    staticKeys: ['staticStyle'],
    transformNode: transformNode$1,
    genData: genData$1
  };

  /*  */

  var decoder;

  var he = {
    decode: function decode (html) {
      decoder = decoder || document.createElement('div');
      decoder.innerHTML = html;
      return decoder.textContent
    }
  };

  /*  */

  var isUnaryTag = makeMap(
    'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
    'link,meta,param,source,track,wbr'
  );

  // Elements that you can, intentionally, leave open
  // (and which close themselves)
  var canBeLeftOpenTag = makeMap(
    'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
  );

  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
  var isNonPhrasingTag = makeMap(
    'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
    'title,tr,track'
  );

  /**
   * Not type-checking this file because it's mostly vendor code.
   */

  // Regular Expressions for parsing tags and attributes
  var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
  var dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
  var ncname = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + (unicodeRegExp.source) + "]*";
  var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
  var startTagOpen = new RegExp(("^<" + qnameCapture));
  var startTagClose = /^\s*(\/?)>/;
  var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
  var doctype = /^<!DOCTYPE [^>]+>/i;
  // #7298: escape - to avoid being passed as HTML comment when inlined in page
  var comment = /^<!\--/;
  var conditionalComment = /^<!\[/;

  // Special Elements (can contain anything)
  var isPlainTextElement = makeMap('script,style,textarea', true);
  var reCache = {};

  var decodingMap = {
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&amp;': '&',
    '&#10;': '\n',
    '&#9;': '\t',
    '&#39;': "'"
  };
  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;

  // #5992
  var isIgnoreNewlineTag = makeMap('pre,textarea', true);
  var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

  function decodeAttr (value, shouldDecodeNewlines) {
    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
    return value.replace(re, function (match) { return decodingMap[match]; })
  }

  function parseHTML (html, options) {
    var stack = [];
    var expectHTML = options.expectHTML;
    var isUnaryTag$$1 = options.isUnaryTag || no;
    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
    var index = 0;
    var last, lastTag;
    while (html) {
      last = html;
      // Make sure we're not in a plaintext content element like script/style
      if (!lastTag || !isPlainTextElement(lastTag)) {
        var textEnd = html.indexOf('<');
        if (textEnd === 0) {
          // Comment:
          if (comment.test(html)) {
            var commentEnd = html.indexOf('-->');

            if (commentEnd >= 0) {
              if (options.shouldKeepComment) {
                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
              }
              advance(commentEnd + 3);
              continue
            }
          }

          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
          if (conditionalComment.test(html)) {
            var conditionalEnd = html.indexOf(']>');

            if (conditionalEnd >= 0) {
              advance(conditionalEnd + 2);
              continue
            }
          }

          // Doctype:
          var doctypeMatch = html.match(doctype);
          if (doctypeMatch) {
            advance(doctypeMatch[0].length);
            continue
          }

          // End tag:
          var endTagMatch = html.match(endTag);
          if (endTagMatch) {
            var curIndex = index;
            advance(endTagMatch[0].length);
            parseEndTag(endTagMatch[1], curIndex, index);
            continue
          }

          // Start tag:
          var startTagMatch = parseStartTag();
          if (startTagMatch) {
            handleStartTag(startTagMatch);
            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
              advance(1);
            }
            continue
          }
        }

        var text = (void 0), rest = (void 0), next = (void 0);
        if (textEnd >= 0) {
          rest = html.slice(textEnd);
          while (
            !endTag.test(rest) &&
            !startTagOpen.test(rest) &&
            !comment.test(rest) &&
            !conditionalComment.test(rest)
          ) {
            // < in plain text, be forgiving and treat it as text
            next = rest.indexOf('<', 1);
            if (next < 0) { break }
            textEnd += next;
            rest = html.slice(textEnd);
          }
          text = html.substring(0, textEnd);
        }

        if (textEnd < 0) {
          text = html;
        }

        if (text) {
          advance(text.length);
        }

        if (options.chars && text) {
          options.chars(text, index - text.length, index);
        }
      } else {
        var endTagLength = 0;
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
          endTagLength = endTag.length;
          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
            text = text
              .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
              .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
          }
          if (shouldIgnoreFirstNewline(stackedTag, text)) {
            text = text.slice(1);
          }
          if (options.chars) {
            options.chars(text);
          }
          return ''
        });
        index += html.length - rest$1.length;
        html = rest$1;
        parseEndTag(stackedTag, index - endTagLength, index);
      }

      if (html === last) {
        options.chars && options.chars(html);
        if (!stack.length && options.warn) {
          options.warn(("Mal-formatted tag at end of template: \"" + html + "\""), { start: index + html.length });
        }
        break
      }
    }

    // Clean up any remaining tags
    parseEndTag();

    function advance (n) {
      index += n;
      html = html.substring(n);
    }

    function parseStartTag () {
      var start = html.match(startTagOpen);
      if (start) {
        var match = {
          tagName: start[1],
          attrs: [],
          start: index
        };
        advance(start[0].length);
        var end, attr;
        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
          attr.start = index;
          advance(attr[0].length);
          attr.end = index;
          match.attrs.push(attr);
        }
        if (end) {
          match.unarySlash = end[1];
          advance(end[0].length);
          match.end = index;
          return match
        }
      }
    }

    function handleStartTag (match) {
      var tagName = match.tagName;
      var unarySlash = match.unarySlash;

      if (expectHTML) {
        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
          parseEndTag(lastTag);
        }
        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
          parseEndTag(tagName);
        }
      }

      var unary = isUnaryTag$$1(tagName) || !!unarySlash;

      var l = match.attrs.length;
      var attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        var args = match.attrs[i];
        var value = args[3] || args[4] || args[5] || '';
        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
          ? options.shouldDecodeNewlinesForHref
          : options.shouldDecodeNewlines;
        attrs[i] = {
          name: args[1],
          value: decodeAttr(value, shouldDecodeNewlines)
        };
        if (options.outputSourceRange) {
          attrs[i].start = args.start + args[0].match(/^\s*/).length;
          attrs[i].end = args.end;
        }
      }

      if (!unary) {
        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });
        lastTag = tagName;
      }

      if (options.start) {
        options.start(tagName, attrs, unary, match.start, match.end);
      }
    }

    function parseEndTag (tagName, start, end) {
      var pos, lowerCasedTagName;
      if (start == null) { start = index; }
      if (end == null) { end = index; }

      // Find the closest opened tag of the same type
      if (tagName) {
        lowerCasedTagName = tagName.toLowerCase();
        for (pos = stack.length - 1; pos >= 0; pos--) {
          if (stack[pos].lowerCasedTag === lowerCasedTagName) {
            break
          }
        }
      } else {
        // If no tag name is provided, clean shop
        pos = 0;
      }

      if (pos >= 0) {
        // Close all the open elements, up the stack
        for (var i = stack.length - 1; i >= pos; i--) {
          if (i > pos || !tagName &&
            options.warn
          ) {
            options.warn(
              ("tag <" + (stack[i].tag) + "> has no matching end tag."),
              { start: stack[i].start, end: stack[i].end }
            );
          }
          if (options.end) {
            options.end(stack[i].tag, start, end);
          }
        }

        // Remove the open elements from the stack
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (lowerCasedTagName === 'br') {
        if (options.start) {
          options.start(tagName, [], true, start, end);
        }
      } else if (lowerCasedTagName === 'p') {
        if (options.start) {
          options.start(tagName, [], false, start, end);
        }
        if (options.end) {
          options.end(tagName, start, end);
        }
      }
    }
  }

  /*  */

  var onRE = /^@|^v-on:/;
  var dirRE = /^v-|^@|^:|^#/;
  var forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
  var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  var stripParensRE = /^\(|\)$/g;
  var dynamicArgRE = /^\[.*\]$/;

  var argRE = /:(.*)$/;
  var bindRE = /^:|^\.|^v-bind:/;
  var modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;

  var slotRE = /^v-slot(:|$)|^#/;

  var lineBreakRE = /[\r\n]/;
  var whitespaceRE$1 = /[ \f\t\r\n]+/g;

  var invalidAttributeRE = /[\s"'<>\/=]/;

  var decodeHTMLCached = cached(he.decode);

  var emptySlotScopeToken = "_empty_";

  // configurable state
  var warn$2;
  var delimiters;
  var transforms;
  var preTransforms;
  var postTransforms;
  var platformIsPreTag;
  var platformMustUseProp;
  var platformGetTagNamespace;
  var maybeComponent;

  function createASTElement (
    tag,
    attrs,
    parent
  ) {
    return {
      type: 1,
      tag: tag,
      attrsList: attrs,
      attrsMap: makeAttrsMap(attrs),
      rawAttrsMap: {},
      parent: parent,
      children: []
    }
  }

  /**
   * Convert HTML string to AST.
   */
  function parse (
    template,
    options
  ) {
    warn$2 = options.warn || baseWarn;

    platformIsPreTag = options.isPreTag || no;
    platformMustUseProp = options.mustUseProp || no;
    platformGetTagNamespace = options.getTagNamespace || no;
    var isReservedTag = options.isReservedTag || no;
    maybeComponent = function (el) { return !!(
      el.component ||
      el.attrsMap[':is'] ||
      el.attrsMap['v-bind:is'] ||
      !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag))
    ); };
    transforms = pluckModuleFunction(options.modules, 'transformNode');
    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

    delimiters = options.delimiters;

    var stack = [];
    var preserveWhitespace = options.preserveWhitespace !== false;
    var whitespaceOption = options.whitespace;
    var root;
    var currentParent;
    var inVPre = false;
    var inPre = false;
    var warned = false;

    function warnOnce (msg, range) {
      if (!warned) {
        warned = true;
        warn$2(msg, range);
      }
    }

    function closeElement (element) {
      trimEndingWhitespace(element);
      if (!inVPre && !element.processed) {
        element = processElement(element, options);
      }
      // tree management
      if (!stack.length && element !== root) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          {
            checkRootConstraints(element);
          }
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else {
          warnOnce(
            "Component template should contain exactly one root element. " +
            "If you are using v-if on multiple elements, " +
            "use v-else-if to chain them instead.",
            { start: element.start }
          );
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else {
          if (element.slotScope) {
            // scoped slot
            // keep it in the children list so that v-else(-if) conditions can
            // find it as the prev node.
            var name = element.slotTarget || '"default"'
            ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
          }
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }

      // final children cleanup
      // filter out scoped slots
      element.children = element.children.filter(function (c) { return !(c).slotScope; });
      // remove trailing whitespace node again
      trimEndingWhitespace(element);

      // check pre state
      if (element.pre) {
        inVPre = false;
      }
      if (platformIsPreTag(element.tag)) {
        inPre = false;
      }
      // apply post-transforms
      for (var i = 0; i < postTransforms.length; i++) {
        postTransforms[i](element, options);
      }
    }

    function trimEndingWhitespace (el) {
      // remove trailing whitespace node
      if (!inPre) {
        var lastNode;
        while (
          (lastNode = el.children[el.children.length - 1]) &&
          lastNode.type === 3 &&
          lastNode.text === ' '
        ) {
          el.children.pop();
        }
      }
    }

    function checkRootConstraints (el) {
      if (el.tag === 'slot' || el.tag === 'template') {
        warnOnce(
          "Cannot use <" + (el.tag) + "> as component root element because it may " +
          'contain multiple nodes.',
          { start: el.start }
        );
      }
      if (el.attrsMap.hasOwnProperty('v-for')) {
        warnOnce(
          'Cannot use v-for on stateful component root element because ' +
          'it renders multiple elements.',
          el.rawAttrsMap['v-for']
        );
      }
    }

    parseHTML(template, {
      warn: warn$2,
      expectHTML: options.expectHTML,
      isUnaryTag: options.isUnaryTag,
      canBeLeftOpenTag: options.canBeLeftOpenTag,
      shouldDecodeNewlines: options.shouldDecodeNewlines,
      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
      shouldKeepComment: options.comments,
      outputSourceRange: options.outputSourceRange,
      start: function start (tag, attrs, unary, start$1, end) {
        // check namespace.
        // inherit parent ns if there is one
        var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

        // handle IE svg bug
        /* istanbul ignore if */
        if (isIE && ns === 'svg') {
          attrs = guardIESVGBug(attrs);
        }

        var element = createASTElement(tag, attrs, currentParent);
        if (ns) {
          element.ns = ns;
        }

        {
          if (options.outputSourceRange) {
            element.start = start$1;
            element.end = end;
            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {
              cumulated[attr.name] = attr;
              return cumulated
            }, {});
          }
          attrs.forEach(function (attr) {
            if (invalidAttributeRE.test(attr.name)) {
              warn$2(
                "Invalid dynamic argument expression: attribute names cannot contain " +
                "spaces, quotes, <, >, / or =.",
                {
                  start: attr.start + attr.name.indexOf("["),
                  end: attr.start + attr.name.length
                }
              );
            }
          });
        }

        if (isForbiddenTag(element) && !isServerRendering()) {
          element.forbidden = true;
          warn$2(
            'Templates should only be responsible for mapping the state to the ' +
            'UI. Avoid placing tags with side-effects in your templates, such as ' +
            "<" + tag + ">" + ', as they will not be parsed.',
            { start: element.start }
          );
        }

        // apply pre-transforms
        for (var i = 0; i < preTransforms.length; i++) {
          element = preTransforms[i](element, options) || element;
        }

        if (!inVPre) {
          processPre(element);
          if (element.pre) {
            inVPre = true;
          }
        }
        if (platformIsPreTag(element.tag)) {
          inPre = true;
        }
        if (inVPre) {
          processRawAttrs(element);
        } else if (!element.processed) {
          // structural directives
          processFor(element);
          processIf(element);
          processOnce(element);
        }

        if (!root) {
          root = element;
          {
            checkRootConstraints(root);
          }
        }

        if (!unary) {
          currentParent = element;
          stack.push(element);
        } else {
          closeElement(element);
        }
      },

      end: function end (tag, start, end$1) {
        var element = stack[stack.length - 1];
        // pop stack
        stack.length -= 1;
        currentParent = stack[stack.length - 1];
        if (options.outputSourceRange) {
          element.end = end$1;
        }
        closeElement(element);
      },

      chars: function chars (text, start, end) {
        if (!currentParent) {
          {
            if (text === template) {
              warnOnce(
                'Component template requires a root element, rather than just text.',
                { start: start }
              );
            } else if ((text = text.trim())) {
              warnOnce(
                ("text \"" + text + "\" outside root element will be ignored."),
                { start: start }
              );
            }
          }
          return
        }
        // IE textarea placeholder bug
        /* istanbul ignore if */
        if (isIE &&
          currentParent.tag === 'textarea' &&
          currentParent.attrsMap.placeholder === text
        ) {
          return
        }
        var children = currentParent.children;
        if (inPre || text.trim()) {
          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);
        } else if (!children.length) {
          // remove the whitespace-only node right after an opening tag
          text = '';
        } else if (whitespaceOption) {
          if (whitespaceOption === 'condense') {
            // in condense mode, remove the whitespace node if it contains
            // line break, otherwise condense to a single space
            text = lineBreakRE.test(text) ? '' : ' ';
          } else {
            text = ' ';
          }
        } else {
          text = preserveWhitespace ? ' ' : '';
        }
        if (text) {
          if (!inPre && whitespaceOption === 'condense') {
            // condense consecutive whitespaces into single space
            text = text.replace(whitespaceRE$1, ' ');
          }
          var res;
          var child;
          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
            child = {
              type: 2,
              expression: res.expression,
              tokens: res.tokens,
              text: text
            };
          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
            child = {
              type: 3,
              text: text
            };
          }
          if (child) {
            if (options.outputSourceRange) {
              child.start = start;
              child.end = end;
            }
            children.push(child);
          }
        }
      },
      comment: function comment (text, start, end) {
        // adding anything as a sibling to the root node is forbidden
        // comments should still be allowed, but ignored
        if (currentParent) {
          var child = {
            type: 3,
            text: text,
            isComment: true
          };
          if (options.outputSourceRange) {
            child.start = start;
            child.end = end;
          }
          currentParent.children.push(child);
        }
      }
    });
    return root
  }

  function processPre (el) {
    if (getAndRemoveAttr(el, 'v-pre') != null) {
      el.pre = true;
    }
  }

  function processRawAttrs (el) {
    var list = el.attrsList;
    var len = list.length;
    if (len) {
      var attrs = el.attrs = new Array(len);
      for (var i = 0; i < len; i++) {
        attrs[i] = {
          name: list[i].name,
          value: JSON.stringify(list[i].value)
        };
        if (list[i].start != null) {
          attrs[i].start = list[i].start;
          attrs[i].end = list[i].end;
        }
      }
    } else if (!el.pre) {
      // non root node in pre blocks with no attributes
      el.plain = true;
    }
  }

  function processElement (
    element,
    options
  ) {
    processKey(element);

    // determine whether this is a plain element after
    // removing structural attributes
    element.plain = (
      !element.key &&
      !element.scopedSlots &&
      !element.attrsList.length
    );

    processRef(element);
    processSlotContent(element);
    processSlotOutlet(element);
    processComponent(element);
    for (var i = 0; i < transforms.length; i++) {
      element = transforms[i](element, options) || element;
    }
    processAttrs(element);
    return element
  }

  function processKey (el) {
    var exp = getBindingAttr(el, 'key');
    if (exp) {
      {
        if (el.tag === 'template') {
          warn$2(
            "<template> cannot be keyed. Place the key on real elements instead.",
            getRawBindingAttr(el, 'key')
          );
        }
        if (el.for) {
          var iterator = el.iterator2 || el.iterator1;
          var parent = el.parent;
          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {
            warn$2(
              "Do not use v-for index as key on <transition-group> children, " +
              "this is the same as not using keys.",
              getRawBindingAttr(el, 'key'),
              true /* tip */
            );
          }
        }
      }
      el.key = exp;
    }
  }

  function processRef (el) {
    var ref = getBindingAttr(el, 'ref');
    if (ref) {
      el.ref = ref;
      el.refInFor = checkInFor(el);
    }
  }

  function processFor (el) {
    var exp;
    if ((exp = getAndRemoveAttr(el, 'v-for'))) {
      var res = parseFor(exp);
      if (res) {
        extend(el, res);
      } else {
        warn$2(
          ("Invalid v-for expression: " + exp),
          el.rawAttrsMap['v-for']
        );
      }
    }
  }



  function parseFor (exp) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) { return }
    var res = {};
    res.for = inMatch[2].trim();
    var alias = inMatch[1].trim().replace(stripParensRE, '');
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      res.alias = alias.replace(forIteratorRE, '').trim();
      res.iterator1 = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.iterator2 = iteratorMatch[2].trim();
      }
    } else {
      res.alias = alias;
    }
    return res
  }

  function processIf (el) {
    var exp = getAndRemoveAttr(el, 'v-if');
    if (exp) {
      el.if = exp;
      addIfCondition(el, {
        exp: exp,
        block: el
      });
    } else {
      if (getAndRemoveAttr(el, 'v-else') != null) {
        el.else = true;
      }
      var elseif = getAndRemoveAttr(el, 'v-else-if');
      if (elseif) {
        el.elseif = elseif;
      }
    }
  }

  function processIfConditions (el, parent) {
    var prev = findPrevElement(parent.children);
    if (prev && prev.if) {
      addIfCondition(prev, {
        exp: el.elseif,
        block: el
      });
    } else {
      warn$2(
        "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
        "used on element <" + (el.tag) + "> without corresponding v-if.",
        el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']
      );
    }
  }

  function findPrevElement (children) {
    var i = children.length;
    while (i--) {
      if (children[i].type === 1) {
        return children[i]
      } else {
        if (children[i].text !== ' ') {
          warn$2(
            "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
            "will be ignored.",
            children[i]
          );
        }
        children.pop();
      }
    }
  }

  function addIfCondition (el, condition) {
    if (!el.ifConditions) {
      el.ifConditions = [];
    }
    el.ifConditions.push(condition);
  }

  function processOnce (el) {
    var once$$1 = getAndRemoveAttr(el, 'v-once');
    if (once$$1 != null) {
      el.once = true;
    }
  }

  // handle content being passed to a component as slot,
  // e.g. <template slot="xxx">, <div slot-scope="xxx">
  function processSlotContent (el) {
    var slotScope;
    if (el.tag === 'template') {
      slotScope = getAndRemoveAttr(el, 'scope');
      /* istanbul ignore if */
      if (slotScope) {
        warn$2(
          "the \"scope\" attribute for scoped slots have been deprecated and " +
          "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
          "can also be used on plain elements in addition to <template> to " +
          "denote scoped slots.",
          el.rawAttrsMap['scope'],
          true
        );
      }
      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
      /* istanbul ignore if */
      if (el.attrsMap['v-for']) {
        warn$2(
          "Ambiguous combined usage of slot-scope and v-for on <" + (el.tag) + "> " +
          "(v-for takes higher priority). Use a wrapper <template> for the " +
          "scoped slot to make it clearer.",
          el.rawAttrsMap['slot-scope'],
          true
        );
      }
      el.slotScope = slotScope;
    }

    // slot="xxx"
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
      // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.
      if (el.tag !== 'template' && !el.slotScope) {
        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
      }
    }

    // 2.6 v-slot syntax
    {
      if (el.tag === 'template') {
        // v-slot on <template>
        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);
        if (slotBinding) {
          {
            if (el.slotTarget || el.slotScope) {
              warn$2(
                "Unexpected mixed usage of different slot syntaxes.",
                el
              );
            }
            if (el.parent && !maybeComponent(el.parent)) {
              warn$2(
                "<template v-slot> can only appear at the root level inside " +
                "the receiving component",
                el
              );
            }
          }
          var ref = getSlotName(slotBinding);
          var name = ref.name;
          var dynamic = ref.dynamic;
          el.slotTarget = name;
          el.slotTargetDynamic = dynamic;
          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
        }
      } else {
        // v-slot on component, denotes default slot
        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);
        if (slotBinding$1) {
          {
            if (!maybeComponent(el)) {
              warn$2(
                "v-slot can only be used on components or <template>.",
                slotBinding$1
              );
            }
            if (el.slotScope || el.slotTarget) {
              warn$2(
                "Unexpected mixed usage of different slot syntaxes.",
                el
              );
            }
            if (el.scopedSlots) {
              warn$2(
                "To avoid scope ambiguity, the default slot should also use " +
                "<template> syntax when there are other named slots.",
                slotBinding$1
              );
            }
          }
          // add the component's children to its default slot
          var slots = el.scopedSlots || (el.scopedSlots = {});
          var ref$1 = getSlotName(slotBinding$1);
          var name$1 = ref$1.name;
          var dynamic$1 = ref$1.dynamic;
          var slotContainer = slots[name$1] = createASTElement('template', [], el);
          slotContainer.slotTarget = name$1;
          slotContainer.slotTargetDynamic = dynamic$1;
          slotContainer.children = el.children.filter(function (c) {
            if (!c.slotScope) {
              c.parent = slotContainer;
              return true
            }
          });
          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;
          // remove children as they are returned from scopedSlots now
          el.children = [];
          // mark el non-plain so data gets generated
          el.plain = false;
        }
      }
    }
  }

  function getSlotName (binding) {
    var name = binding.name.replace(slotRE, '');
    if (!name) {
      if (binding.name[0] !== '#') {
        name = 'default';
      } else {
        warn$2(
          "v-slot shorthand syntax requires a slot name.",
          binding
        );
      }
    }
    return dynamicArgRE.test(name)
      // dynamic [name]
      ? { name: name.slice(1, -1), dynamic: true }
      // static name
      : { name: ("\"" + name + "\""), dynamic: false }
  }

  // handle <slot/> outlets
  function processSlotOutlet (el) {
    if (el.tag === 'slot') {
      el.slotName = getBindingAttr(el, 'name');
      if (el.key) {
        warn$2(
          "`key` does not work on <slot> because slots are abstract outlets " +
          "and can possibly expand into multiple elements. " +
          "Use the key on a wrapping element instead.",
          getRawBindingAttr(el, 'key')
        );
      }
    }
  }

  function processComponent (el) {
    var binding;
    if ((binding = getBindingAttr(el, 'is'))) {
      el.component = binding;
    }
    if (getAndRemoveAttr(el, 'inline-template') != null) {
      el.inlineTemplate = true;
    }
  }

  function processAttrs (el) {
    var list = el.attrsList;
    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;
    for (i = 0, l = list.length; i < l; i++) {
      name = rawName = list[i].name;
      value = list[i].value;
      if (dirRE.test(name)) {
        // mark element as dynamic
        el.hasBindings = true;
        // modifiers
        modifiers = parseModifiers(name.replace(dirRE, ''));
        // support .foo shorthand syntax for the .prop modifier
        if (modifiers) {
          name = name.replace(modifierRE, '');
        }
        if (bindRE.test(name)) { // v-bind
          name = name.replace(bindRE, '');
          value = parseFilters(value);
          isDynamic = dynamicArgRE.test(name);
          if (isDynamic) {
            name = name.slice(1, -1);
          }
          if (
            value.trim().length === 0
          ) {
            warn$2(
              ("The value for a v-bind expression cannot be empty. Found in \"v-bind:" + name + "\"")
            );
          }
          if (modifiers) {
            if (modifiers.prop && !isDynamic) {
              name = camelize(name);
              if (name === 'innerHtml') { name = 'innerHTML'; }
            }
            if (modifiers.camel && !isDynamic) {
              name = camelize(name);
            }
            if (modifiers.sync) {
              syncGen = genAssignmentCode(value, "$event");
              if (!isDynamic) {
                addHandler(
                  el,
                  ("update:" + (camelize(name))),
                  syncGen,
                  null,
                  false,
                  warn$2,
                  list[i]
                );
                if (hyphenate(name) !== camelize(name)) {
                  addHandler(
                    el,
                    ("update:" + (hyphenate(name))),
                    syncGen,
                    null,
                    false,
                    warn$2,
                    list[i]
                  );
                }
              } else {
                // handler w/ dynamic event name
                addHandler(
                  el,
                  ("\"update:\"+(" + name + ")"),
                  syncGen,
                  null,
                  false,
                  warn$2,
                  list[i],
                  true // dynamic
                );
              }
            }
          }
          if ((modifiers && modifiers.prop) || (
            !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
          )) {
            addProp(el, name, value, list[i], isDynamic);
          } else {
            addAttr(el, name, value, list[i], isDynamic);
          }
        } else if (onRE.test(name)) { // v-on
          name = name.replace(onRE, '');
          isDynamic = dynamicArgRE.test(name);
          if (isDynamic) {
            name = name.slice(1, -1);
          }
          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);
        } else { // normal directives
          name = name.replace(dirRE, '');
          // parse arg
          var argMatch = name.match(argRE);
          var arg = argMatch && argMatch[1];
          isDynamic = false;
          if (arg) {
            name = name.slice(0, -(arg.length + 1));
            if (dynamicArgRE.test(arg)) {
              arg = arg.slice(1, -1);
              isDynamic = true;
            }
          }
          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
          if (name === 'model') {
            checkForAliasModel(el, value);
          }
        }
      } else {
        // literal attribute
        {
          var res = parseText(value, delimiters);
          if (res) {
            warn$2(
              name + "=\"" + value + "\": " +
              'Interpolation inside attributes has been removed. ' +
              'Use v-bind or the colon shorthand instead. For example, ' +
              'instead of <div id="{{ val }}">, use <div :id="val">.',
              list[i]
            );
          }
        }
        addAttr(el, name, JSON.stringify(value), list[i]);
        // #6887 firefox doesn't update muted state if set via attribute
        // even immediately after element creation
        if (!el.component &&
            name === 'muted' &&
            platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, 'true', list[i]);
        }
      }
    }
  }

  function checkInFor (el) {
    var parent = el;
    while (parent) {
      if (parent.for !== undefined) {
        return true
      }
      parent = parent.parent;
    }
    return false
  }

  function parseModifiers (name) {
    var match = name.match(modifierRE);
    if (match) {
      var ret = {};
      match.forEach(function (m) { ret[m.slice(1)] = true; });
      return ret
    }
  }

  function makeAttrsMap (attrs) {
    var map = {};
    for (var i = 0, l = attrs.length; i < l; i++) {
      if (
        map[attrs[i].name] && !isIE && !isEdge
      ) {
        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);
      }
      map[attrs[i].name] = attrs[i].value;
    }
    return map
  }

  // for script (e.g. type="x/template") or style, do not decode content
  function isTextTag (el) {
    return el.tag === 'script' || el.tag === 'style'
  }

  function isForbiddenTag (el) {
    return (
      el.tag === 'style' ||
      (el.tag === 'script' && (
        !el.attrsMap.type ||
        el.attrsMap.type === 'text/javascript'
      ))
    )
  }

  var ieNSBug = /^xmlns:NS\d+/;
  var ieNSPrefix = /^NS\d+:/;

  /* istanbul ignore next */
  function guardIESVGBug (attrs) {
    var res = [];
    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];
      if (!ieNSBug.test(attr.name)) {
        attr.name = attr.name.replace(ieNSPrefix, '');
        res.push(attr);
      }
    }
    return res
  }

  function checkForAliasModel (el, value) {
    var _el = el;
    while (_el) {
      if (_el.for && _el.alias === value) {
        warn$2(
          "<" + (el.tag) + " v-model=\"" + value + "\">: " +
          "You are binding v-model directly to a v-for iteration alias. " +
          "This will not be able to modify the v-for source array because " +
          "writing to the alias is like modifying a function local variable. " +
          "Consider using an array of objects and use v-model on an object property instead.",
          el.rawAttrsMap['v-model']
        );
      }
      _el = _el.parent;
    }
  }

  /*  */

  function preTransformNode (el, options) {
    if (el.tag === 'input') {
      var map = el.attrsMap;
      if (!map['v-model']) {
        return
      }

      var typeBinding;
      if (map[':type'] || map['v-bind:type']) {
        typeBinding = getBindingAttr(el, 'type');
      }
      if (!map.type && !typeBinding && map['v-bind']) {
        typeBinding = "(" + (map['v-bind']) + ").type";
      }

      if (typeBinding) {
        var ifCondition = getAndRemoveAttr(el, 'v-if', true);
        var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
        // 1. checkbox
        var branch0 = cloneASTElement(el);
        // process for on the main node
        processFor(branch0);
        addRawAttr(branch0, 'type', 'checkbox');
        processElement(branch0, options);
        branch0.processed = true; // prevent it from double-processed
        branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
        addIfCondition(branch0, {
          exp: branch0.if,
          block: branch0
        });
        // 2. add radio else-if condition
        var branch1 = cloneASTElement(el);
        getAndRemoveAttr(branch1, 'v-for', true);
        addRawAttr(branch1, 'type', 'radio');
        processElement(branch1, options);
        addIfCondition(branch0, {
          exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
          block: branch1
        });
        // 3. other
        var branch2 = cloneASTElement(el);
        getAndRemoveAttr(branch2, 'v-for', true);
        addRawAttr(branch2, ':type', typeBinding);
        processElement(branch2, options);
        addIfCondition(branch0, {
          exp: ifCondition,
          block: branch2
        });

        if (hasElse) {
          branch0.else = true;
        } else if (elseIfCondition) {
          branch0.elseif = elseIfCondition;
        }

        return branch0
      }
    }
  }

  function cloneASTElement (el) {
    return createASTElement(el.tag, el.attrsList.slice(), el.parent)
  }

  var model$1 = {
    preTransformNode: preTransformNode
  };

  var modules$1 = [
    klass$1,
    style$1,
    model$1
  ];

  /*  */

  function text (el, dir) {
    if (dir.value) {
      addProp(el, 'textContent', ("_s(" + (dir.value) + ")"), dir);
    }
  }

  /*  */

  function html (el, dir) {
    if (dir.value) {
      addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"), dir);
    }
  }

  var directives$1 = {
    model: model,
    text: text,
    html: html
  };

  /*  */

  var baseOptions = {
    expectHTML: true,
    modules: modules$1,
    directives: directives$1,
    isPreTag: isPreTag,
    isUnaryTag: isUnaryTag,
    mustUseProp: mustUseProp,
    canBeLeftOpenTag: canBeLeftOpenTag,
    isReservedTag: isReservedTag,
    getTagNamespace: getTagNamespace,
    staticKeys: genStaticKeys(modules$1)
  };

  /*  */

  var isStaticKey;
  var isPlatformReservedTag;

  var genStaticKeysCached = cached(genStaticKeys$1);

  /**
   * Goal of the optimizer: walk the generated template AST tree
   * and detect sub-trees that are purely static, i.e. parts of
   * the DOM that never needs to change.
   *
   * Once we detect these sub-trees, we can:
   *
   * 1. Hoist them into constants, so that we no longer need to
   *    create fresh nodes for them on each re-render;
   * 2. Completely skip them in the patching process.
   */
  function optimize (root, options) {
    if (!root) { return }
    isStaticKey = genStaticKeysCached(options.staticKeys || '');
    isPlatformReservedTag = options.isReservedTag || no;
    // first pass: mark all non-static nodes.
    markStatic$1(root);
    // second pass: mark static roots.
    markStaticRoots(root, false);
  }

  function genStaticKeys$1 (keys) {
    return makeMap(
      'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
      (keys ? ',' + keys : '')
    )
  }

  function markStatic$1 (node) {
    node.static = isStatic(node);
    if (node.type === 1) {
      // do not make component slot content static. this avoids
      // 1. components not able to mutate slot nodes
      // 2. static slot content fails for hot-reloading
      if (
        !isPlatformReservedTag(node.tag) &&
        node.tag !== 'slot' &&
        node.attrsMap['inline-template'] == null
      ) {
        return
      }
      for (var i = 0, l = node.children.length; i < l; i++) {
        var child = node.children[i];
        markStatic$1(child);
        if (!child.static) {
          node.static = false;
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          var block = node.ifConditions[i$1].block;
          markStatic$1(block);
          if (!block.static) {
            node.static = false;
          }
        }
      }
    }
  }

  function markStaticRoots (node, isInFor) {
    if (node.type === 1) {
      if (node.static || node.once) {
        node.staticInFor = isInFor;
      }
      // For a node to qualify as a static root, it should have children that
      // are not just static text. Otherwise the cost of hoisting out will
      // outweigh the benefits and it's better off to just always render it fresh.
      if (node.static && node.children.length && !(
        node.children.length === 1 &&
        node.children[0].type === 3
      )) {
        node.staticRoot = true;
        return
      } else {
        node.staticRoot = false;
      }
      if (node.children) {
        for (var i = 0, l = node.children.length; i < l; i++) {
          markStaticRoots(node.children[i], isInFor || !!node.for);
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          markStaticRoots(node.ifConditions[i$1].block, isInFor);
        }
      }
    }
  }

  function isStatic (node) {
    if (node.type === 2) { // expression
      return false
    }
    if (node.type === 3) { // text
      return true
    }
    return !!(node.pre || (
      !node.hasBindings && // no dynamic bindings
      !node.if && !node.for && // not v-if or v-for or v-else
      !isBuiltInTag(node.tag) && // not a built-in
      isPlatformReservedTag(node.tag) && // not a component
      !isDirectChildOfTemplateFor(node) &&
      Object.keys(node).every(isStaticKey)
    ))
  }

  function isDirectChildOfTemplateFor (node) {
    while (node.parent) {
      node = node.parent;
      if (node.tag !== 'template') {
        return false
      }
      if (node.for) {
        return true
      }
    }
    return false
  }

  /*  */

  var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
  var fnInvokeRE = /\([^)]*?\);*$/;
  var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

  // KeyboardEvent.keyCode aliases
  var keyCodes = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    'delete': [8, 46]
  };

  // KeyboardEvent.key aliases
  var keyNames = {
    // #7880: IE11 and Edge use `Esc` for Escape key name.
    esc: ['Esc', 'Escape'],
    tab: 'Tab',
    enter: 'Enter',
    // #9112: IE11 uses `Spacebar` for Space key name.
    space: [' ', 'Spacebar'],
    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
    up: ['Up', 'ArrowUp'],
    left: ['Left', 'ArrowLeft'],
    right: ['Right', 'ArrowRight'],
    down: ['Down', 'ArrowDown'],
    // #9112: IE11 uses `Del` for Delete key name.
    'delete': ['Backspace', 'Delete', 'Del']
  };

  // #4868: modifiers that prevent the execution of the listener
  // need to explicitly return null so that we can determine whether to remove
  // the listener for .once
  var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

  var modifierCode = {
    stop: '$event.stopPropagation();',
    prevent: '$event.preventDefault();',
    self: genGuard("$event.target !== $event.currentTarget"),
    ctrl: genGuard("!$event.ctrlKey"),
    shift: genGuard("!$event.shiftKey"),
    alt: genGuard("!$event.altKey"),
    meta: genGuard("!$event.metaKey"),
    left: genGuard("'button' in $event && $event.button !== 0"),
    middle: genGuard("'button' in $event && $event.button !== 1"),
    right: genGuard("'button' in $event && $event.button !== 2")
  };

  function genHandlers (
    events,
    isNative
  ) {
    var prefix = isNative ? 'nativeOn:' : 'on:';
    var staticHandlers = "";
    var dynamicHandlers = "";
    for (var name in events) {
      var handlerCode = genHandler(events[name]);
      if (events[name] && events[name].dynamic) {
        dynamicHandlers += name + "," + handlerCode + ",";
      } else {
        staticHandlers += "\"" + name + "\":" + handlerCode + ",";
      }
    }
    staticHandlers = "{" + (staticHandlers.slice(0, -1)) + "}";
    if (dynamicHandlers) {
      return prefix + "_d(" + staticHandlers + ",[" + (dynamicHandlers.slice(0, -1)) + "])"
    } else {
      return prefix + staticHandlers
    }
  }

  function genHandler (handler) {
    if (!handler) {
      return 'function(){}'
    }

    if (Array.isArray(handler)) {
      return ("[" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + "]")
    }

    var isMethodPath = simplePathRE.test(handler.value);
    var isFunctionExpression = fnExpRE.test(handler.value);
    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));

    if (!handler.modifiers) {
      if (isMethodPath || isFunctionExpression) {
        return handler.value
      }
      return ("function($event){" + (isFunctionInvocation ? ("return " + (handler.value)) : handler.value) + "}") // inline statement
    } else {
      var code = '';
      var genModifierCode = '';
      var keys = [];
      for (var key in handler.modifiers) {
        if (modifierCode[key]) {
          genModifierCode += modifierCode[key];
          // left/right
          if (keyCodes[key]) {
            keys.push(key);
          }
        } else if (key === 'exact') {
          var modifiers = (handler.modifiers);
          genModifierCode += genGuard(
            ['ctrl', 'shift', 'alt', 'meta']
              .filter(function (keyModifier) { return !modifiers[keyModifier]; })
              .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
              .join('||')
          );
        } else {
          keys.push(key);
        }
      }
      if (keys.length) {
        code += genKeyFilter(keys);
      }
      // Make sure modifiers like prevent and stop get executed after key filtering
      if (genModifierCode) {
        code += genModifierCode;
      }
      var handlerCode = isMethodPath
        ? ("return " + (handler.value) + ".apply(null, arguments)")
        : isFunctionExpression
          ? ("return (" + (handler.value) + ").apply(null, arguments)")
          : isFunctionInvocation
            ? ("return " + (handler.value))
            : handler.value;
      return ("function($event){" + code + handlerCode + "}")
    }
  }

  function genKeyFilter (keys) {
    return (
      // make sure the key filters only apply to KeyboardEvents
      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
      // key events that do not have keyCode property...
      "if(!$event.type.indexOf('key')&&" +
      (keys.map(genFilterCode).join('&&')) + ")return null;"
    )
  }

  function genFilterCode (key) {
    var keyVal = parseInt(key, 10);
    if (keyVal) {
      return ("$event.keyCode!==" + keyVal)
    }
    var keyCode = keyCodes[key];
    var keyName = keyNames[key];
    return (
      "_k($event.keyCode," +
      (JSON.stringify(key)) + "," +
      (JSON.stringify(keyCode)) + "," +
      "$event.key," +
      "" + (JSON.stringify(keyName)) +
      ")"
    )
  }

  /*  */

  function on (el, dir) {
    if (dir.modifiers) {
      warn("v-on without argument does not support modifiers.");
    }
    el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
  }

  /*  */

  function bind$1 (el, dir) {
    el.wrapData = function (code) {
      return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
    };
  }

  /*  */

  var baseDirectives = {
    on: on,
    bind: bind$1,
    cloak: noop
  };

  /*  */





  var CodegenState = function CodegenState (options) {
    this.options = options;
    this.warn = options.warn || baseWarn;
    this.transforms = pluckModuleFunction(options.modules, 'transformCode');
    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
    this.directives = extend(extend({}, baseDirectives), options.directives);
    var isReservedTag = options.isReservedTag || no;
    this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };
    this.onceId = 0;
    this.staticRenderFns = [];
    this.pre = false;
  };



  function generate (
    ast,
    options
  ) {
    var state = new CodegenState(options);
    // fix #11483, Root level <script> tags should not be rendered.
    var code = ast ? (ast.tag === 'script' ? 'null' : genElement(ast, state)) : '_c("div")';
    return {
      render: ("with(this){return " + code + "}"),
      staticRenderFns: state.staticRenderFns
    }
  }

  function genElement (el, state) {
    if (el.parent) {
      el.pre = el.pre || el.parent.pre;
    }

    if (el.staticRoot && !el.staticProcessed) {
      return genStatic(el, state)
    } else if (el.once && !el.onceProcessed) {
      return genOnce(el, state)
    } else if (el.for && !el.forProcessed) {
      return genFor(el, state)
    } else if (el.if && !el.ifProcessed) {
      return genIf(el, state)
    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
      return genChildren(el, state) || 'void 0'
    } else if (el.tag === 'slot') {
      return genSlot(el, state)
    } else {
      // component or element
      var code;
      if (el.component) {
        code = genComponent(el.component, el, state);
      } else {
        var data;
        if (!el.plain || (el.pre && state.maybeComponent(el))) {
          data = genData$2(el, state);
        }

        var children = el.inlineTemplate ? null : genChildren(el, state, true);
        code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
      }
      // module transforms
      for (var i = 0; i < state.transforms.length; i++) {
        code = state.transforms[i](el, code);
      }
      return code
    }
  }

  // hoist static sub-trees out
  function genStatic (el, state) {
    el.staticProcessed = true;
    // Some elements (templates) need to behave differently inside of a v-pre
    // node.  All pre nodes are static roots, so we can use this as a location to
    // wrap a state change and reset it upon exiting the pre node.
    var originalPreState = state.pre;
    if (el.pre) {
      state.pre = el.pre;
    }
    state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
    state.pre = originalPreState;
    return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
  }

  // v-once
  function genOnce (el, state) {
    el.onceProcessed = true;
    if (el.if && !el.ifProcessed) {
      return genIf(el, state)
    } else if (el.staticInFor) {
      var key = '';
      var parent = el.parent;
      while (parent) {
        if (parent.for) {
          key = parent.key;
          break
        }
        parent = parent.parent;
      }
      if (!key) {
        state.warn(
          "v-once can only be used inside v-for that is keyed. ",
          el.rawAttrsMap['v-once']
        );
        return genElement(el, state)
      }
      return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
    } else {
      return genStatic(el, state)
    }
  }

  function genIf (
    el,
    state,
    altGen,
    altEmpty
  ) {
    el.ifProcessed = true; // avoid recursion
    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
  }

  function genIfConditions (
    conditions,
    state,
    altGen,
    altEmpty
  ) {
    if (!conditions.length) {
      return altEmpty || '_e()'
    }

    var condition = conditions.shift();
    if (condition.exp) {
      return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
    } else {
      return ("" + (genTernaryExp(condition.block)))
    }

    // v-if with v-once should generate code like (a)?_m(0):_m(1)
    function genTernaryExp (el) {
      return altGen
        ? altGen(el, state)
        : el.once
          ? genOnce(el, state)
          : genElement(el, state)
    }
  }

  function genFor (
    el,
    state,
    altGen,
    altHelper
  ) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
    var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

    if (state.maybeComponent(el) &&
      el.tag !== 'slot' &&
      el.tag !== 'template' &&
      !el.key
    ) {
      state.warn(
        "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
        "v-for should have explicit keys. " +
        "See https://vuejs.org/guide/list.html#key for more info.",
        el.rawAttrsMap['v-for'],
        true /* tip */
      );
    }

    el.forProcessed = true; // avoid recursion
    return (altHelper || '_l') + "((" + exp + ")," +
      "function(" + alias + iterator1 + iterator2 + "){" +
        "return " + ((altGen || genElement)(el, state)) +
      '})'
  }

  function genData$2 (el, state) {
    var data = '{';

    // directives first.
    // directives may mutate the el's other properties before they are generated.
    var dirs = genDirectives(el, state);
    if (dirs) { data += dirs + ','; }

    // key
    if (el.key) {
      data += "key:" + (el.key) + ",";
    }
    // ref
    if (el.ref) {
      data += "ref:" + (el.ref) + ",";
    }
    if (el.refInFor) {
      data += "refInFor:true,";
    }
    // pre
    if (el.pre) {
      data += "pre:true,";
    }
    // record original tag name for components using "is" attribute
    if (el.component) {
      data += "tag:\"" + (el.tag) + "\",";
    }
    // module data generation functions
    for (var i = 0; i < state.dataGenFns.length; i++) {
      data += state.dataGenFns[i](el);
    }
    // attributes
    if (el.attrs) {
      data += "attrs:" + (genProps(el.attrs)) + ",";
    }
    // DOM props
    if (el.props) {
      data += "domProps:" + (genProps(el.props)) + ",";
    }
    // event handlers
    if (el.events) {
      data += (genHandlers(el.events, false)) + ",";
    }
    if (el.nativeEvents) {
      data += (genHandlers(el.nativeEvents, true)) + ",";
    }
    // slot target
    // only for non-scoped slots
    if (el.slotTarget && !el.slotScope) {
      data += "slot:" + (el.slotTarget) + ",";
    }
    // scoped slots
    if (el.scopedSlots) {
      data += (genScopedSlots(el, el.scopedSlots, state)) + ",";
    }
    // component v-model
    if (el.model) {
      data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
    }
    // inline-template
    if (el.inlineTemplate) {
      var inlineTemplate = genInlineTemplate(el, state);
      if (inlineTemplate) {
        data += inlineTemplate + ",";
      }
    }
    data = data.replace(/,$/, '') + '}';
    // v-bind dynamic argument wrap
    // v-bind with dynamic arguments must be applied using the same v-bind object
    // merge helper so that class/style/mustUseProp attrs are handled correctly.
    if (el.dynamicAttrs) {
      data = "_b(" + data + ",\"" + (el.tag) + "\"," + (genProps(el.dynamicAttrs)) + ")";
    }
    // v-bind data wrap
    if (el.wrapData) {
      data = el.wrapData(data);
    }
    // v-on data wrap
    if (el.wrapListeners) {
      data = el.wrapListeners(data);
    }
    return data
  }

  function genDirectives (el, state) {
    var dirs = el.directives;
    if (!dirs) { return }
    var res = 'directives:[';
    var hasRuntime = false;
    var i, l, dir, needRuntime;
    for (i = 0, l = dirs.length; i < l; i++) {
      dir = dirs[i];
      needRuntime = true;
      var gen = state.directives[dir.name];
      if (gen) {
        // compile-time directive that manipulates AST.
        // returns true if it also needs a runtime counterpart.
        needRuntime = !!gen(el, dir, state.warn);
      }
      if (needRuntime) {
        hasRuntime = true;
        res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:" + (dir.isDynamicArg ? dir.arg : ("\"" + (dir.arg) + "\""))) : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
      }
    }
    if (hasRuntime) {
      return res.slice(0, -1) + ']'
    }
  }

  function genInlineTemplate (el, state) {
    var ast = el.children[0];
    if (el.children.length !== 1 || ast.type !== 1) {
      state.warn(
        'Inline-template components must have exactly one child element.',
        { start: el.start }
      );
    }
    if (ast && ast.type === 1) {
      var inlineRenderFns = generate(ast, state.options);
      return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
    }
  }

  function genScopedSlots (
    el,
    slots,
    state
  ) {
    // by default scoped slots are considered "stable", this allows child
    // components with only scoped slots to skip forced updates from parent.
    // but in some cases we have to bail-out of this optimization
    // for example if the slot contains dynamic names, has v-if or v-for on them...
    var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {
      var slot = slots[key];
      return (
        slot.slotTargetDynamic ||
        slot.if ||
        slot.for ||
        containsSlotChild(slot) // is passing down slot from parent which may be dynamic
      )
    });

    // #9534: if a component with scoped slots is inside a conditional branch,
    // it's possible for the same component to be reused but with different
    // compiled slot content. To avoid that, we generate a unique key based on
    // the generated code of all the slot contents.
    var needsKey = !!el.if;

    // OR when it is inside another scoped slot or v-for (the reactivity may be
    // disconnected due to the intermediate scope variable)
    // #9438, #9506
    // TODO: this can be further optimized by properly analyzing in-scope bindings
    // and skip force updating ones that do not actually use scope variables.
    if (!needsForceUpdate) {
      var parent = el.parent;
      while (parent) {
        if (
          (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||
          parent.for
        ) {
          needsForceUpdate = true;
          break
        }
        if (parent.if) {
          needsKey = true;
        }
        parent = parent.parent;
      }
    }

    var generatedSlots = Object.keys(slots)
      .map(function (key) { return genScopedSlot(slots[key], state); })
      .join(',');

    return ("scopedSlots:_u([" + generatedSlots + "]" + (needsForceUpdate ? ",null,true" : "") + (!needsForceUpdate && needsKey ? (",null,false," + (hash(generatedSlots))) : "") + ")")
  }

  function hash(str) {
    var hash = 5381;
    var i = str.length;
    while(i) {
      hash = (hash * 33) ^ str.charCodeAt(--i);
    }
    return hash >>> 0
  }

  function containsSlotChild (el) {
    if (el.type === 1) {
      if (el.tag === 'slot') {
        return true
      }
      return el.children.some(containsSlotChild)
    }
    return false
  }

  function genScopedSlot (
    el,
    state
  ) {
    var isLegacySyntax = el.attrsMap['slot-scope'];
    if (el.if && !el.ifProcessed && !isLegacySyntax) {
      return genIf(el, state, genScopedSlot, "null")
    }
    if (el.for && !el.forProcessed) {
      return genFor(el, state, genScopedSlot)
    }
    var slotScope = el.slotScope === emptySlotScopeToken
      ? ""
      : String(el.slotScope);
    var fn = "function(" + slotScope + "){" +
      "return " + (el.tag === 'template'
        ? el.if && isLegacySyntax
          ? ("(" + (el.if) + ")?" + (genChildren(el, state) || 'undefined') + ":undefined")
          : genChildren(el, state) || 'undefined'
        : genElement(el, state)) + "}";
    // reverse proxy v-slot without scope on this.$slots
    var reverseProxy = slotScope ? "" : ",proxy:true";
    return ("{key:" + (el.slotTarget || "\"default\"") + ",fn:" + fn + reverseProxy + "}")
  }

  function genChildren (
    el,
    state,
    checkSkip,
    altGenElement,
    altGenNode
  ) {
    var children = el.children;
    if (children.length) {
      var el$1 = children[0];
      // optimize single v-for
      if (children.length === 1 &&
        el$1.for &&
        el$1.tag !== 'template' &&
        el$1.tag !== 'slot'
      ) {
        var normalizationType = checkSkip
          ? state.maybeComponent(el$1) ? ",1" : ",0"
          : "";
        return ("" + ((altGenElement || genElement)(el$1, state)) + normalizationType)
      }
      var normalizationType$1 = checkSkip
        ? getNormalizationType(children, state.maybeComponent)
        : 0;
      var gen = altGenNode || genNode;
      return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType$1 ? ("," + normalizationType$1) : ''))
    }
  }

  // determine the normalization needed for the children array.
  // 0: no normalization needed
  // 1: simple normalization needed (possible 1-level deep nested array)
  // 2: full normalization needed
  function getNormalizationType (
    children,
    maybeComponent
  ) {
    var res = 0;
    for (var i = 0; i < children.length; i++) {
      var el = children[i];
      if (el.type !== 1) {
        continue
      }
      if (needsNormalization(el) ||
          (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
        res = 2;
        break
      }
      if (maybeComponent(el) ||
          (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
        res = 1;
      }
    }
    return res
  }

  function needsNormalization (el) {
    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
  }

  function genNode (node, state) {
    if (node.type === 1) {
      return genElement(node, state)
    } else if (node.type === 3 && node.isComment) {
      return genComment(node)
    } else {
      return genText(node)
    }
  }

  function genText (text) {
    return ("_v(" + (text.type === 2
      ? text.expression // no need for () because already wrapped in _s()
      : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
  }

  function genComment (comment) {
    return ("_e(" + (JSON.stringify(comment.text)) + ")")
  }

  function genSlot (el, state) {
    var slotName = el.slotName || '"default"';
    var children = genChildren(el, state);
    var res = "_t(" + slotName + (children ? (",function(){return " + children + "}") : '');
    var attrs = el.attrs || el.dynamicAttrs
      ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({
          // slot props are camelized
          name: camelize(attr.name),
          value: attr.value,
          dynamic: attr.dynamic
        }); }))
      : null;
    var bind$$1 = el.attrsMap['v-bind'];
    if ((attrs || bind$$1) && !children) {
      res += ",null";
    }
    if (attrs) {
      res += "," + attrs;
    }
    if (bind$$1) {
      res += (attrs ? '' : ',null') + "," + bind$$1;
    }
    return res + ')'
  }

  // componentName is el.component, take it as argument to shun flow's pessimistic refinement
  function genComponent (
    componentName,
    el,
    state
  ) {
    var children = el.inlineTemplate ? null : genChildren(el, state, true);
    return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
  }

  function genProps (props) {
    var staticProps = "";
    var dynamicProps = "";
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      var value = transformSpecialNewlines(prop.value);
      if (prop.dynamic) {
        dynamicProps += (prop.name) + "," + value + ",";
      } else {
        staticProps += "\"" + (prop.name) + "\":" + value + ",";
      }
    }
    staticProps = "{" + (staticProps.slice(0, -1)) + "}";
    if (dynamicProps) {
      return ("_d(" + staticProps + ",[" + (dynamicProps.slice(0, -1)) + "])")
    } else {
      return staticProps
    }
  }

  // #3895, #4268
  function transformSpecialNewlines (text) {
    return text
      .replace(/\u2028/g, '\\u2028')
      .replace(/\u2029/g, '\\u2029')
  }

  /*  */



  // these keywords should not appear inside expressions, but operators like
  // typeof, instanceof and in are allowed
  var prohibitedKeywordRE = new RegExp('\\b' + (
    'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
    'super,throw,while,yield,delete,export,import,return,switch,default,' +
    'extends,finally,continue,debugger,function,arguments'
  ).split(',').join('\\b|\\b') + '\\b');

  // these unary operators should not be used as property/method names
  var unaryOperatorsRE = new RegExp('\\b' + (
    'delete,typeof,void'
  ).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

  // strip strings in expressions
  var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

  // detect problematic expressions in a template
  function detectErrors (ast, warn) {
    if (ast) {
      checkNode(ast, warn);
    }
  }

  function checkNode (node, warn) {
    if (node.type === 1) {
      for (var name in node.attrsMap) {
        if (dirRE.test(name)) {
          var value = node.attrsMap[name];
          if (value) {
            var range = node.rawAttrsMap[name];
            if (name === 'v-for') {
              checkFor(node, ("v-for=\"" + value + "\""), warn, range);
            } else if (name === 'v-slot' || name[0] === '#') {
              checkFunctionParameterExpression(value, (name + "=\"" + value + "\""), warn, range);
            } else if (onRE.test(name)) {
              checkEvent(value, (name + "=\"" + value + "\""), warn, range);
            } else {
              checkExpression(value, (name + "=\"" + value + "\""), warn, range);
            }
          }
        }
      }
      if (node.children) {
        for (var i = 0; i < node.children.length; i++) {
          checkNode(node.children[i], warn);
        }
      }
    } else if (node.type === 2) {
      checkExpression(node.expression, node.text, warn, node);
    }
  }

  function checkEvent (exp, text, warn, range) {
    var stripped = exp.replace(stripStringRE, '');
    var keywordMatch = stripped.match(unaryOperatorsRE);
    if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
      warn(
        "avoid using JavaScript unary operator as property name: " +
        "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim()),
        range
      );
    }
    checkExpression(exp, text, warn, range);
  }

  function checkFor (node, text, warn, range) {
    checkExpression(node.for || '', text, warn, range);
    checkIdentifier(node.alias, 'v-for alias', text, warn, range);
    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
  }

  function checkIdentifier (
    ident,
    type,
    text,
    warn,
    range
  ) {
    if (typeof ident === 'string') {
      try {
        new Function(("var " + ident + "=_"));
      } catch (e) {
        warn(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())), range);
      }
    }
  }

  function checkExpression (exp, text, warn, range) {
    try {
      new Function(("return " + exp));
    } catch (e) {
      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
      if (keywordMatch) {
        warn(
          "avoid using JavaScript keyword as property name: " +
          "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim()),
          range
        );
      } else {
        warn(
          "invalid expression: " + (e.message) + " in\n\n" +
          "    " + exp + "\n\n" +
          "  Raw expression: " + (text.trim()) + "\n",
          range
        );
      }
    }
  }

  function checkFunctionParameterExpression (exp, text, warn, range) {
    try {
      new Function(exp, '');
    } catch (e) {
      warn(
        "invalid function parameter expression: " + (e.message) + " in\n\n" +
        "    " + exp + "\n\n" +
        "  Raw expression: " + (text.trim()) + "\n",
        range
      );
    }
  }

  /*  */

  var range = 2;

  function generateCodeFrame (
    source,
    start,
    end
  ) {
    if ( start === void 0 ) start = 0;
    if ( end === void 0 ) end = source.length;

    var lines = source.split(/\r?\n/);
    var count = 0;
    var res = [];
    for (var i = 0; i < lines.length; i++) {
      count += lines[i].length + 1;
      if (count >= start) {
        for (var j = i - range; j <= i + range || end > count; j++) {
          if (j < 0 || j >= lines.length) { continue }
          res.push(("" + (j + 1) + (repeat$1(" ", 3 - String(j + 1).length)) + "|  " + (lines[j])));
          var lineLength = lines[j].length;
          if (j === i) {
            // push underline
            var pad = start - (count - lineLength) + 1;
            var length = end > count ? lineLength - pad : end - start;
            res.push("   |  " + repeat$1(" ", pad) + repeat$1("^", length));
          } else if (j > i) {
            if (end > count) {
              var length$1 = Math.min(end - count, lineLength);
              res.push("   |  " + repeat$1("^", length$1));
            }
            count += lineLength + 1;
          }
        }
        break
      }
    }
    return res.join('\n')
  }

  function repeat$1 (str, n) {
    var result = '';
    if (n > 0) {
      while (true) { // eslint-disable-line
        if (n & 1) { result += str; }
        n >>>= 1;
        if (n <= 0) { break }
        str += str;
      }
    }
    return result
  }

  /*  */



  function createFunction (code, errors) {
    try {
      return new Function(code)
    } catch (err) {
      errors.push({ err: err, code: code });
      return noop
    }
  }

  function createCompileToFunctionFn (compile) {
    var cache = Object.create(null);

    return function compileToFunctions (
      template,
      options,
      vm
    ) {
      options = extend({}, options);
      var warn$$1 = options.warn || warn;
      delete options.warn;

      /* istanbul ignore if */
      {
        // detect possible CSP restriction
        try {
          new Function('return 1');
        } catch (e) {
          if (e.toString().match(/unsafe-eval|CSP/)) {
            warn$$1(
              'It seems you are using the standalone build of Vue.js in an ' +
              'environment with Content Security Policy that prohibits unsafe-eval. ' +
              'The template compiler cannot work in this environment. Consider ' +
              'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
              'templates into render functions.'
            );
          }
        }
      }

      // check cache
      var key = options.delimiters
        ? String(options.delimiters) + template
        : template;
      if (cache[key]) {
        return cache[key]
      }

      // compile
      var compiled = compile(template, options);

      // check compilation errors/tips
      {
        if (compiled.errors && compiled.errors.length) {
          if (options.outputSourceRange) {
            compiled.errors.forEach(function (e) {
              warn$$1(
                "Error compiling template:\n\n" + (e.msg) + "\n\n" +
                generateCodeFrame(template, e.start, e.end),
                vm
              );
            });
          } else {
            warn$$1(
              "Error compiling template:\n\n" + template + "\n\n" +
              compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
              vm
            );
          }
        }
        if (compiled.tips && compiled.tips.length) {
          if (options.outputSourceRange) {
            compiled.tips.forEach(function (e) { return tip(e.msg, vm); });
          } else {
            compiled.tips.forEach(function (msg) { return tip(msg, vm); });
          }
        }
      }

      // turn code into functions
      var res = {};
      var fnGenErrors = [];
      res.render = createFunction(compiled.render, fnGenErrors);
      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
        return createFunction(code, fnGenErrors)
      });

      // check function generation errors.
      // this should only happen if there is a bug in the compiler itself.
      // mostly for codegen development use
      /* istanbul ignore if */
      {
        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
          warn$$1(
            "Failed to generate render function:\n\n" +
            fnGenErrors.map(function (ref) {
              var err = ref.err;
              var code = ref.code;

              return ((err.toString()) + " in\n\n" + code + "\n");
          }).join('\n'),
            vm
          );
        }
      }

      return (cache[key] = res)
    }
  }

  /*  */

  function createCompilerCreator (baseCompile) {
    return function createCompiler (baseOptions) {
      function compile (
        template,
        options
      ) {
        var finalOptions = Object.create(baseOptions);
        var errors = [];
        var tips = [];

        var warn = function (msg, range, tip) {
          (tip ? tips : errors).push(msg);
        };

        if (options) {
          if (options.outputSourceRange) {
            // $flow-disable-line
            var leadingSpaceLength = template.match(/^\s*/)[0].length;

            warn = function (msg, range, tip) {
              var data = { msg: msg };
              if (range) {
                if (range.start != null) {
                  data.start = range.start + leadingSpaceLength;
                }
                if (range.end != null) {
                  data.end = range.end + leadingSpaceLength;
                }
              }
              (tip ? tips : errors).push(data);
            };
          }
          // merge custom modules
          if (options.modules) {
            finalOptions.modules =
              (baseOptions.modules || []).concat(options.modules);
          }
          // merge custom directives
          if (options.directives) {
            finalOptions.directives = extend(
              Object.create(baseOptions.directives || null),
              options.directives
            );
          }
          // copy other options
          for (var key in options) {
            if (key !== 'modules' && key !== 'directives') {
              finalOptions[key] = options[key];
            }
          }
        }

        finalOptions.warn = warn;

        var compiled = baseCompile(template.trim(), finalOptions);
        {
          detectErrors(compiled.ast, warn);
        }
        compiled.errors = errors;
        compiled.tips = tips;
        return compiled
      }

      return {
        compile: compile,
        compileToFunctions: createCompileToFunctionFn(compile)
      }
    }
  }

  /*  */

  // `createCompilerCreator` allows creating compilers that use alternative
  // parser/optimizer/codegen, e.g the SSR optimizing compiler.
  // Here we just export a default compiler using the default parts.
  var createCompiler = createCompilerCreator(function baseCompile (
    template,
    options
  ) {
    var ast = parse(template.trim(), options);
    if (options.optimize !== false) {
      optimize(ast, options);
    }
    var code = generate(ast, options);
    return {
      ast: ast,
      render: code.render,
      staticRenderFns: code.staticRenderFns
    }
  });

  /*  */

  var ref$1 = createCompiler(baseOptions);
  var compile = ref$1.compile;
  var compileToFunctions = ref$1.compileToFunctions;

  /*  */

  // check whether current browser encodes a char inside attribute values
  var div;
  function getShouldDecode (href) {
    div = div || document.createElement('div');
    div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
    return div.innerHTML.indexOf('&#10;') > 0
  }

  // #3663: IE encodes newlines inside attribute values while other browsers don't
  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
  // #6828: chrome encodes content in a[href]
  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

  /*  */

  var idToTemplate = cached(function (id) {
    var el = query(id);
    return el && el.innerHTML
  });

  var mount = Vue.prototype.$mount;
  Vue.prototype.$mount = function (
    el,
    hydrating
  ) {
    el = el && query(el);

    /* istanbul ignore if */
    if (el === document.body || el === document.documentElement) {
      warn(
        "Do not mount Vue to <html> or <body> - mount to normal elements instead."
      );
      return this
    }

    var options = this.$options;
    // resolve template/el and convert to render function
    if (!options.render) {
      var template = options.template;
      if (template) {
        if (typeof template === 'string') {
          if (template.charAt(0) === '#') {
            template = idToTemplate(template);
            /* istanbul ignore if */
            if (!template) {
              warn(
                ("Template element not found or is empty: " + (options.template)),
                this
              );
            }
          }
        } else if (template.nodeType) {
          template = template.innerHTML;
        } else {
          {
            warn('invalid template option:' + template, this);
          }
          return this
        }
      } else if (el) {
        template = getOuterHTML(el);
      }
      if (template) {
        /* istanbul ignore if */
        if (config.performance && mark) {
          mark('compile');
        }

        var ref = compileToFunctions(template, {
          outputSourceRange: "development" !== 'production',
          shouldDecodeNewlines: shouldDecodeNewlines,
          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        }, this);
        var render = ref.render;
        var staticRenderFns = ref.staticRenderFns;
        options.render = render;
        options.staticRenderFns = staticRenderFns;

        /* istanbul ignore if */
        if (config.performance && mark) {
          mark('compile end');
          measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
        }
      }
    }
    return mount.call(this, el, hydrating)
  };

  /**
   * Get outerHTML of elements, taking care
   * of SVG elements in IE as well.
   */
  function getOuterHTML (el) {
    if (el.outerHTML) {
      return el.outerHTML
    } else {
      var container = document.createElement('div');
      container.appendChild(el.cloneNode(true));
      return container.innerHTML
    }
  }

  Vue.compile = compileToFunctions;

  return Vue;

}));


/***/ }),

/***/ 2868:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 4777:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 9830:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 209:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 7414:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 2961:
/***/ ((module) => {

let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = ''
    let i = size
    while (i--) {
      id += alphabet[(Math.random() * alphabet.length) | 0]
    }
    return id
  }
}
let nanoid = (size = 21) => {
  let id = ''
  let i = size
  while (i--) {
    id += urlAlphabet[(Math.random() * 64) | 0]
  }
  return id
}
module.exports = { nanoid, customAlphabet }


/***/ }),

/***/ 3600:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}');

/***/ }),

/***/ 9323:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"Aacute":"","aacute":"","Abreve":"","abreve":"","ac":"","acd":"","acE":"","Acirc":"","acirc":"","acute":"","Acy":"","acy":"","AElig":"","aelig":"","af":"","Afr":"","afr":"","Agrave":"","agrave":"","alefsym":"","aleph":"","Alpha":"","alpha":"","Amacr":"","amacr":"","amalg":"","amp":"&","AMP":"&","andand":"","And":"","and":"","andd":"","andslope":"","andv":"","ang":"","ange":"","angle":"","angmsdaa":"","angmsdab":"","angmsdac":"","angmsdad":"","angmsdae":"","angmsdaf":"","angmsdag":"","angmsdah":"","angmsd":"","angrt":"","angrtvb":"","angrtvbd":"","angsph":"","angst":"","angzarr":"","Aogon":"","aogon":"","Aopf":"","aopf":"","apacir":"","ap":"","apE":"","ape":"","apid":"","apos":"\'","ApplyFunction":"","approx":"","approxeq":"","Aring":"","aring":"","Ascr":"","ascr":"","Assign":"","ast":"*","asymp":"","asympeq":"","Atilde":"","atilde":"","Auml":"","auml":"","awconint":"","awint":"","backcong":"","backepsilon":"","backprime":"","backsim":"","backsimeq":"","Backslash":"","Barv":"","barvee":"","barwed":"","Barwed":"","barwedge":"","bbrk":"","bbrktbrk":"","bcong":"","Bcy":"","bcy":"","bdquo":"","becaus":"","because":"","Because":"","bemptyv":"","bepsi":"","bernou":"","Bernoullis":"","Beta":"","beta":"","beth":"","between":"","Bfr":"","bfr":"","bigcap":"","bigcirc":"","bigcup":"","bigodot":"","bigoplus":"","bigotimes":"","bigsqcup":"","bigstar":"","bigtriangledown":"","bigtriangleup":"","biguplus":"","bigvee":"","bigwedge":"","bkarow":"","blacklozenge":"","blacksquare":"","blacktriangle":"","blacktriangledown":"","blacktriangleleft":"","blacktriangleright":"","blank":"","blk12":"","blk14":"","blk34":"","block":"","bne":"=","bnequiv":"","bNot":"","bnot":"","Bopf":"","bopf":"","bot":"","bottom":"","bowtie":"","boxbox":"","boxdl":"","boxdL":"","boxDl":"","boxDL":"","boxdr":"","boxdR":"","boxDr":"","boxDR":"","boxh":"","boxH":"","boxhd":"","boxHd":"","boxhD":"","boxHD":"","boxhu":"","boxHu":"","boxhU":"","boxHU":"","boxminus":"","boxplus":"","boxtimes":"","boxul":"","boxuL":"","boxUl":"","boxUL":"","boxur":"","boxuR":"","boxUr":"","boxUR":"","boxv":"","boxV":"","boxvh":"","boxvH":"","boxVh":"","boxVH":"","boxvl":"","boxvL":"","boxVl":"","boxVL":"","boxvr":"","boxvR":"","boxVr":"","boxVR":"","bprime":"","breve":"","Breve":"","brvbar":"","bscr":"","Bscr":"","bsemi":"","bsim":"","bsime":"","bsolb":"","bsol":"\\\\","bsolhsub":"","bull":"","bullet":"","bump":"","bumpE":"","bumpe":"","Bumpeq":"","bumpeq":"","Cacute":"","cacute":"","capand":"","capbrcup":"","capcap":"","cap":"","Cap":"","capcup":"","capdot":"","CapitalDifferentialD":"","caps":"","caret":"","caron":"","Cayleys":"","ccaps":"","Ccaron":"","ccaron":"","Ccedil":"","ccedil":"","Ccirc":"","ccirc":"","Cconint":"","ccups":"","ccupssm":"","Cdot":"","cdot":"","cedil":"","Cedilla":"","cemptyv":"","cent":"","centerdot":"","CenterDot":"","cfr":"","Cfr":"","CHcy":"","chcy":"","check":"","checkmark":"","Chi":"","chi":"","circ":"","circeq":"","circlearrowleft":"","circlearrowright":"","circledast":"","circledcirc":"","circleddash":"","CircleDot":"","circledR":"","circledS":"","CircleMinus":"","CirclePlus":"","CircleTimes":"","cir":"","cirE":"","cire":"","cirfnint":"","cirmid":"","cirscir":"","ClockwiseContourIntegral":"","CloseCurlyDoubleQuote":"","CloseCurlyQuote":"","clubs":"","clubsuit":"","colon":":","Colon":"","Colone":"","colone":"","coloneq":"","comma":",","commat":"@","comp":"","compfn":"","complement":"","complexes":"","cong":"","congdot":"","Congruent":"","conint":"","Conint":"","ContourIntegral":"","copf":"","Copf":"","coprod":"","Coproduct":"","copy":"","COPY":"","copysr":"","CounterClockwiseContourIntegral":"","crarr":"","cross":"","Cross":"","Cscr":"","cscr":"","csub":"","csube":"","csup":"","csupe":"","ctdot":"","cudarrl":"","cudarrr":"","cuepr":"","cuesc":"","cularr":"","cularrp":"","cupbrcap":"","cupcap":"","CupCap":"","cup":"","Cup":"","cupcup":"","cupdot":"","cupor":"","cups":"","curarr":"","curarrm":"","curlyeqprec":"","curlyeqsucc":"","curlyvee":"","curlywedge":"","curren":"","curvearrowleft":"","curvearrowright":"","cuvee":"","cuwed":"","cwconint":"","cwint":"","cylcty":"","dagger":"","Dagger":"","daleth":"","darr":"","Darr":"","dArr":"","dash":"","Dashv":"","dashv":"","dbkarow":"","dblac":"","Dcaron":"","dcaron":"","Dcy":"","dcy":"","ddagger":"","ddarr":"","DD":"","dd":"","DDotrahd":"","ddotseq":"","deg":"","Del":"","Delta":"","delta":"","demptyv":"","dfisht":"","Dfr":"","dfr":"","dHar":"","dharl":"","dharr":"","DiacriticalAcute":"","DiacriticalDot":"","DiacriticalDoubleAcute":"","DiacriticalGrave":"`","DiacriticalTilde":"","diam":"","diamond":"","Diamond":"","diamondsuit":"","diams":"","die":"","DifferentialD":"","digamma":"","disin":"","div":"","divide":"","divideontimes":"","divonx":"","DJcy":"","djcy":"","dlcorn":"","dlcrop":"","dollar":"$","Dopf":"","dopf":"","Dot":"","dot":"","DotDot":"","doteq":"","doteqdot":"","DotEqual":"","dotminus":"","dotplus":"","dotsquare":"","doublebarwedge":"","DoubleContourIntegral":"","DoubleDot":"","DoubleDownArrow":"","DoubleLeftArrow":"","DoubleLeftRightArrow":"","DoubleLeftTee":"","DoubleLongLeftArrow":"","DoubleLongLeftRightArrow":"","DoubleLongRightArrow":"","DoubleRightArrow":"","DoubleRightTee":"","DoubleUpArrow":"","DoubleUpDownArrow":"","DoubleVerticalBar":"","DownArrowBar":"","downarrow":"","DownArrow":"","Downarrow":"","DownArrowUpArrow":"","DownBreve":"","downdownarrows":"","downharpoonleft":"","downharpoonright":"","DownLeftRightVector":"","DownLeftTeeVector":"","DownLeftVectorBar":"","DownLeftVector":"","DownRightTeeVector":"","DownRightVectorBar":"","DownRightVector":"","DownTeeArrow":"","DownTee":"","drbkarow":"","drcorn":"","drcrop":"","Dscr":"","dscr":"","DScy":"","dscy":"","dsol":"","Dstrok":"","dstrok":"","dtdot":"","dtri":"","dtrif":"","duarr":"","duhar":"","dwangle":"","DZcy":"","dzcy":"","dzigrarr":"","Eacute":"","eacute":"","easter":"","Ecaron":"","ecaron":"","Ecirc":"","ecirc":"","ecir":"","ecolon":"","Ecy":"","ecy":"","eDDot":"","Edot":"","edot":"","eDot":"","ee":"","efDot":"","Efr":"","efr":"","eg":"","Egrave":"","egrave":"","egs":"","egsdot":"","el":"","Element":"","elinters":"","ell":"","els":"","elsdot":"","Emacr":"","emacr":"","empty":"","emptyset":"","EmptySmallSquare":"","emptyv":"","EmptyVerySmallSquare":"","emsp13":"","emsp14":"","emsp":"","ENG":"","eng":"","ensp":"","Eogon":"","eogon":"","Eopf":"","eopf":"","epar":"","eparsl":"","eplus":"","epsi":"","Epsilon":"","epsilon":"","epsiv":"","eqcirc":"","eqcolon":"","eqsim":"","eqslantgtr":"","eqslantless":"","Equal":"","equals":"=","EqualTilde":"","equest":"","Equilibrium":"","equiv":"","equivDD":"","eqvparsl":"","erarr":"","erDot":"","escr":"","Escr":"","esdot":"","Esim":"","esim":"","Eta":"","eta":"","ETH":"","eth":"","Euml":"","euml":"","euro":"","excl":"!","exist":"","Exists":"","expectation":"","exponentiale":"","ExponentialE":"","fallingdotseq":"","Fcy":"","fcy":"","female":"","ffilig":"","fflig":"","ffllig":"","Ffr":"","ffr":"","filig":"","FilledSmallSquare":"","FilledVerySmallSquare":"","fjlig":"fj","flat":"","fllig":"","fltns":"","fnof":"","Fopf":"","fopf":"","forall":"","ForAll":"","fork":"","forkv":"","Fouriertrf":"","fpartint":"","frac12":"","frac13":"","frac14":"","frac15":"","frac16":"","frac18":"","frac23":"","frac25":"","frac34":"","frac35":"","frac38":"","frac45":"","frac56":"","frac58":"","frac78":"","frasl":"","frown":"","fscr":"","Fscr":"","gacute":"","Gamma":"","gamma":"","Gammad":"","gammad":"","gap":"","Gbreve":"","gbreve":"","Gcedil":"","Gcirc":"","gcirc":"","Gcy":"","gcy":"","Gdot":"","gdot":"","ge":"","gE":"","gEl":"","gel":"","geq":"","geqq":"","geqslant":"","gescc":"","ges":"","gesdot":"","gesdoto":"","gesdotol":"","gesl":"","gesles":"","Gfr":"","gfr":"","gg":"","Gg":"","ggg":"","gimel":"","GJcy":"","gjcy":"","gla":"","gl":"","glE":"","glj":"","gnap":"","gnapprox":"","gne":"","gnE":"","gneq":"","gneqq":"","gnsim":"","Gopf":"","gopf":"","grave":"`","GreaterEqual":"","GreaterEqualLess":"","GreaterFullEqual":"","GreaterGreater":"","GreaterLess":"","GreaterSlantEqual":"","GreaterTilde":"","Gscr":"","gscr":"","gsim":"","gsime":"","gsiml":"","gtcc":"","gtcir":"","gt":">","GT":">","Gt":"","gtdot":"","gtlPar":"","gtquest":"","gtrapprox":"","gtrarr":"","gtrdot":"","gtreqless":"","gtreqqless":"","gtrless":"","gtrsim":"","gvertneqq":"","gvnE":"","Hacek":"","hairsp":"","half":"","hamilt":"","HARDcy":"","hardcy":"","harrcir":"","harr":"","hArr":"","harrw":"","Hat":"^","hbar":"","Hcirc":"","hcirc":"","hearts":"","heartsuit":"","hellip":"","hercon":"","hfr":"","Hfr":"","HilbertSpace":"","hksearow":"","hkswarow":"","hoarr":"","homtht":"","hookleftarrow":"","hookrightarrow":"","hopf":"","Hopf":"","horbar":"","HorizontalLine":"","hscr":"","Hscr":"","hslash":"","Hstrok":"","hstrok":"","HumpDownHump":"","HumpEqual":"","hybull":"","hyphen":"","Iacute":"","iacute":"","ic":"","Icirc":"","icirc":"","Icy":"","icy":"","Idot":"","IEcy":"","iecy":"","iexcl":"","iff":"","ifr":"","Ifr":"","Igrave":"","igrave":"","ii":"","iiiint":"","iiint":"","iinfin":"","iiota":"","IJlig":"","ijlig":"","Imacr":"","imacr":"","image":"","ImaginaryI":"","imagline":"","imagpart":"","imath":"","Im":"","imof":"","imped":"","Implies":"","incare":"","in":"","infin":"","infintie":"","inodot":"","intcal":"","int":"","Int":"","integers":"","Integral":"","intercal":"","Intersection":"","intlarhk":"","intprod":"","InvisibleComma":"","InvisibleTimes":"","IOcy":"","iocy":"","Iogon":"","iogon":"","Iopf":"","iopf":"","Iota":"","iota":"","iprod":"","iquest":"","iscr":"","Iscr":"","isin":"","isindot":"","isinE":"","isins":"","isinsv":"","isinv":"","it":"","Itilde":"","itilde":"","Iukcy":"","iukcy":"","Iuml":"","iuml":"","Jcirc":"","jcirc":"","Jcy":"","jcy":"","Jfr":"","jfr":"","jmath":"","Jopf":"","jopf":"","Jscr":"","jscr":"","Jsercy":"","jsercy":"","Jukcy":"","jukcy":"","Kappa":"","kappa":"","kappav":"","Kcedil":"","kcedil":"","Kcy":"","kcy":"","Kfr":"","kfr":"","kgreen":"","KHcy":"","khcy":"","KJcy":"","kjcy":"","Kopf":"","kopf":"","Kscr":"","kscr":"","lAarr":"","Lacute":"","lacute":"","laemptyv":"","lagran":"","Lambda":"","lambda":"","lang":"","Lang":"","langd":"","langle":"","lap":"","Laplacetrf":"","laquo":"","larrb":"","larrbfs":"","larr":"","Larr":"","lArr":"","larrfs":"","larrhk":"","larrlp":"","larrpl":"","larrsim":"","larrtl":"","latail":"","lAtail":"","lat":"","late":"","lates":"","lbarr":"","lBarr":"","lbbrk":"","lbrace":"{","lbrack":"[","lbrke":"","lbrksld":"","lbrkslu":"","Lcaron":"","lcaron":"","Lcedil":"","lcedil":"","lceil":"","lcub":"{","Lcy":"","lcy":"","ldca":"","ldquo":"","ldquor":"","ldrdhar":"","ldrushar":"","ldsh":"","le":"","lE":"","LeftAngleBracket":"","LeftArrowBar":"","leftarrow":"","LeftArrow":"","Leftarrow":"","LeftArrowRightArrow":"","leftarrowtail":"","LeftCeiling":"","LeftDoubleBracket":"","LeftDownTeeVector":"","LeftDownVectorBar":"","LeftDownVector":"","LeftFloor":"","leftharpoondown":"","leftharpoonup":"","leftleftarrows":"","leftrightarrow":"","LeftRightArrow":"","Leftrightarrow":"","leftrightarrows":"","leftrightharpoons":"","leftrightsquigarrow":"","LeftRightVector":"","LeftTeeArrow":"","LeftTee":"","LeftTeeVector":"","leftthreetimes":"","LeftTriangleBar":"","LeftTriangle":"","LeftTriangleEqual":"","LeftUpDownVector":"","LeftUpTeeVector":"","LeftUpVectorBar":"","LeftUpVector":"","LeftVectorBar":"","LeftVector":"","lEg":"","leg":"","leq":"","leqq":"","leqslant":"","lescc":"","les":"","lesdot":"","lesdoto":"","lesdotor":"","lesg":"","lesges":"","lessapprox":"","lessdot":"","lesseqgtr":"","lesseqqgtr":"","LessEqualGreater":"","LessFullEqual":"","LessGreater":"","lessgtr":"","LessLess":"","lesssim":"","LessSlantEqual":"","LessTilde":"","lfisht":"","lfloor":"","Lfr":"","lfr":"","lg":"","lgE":"","lHar":"","lhard":"","lharu":"","lharul":"","lhblk":"","LJcy":"","ljcy":"","llarr":"","ll":"","Ll":"","llcorner":"","Lleftarrow":"","llhard":"","lltri":"","Lmidot":"","lmidot":"","lmoustache":"","lmoust":"","lnap":"","lnapprox":"","lne":"","lnE":"","lneq":"","lneqq":"","lnsim":"","loang":"","loarr":"","lobrk":"","longleftarrow":"","LongLeftArrow":"","Longleftarrow":"","longleftrightarrow":"","LongLeftRightArrow":"","Longleftrightarrow":"","longmapsto":"","longrightarrow":"","LongRightArrow":"","Longrightarrow":"","looparrowleft":"","looparrowright":"","lopar":"","Lopf":"","lopf":"","loplus":"","lotimes":"","lowast":"","lowbar":"_","LowerLeftArrow":"","LowerRightArrow":"","loz":"","lozenge":"","lozf":"","lpar":"(","lparlt":"","lrarr":"","lrcorner":"","lrhar":"","lrhard":"","lrm":"","lrtri":"","lsaquo":"","lscr":"","Lscr":"","lsh":"","Lsh":"","lsim":"","lsime":"","lsimg":"","lsqb":"[","lsquo":"","lsquor":"","Lstrok":"","lstrok":"","ltcc":"","ltcir":"","lt":"<","LT":"<","Lt":"","ltdot":"","lthree":"","ltimes":"","ltlarr":"","ltquest":"","ltri":"","ltrie":"","ltrif":"","ltrPar":"","lurdshar":"","luruhar":"","lvertneqq":"","lvnE":"","macr":"","male":"","malt":"","maltese":"","Map":"","map":"","mapsto":"","mapstodown":"","mapstoleft":"","mapstoup":"","marker":"","mcomma":"","Mcy":"","mcy":"","mdash":"","mDDot":"","measuredangle":"","MediumSpace":"","Mellintrf":"","Mfr":"","mfr":"","mho":"","micro":"","midast":"*","midcir":"","mid":"","middot":"","minusb":"","minus":"","minusd":"","minusdu":"","MinusPlus":"","mlcp":"","mldr":"","mnplus":"","models":"","Mopf":"","mopf":"","mp":"","mscr":"","Mscr":"","mstpos":"","Mu":"","mu":"","multimap":"","mumap":"","nabla":"","Nacute":"","nacute":"","nang":"","nap":"","napE":"","napid":"","napos":"","napprox":"","natural":"","naturals":"","natur":"","nbsp":"","nbump":"","nbumpe":"","ncap":"","Ncaron":"","ncaron":"","Ncedil":"","ncedil":"","ncong":"","ncongdot":"","ncup":"","Ncy":"","ncy":"","ndash":"","nearhk":"","nearr":"","neArr":"","nearrow":"","ne":"","nedot":"","NegativeMediumSpace":"","NegativeThickSpace":"","NegativeThinSpace":"","NegativeVeryThinSpace":"","nequiv":"","nesear":"","nesim":"","NestedGreaterGreater":"","NestedLessLess":"","NewLine":"\\n","nexist":"","nexists":"","Nfr":"","nfr":"","ngE":"","nge":"","ngeq":"","ngeqq":"","ngeqslant":"","nges":"","nGg":"","ngsim":"","nGt":"","ngt":"","ngtr":"","nGtv":"","nharr":"","nhArr":"","nhpar":"","ni":"","nis":"","nisd":"","niv":"","NJcy":"","njcy":"","nlarr":"","nlArr":"","nldr":"","nlE":"","nle":"","nleftarrow":"","nLeftarrow":"","nleftrightarrow":"","nLeftrightarrow":"","nleq":"","nleqq":"","nleqslant":"","nles":"","nless":"","nLl":"","nlsim":"","nLt":"","nlt":"","nltri":"","nltrie":"","nLtv":"","nmid":"","NoBreak":"","NonBreakingSpace":"","nopf":"","Nopf":"","Not":"","not":"","NotCongruent":"","NotCupCap":"","NotDoubleVerticalBar":"","NotElement":"","NotEqual":"","NotEqualTilde":"","NotExists":"","NotGreater":"","NotGreaterEqual":"","NotGreaterFullEqual":"","NotGreaterGreater":"","NotGreaterLess":"","NotGreaterSlantEqual":"","NotGreaterTilde":"","NotHumpDownHump":"","NotHumpEqual":"","notin":"","notindot":"","notinE":"","notinva":"","notinvb":"","notinvc":"","NotLeftTriangleBar":"","NotLeftTriangle":"","NotLeftTriangleEqual":"","NotLess":"","NotLessEqual":"","NotLessGreater":"","NotLessLess":"","NotLessSlantEqual":"","NotLessTilde":"","NotNestedGreaterGreater":"","NotNestedLessLess":"","notni":"","notniva":"","notnivb":"","notnivc":"","NotPrecedes":"","NotPrecedesEqual":"","NotPrecedesSlantEqual":"","NotReverseElement":"","NotRightTriangleBar":"","NotRightTriangle":"","NotRightTriangleEqual":"","NotSquareSubset":"","NotSquareSubsetEqual":"","NotSquareSuperset":"","NotSquareSupersetEqual":"","NotSubset":"","NotSubsetEqual":"","NotSucceeds":"","NotSucceedsEqual":"","NotSucceedsSlantEqual":"","NotSucceedsTilde":"","NotSuperset":"","NotSupersetEqual":"","NotTilde":"","NotTildeEqual":"","NotTildeFullEqual":"","NotTildeTilde":"","NotVerticalBar":"","nparallel":"","npar":"","nparsl":"","npart":"","npolint":"","npr":"","nprcue":"","nprec":"","npreceq":"","npre":"","nrarrc":"","nrarr":"","nrArr":"","nrarrw":"","nrightarrow":"","nRightarrow":"","nrtri":"","nrtrie":"","nsc":"","nsccue":"","nsce":"","Nscr":"","nscr":"","nshortmid":"","nshortparallel":"","nsim":"","nsime":"","nsimeq":"","nsmid":"","nspar":"","nsqsube":"","nsqsupe":"","nsub":"","nsubE":"","nsube":"","nsubset":"","nsubseteq":"","nsubseteqq":"","nsucc":"","nsucceq":"","nsup":"","nsupE":"","nsupe":"","nsupset":"","nsupseteq":"","nsupseteqq":"","ntgl":"","Ntilde":"","ntilde":"","ntlg":"","ntriangleleft":"","ntrianglelefteq":"","ntriangleright":"","ntrianglerighteq":"","Nu":"","nu":"","num":"#","numero":"","numsp":"","nvap":"","nvdash":"","nvDash":"","nVdash":"","nVDash":"","nvge":"","nvgt":">","nvHarr":"","nvinfin":"","nvlArr":"","nvle":"","nvlt":"<","nvltrie":"","nvrArr":"","nvrtrie":"","nvsim":"","nwarhk":"","nwarr":"","nwArr":"","nwarrow":"","nwnear":"","Oacute":"","oacute":"","oast":"","Ocirc":"","ocirc":"","ocir":"","Ocy":"","ocy":"","odash":"","Odblac":"","odblac":"","odiv":"","odot":"","odsold":"","OElig":"","oelig":"","ofcir":"","Ofr":"","ofr":"","ogon":"","Ograve":"","ograve":"","ogt":"","ohbar":"","ohm":"","oint":"","olarr":"","olcir":"","olcross":"","oline":"","olt":"","Omacr":"","omacr":"","Omega":"","omega":"","Omicron":"","omicron":"","omid":"","ominus":"","Oopf":"","oopf":"","opar":"","OpenCurlyDoubleQuote":"","OpenCurlyQuote":"","operp":"","oplus":"","orarr":"","Or":"","or":"","ord":"","order":"","orderof":"","ordf":"","ordm":"","origof":"","oror":"","orslope":"","orv":"","oS":"","Oscr":"","oscr":"","Oslash":"","oslash":"","osol":"","Otilde":"","otilde":"","otimesas":"","Otimes":"","otimes":"","Ouml":"","ouml":"","ovbar":"","OverBar":"","OverBrace":"","OverBracket":"","OverParenthesis":"","para":"","parallel":"","par":"","parsim":"","parsl":"","part":"","PartialD":"","Pcy":"","pcy":"","percnt":"%","period":".","permil":"","perp":"","pertenk":"","Pfr":"","pfr":"","Phi":"","phi":"","phiv":"","phmmat":"","phone":"","Pi":"","pi":"","pitchfork":"","piv":"","planck":"","planckh":"","plankv":"","plusacir":"","plusb":"","pluscir":"","plus":"+","plusdo":"","plusdu":"","pluse":"","PlusMinus":"","plusmn":"","plussim":"","plustwo":"","pm":"","Poincareplane":"","pointint":"","popf":"","Popf":"","pound":"","prap":"","Pr":"","pr":"","prcue":"","precapprox":"","prec":"","preccurlyeq":"","Precedes":"","PrecedesEqual":"","PrecedesSlantEqual":"","PrecedesTilde":"","preceq":"","precnapprox":"","precneqq":"","precnsim":"","pre":"","prE":"","precsim":"","prime":"","Prime":"","primes":"","prnap":"","prnE":"","prnsim":"","prod":"","Product":"","profalar":"","profline":"","profsurf":"","prop":"","Proportional":"","Proportion":"","propto":"","prsim":"","prurel":"","Pscr":"","pscr":"","Psi":"","psi":"","puncsp":"","Qfr":"","qfr":"","qint":"","qopf":"","Qopf":"","qprime":"","Qscr":"","qscr":"","quaternions":"","quatint":"","quest":"?","questeq":"","quot":"\\"","QUOT":"\\"","rAarr":"","race":"","Racute":"","racute":"","radic":"","raemptyv":"","rang":"","Rang":"","rangd":"","range":"","rangle":"","raquo":"","rarrap":"","rarrb":"","rarrbfs":"","rarrc":"","rarr":"","Rarr":"","rArr":"","rarrfs":"","rarrhk":"","rarrlp":"","rarrpl":"","rarrsim":"","Rarrtl":"","rarrtl":"","rarrw":"","ratail":"","rAtail":"","ratio":"","rationals":"","rbarr":"","rBarr":"","RBarr":"","rbbrk":"","rbrace":"}","rbrack":"]","rbrke":"","rbrksld":"","rbrkslu":"","Rcaron":"","rcaron":"","Rcedil":"","rcedil":"","rceil":"","rcub":"}","Rcy":"","rcy":"","rdca":"","rdldhar":"","rdquo":"","rdquor":"","rdsh":"","real":"","realine":"","realpart":"","reals":"","Re":"","rect":"","reg":"","REG":"","ReverseElement":"","ReverseEquilibrium":"","ReverseUpEquilibrium":"","rfisht":"","rfloor":"","rfr":"","Rfr":"","rHar":"","rhard":"","rharu":"","rharul":"","Rho":"","rho":"","rhov":"","RightAngleBracket":"","RightArrowBar":"","rightarrow":"","RightArrow":"","Rightarrow":"","RightArrowLeftArrow":"","rightarrowtail":"","RightCeiling":"","RightDoubleBracket":"","RightDownTeeVector":"","RightDownVectorBar":"","RightDownVector":"","RightFloor":"","rightharpoondown":"","rightharpoonup":"","rightleftarrows":"","rightleftharpoons":"","rightrightarrows":"","rightsquigarrow":"","RightTeeArrow":"","RightTee":"","RightTeeVector":"","rightthreetimes":"","RightTriangleBar":"","RightTriangle":"","RightTriangleEqual":"","RightUpDownVector":"","RightUpTeeVector":"","RightUpVectorBar":"","RightUpVector":"","RightVectorBar":"","RightVector":"","ring":"","risingdotseq":"","rlarr":"","rlhar":"","rlm":"","rmoustache":"","rmoust":"","rnmid":"","roang":"","roarr":"","robrk":"","ropar":"","ropf":"","Ropf":"","roplus":"","rotimes":"","RoundImplies":"","rpar":")","rpargt":"","rppolint":"","rrarr":"","Rrightarrow":"","rsaquo":"","rscr":"","Rscr":"","rsh":"","Rsh":"","rsqb":"]","rsquo":"","rsquor":"","rthree":"","rtimes":"","rtri":"","rtrie":"","rtrif":"","rtriltri":"","RuleDelayed":"","ruluhar":"","rx":"","Sacute":"","sacute":"","sbquo":"","scap":"","Scaron":"","scaron":"","Sc":"","sc":"","sccue":"","sce":"","scE":"","Scedil":"","scedil":"","Scirc":"","scirc":"","scnap":"","scnE":"","scnsim":"","scpolint":"","scsim":"","Scy":"","scy":"","sdotb":"","sdot":"","sdote":"","searhk":"","searr":"","seArr":"","searrow":"","sect":"","semi":";","seswar":"","setminus":"","setmn":"","sext":"","Sfr":"","sfr":"","sfrown":"","sharp":"","SHCHcy":"","shchcy":"","SHcy":"","shcy":"","ShortDownArrow":"","ShortLeftArrow":"","shortmid":"","shortparallel":"","ShortRightArrow":"","ShortUpArrow":"","shy":"","Sigma":"","sigma":"","sigmaf":"","sigmav":"","sim":"","simdot":"","sime":"","simeq":"","simg":"","simgE":"","siml":"","simlE":"","simne":"","simplus":"","simrarr":"","slarr":"","SmallCircle":"","smallsetminus":"","smashp":"","smeparsl":"","smid":"","smile":"","smt":"","smte":"","smtes":"","SOFTcy":"","softcy":"","solbar":"","solb":"","sol":"/","Sopf":"","sopf":"","spades":"","spadesuit":"","spar":"","sqcap":"","sqcaps":"","sqcup":"","sqcups":"","Sqrt":"","sqsub":"","sqsube":"","sqsubset":"","sqsubseteq":"","sqsup":"","sqsupe":"","sqsupset":"","sqsupseteq":"","square":"","Square":"","SquareIntersection":"","SquareSubset":"","SquareSubsetEqual":"","SquareSuperset":"","SquareSupersetEqual":"","SquareUnion":"","squarf":"","squ":"","squf":"","srarr":"","Sscr":"","sscr":"","ssetmn":"","ssmile":"","sstarf":"","Star":"","star":"","starf":"","straightepsilon":"","straightphi":"","strns":"","sub":"","Sub":"","subdot":"","subE":"","sube":"","subedot":"","submult":"","subnE":"","subne":"","subplus":"","subrarr":"","subset":"","Subset":"","subseteq":"","subseteqq":"","SubsetEqual":"","subsetneq":"","subsetneqq":"","subsim":"","subsub":"","subsup":"","succapprox":"","succ":"","succcurlyeq":"","Succeeds":"","SucceedsEqual":"","SucceedsSlantEqual":"","SucceedsTilde":"","succeq":"","succnapprox":"","succneqq":"","succnsim":"","succsim":"","SuchThat":"","sum":"","Sum":"","sung":"","sup1":"","sup2":"","sup3":"","sup":"","Sup":"","supdot":"","supdsub":"","supE":"","supe":"","supedot":"","Superset":"","SupersetEqual":"","suphsol":"","suphsub":"","suplarr":"","supmult":"","supnE":"","supne":"","supplus":"","supset":"","Supset":"","supseteq":"","supseteqq":"","supsetneq":"","supsetneqq":"","supsim":"","supsub":"","supsup":"","swarhk":"","swarr":"","swArr":"","swarrow":"","swnwar":"","szlig":"","Tab":"\\t","target":"","Tau":"","tau":"","tbrk":"","Tcaron":"","tcaron":"","Tcedil":"","tcedil":"","Tcy":"","tcy":"","tdot":"","telrec":"","Tfr":"","tfr":"","there4":"","therefore":"","Therefore":"","Theta":"","theta":"","thetasym":"","thetav":"","thickapprox":"","thicksim":"","ThickSpace":"","ThinSpace":"","thinsp":"","thkap":"","thksim":"","THORN":"","thorn":"","tilde":"","Tilde":"","TildeEqual":"","TildeFullEqual":"","TildeTilde":"","timesbar":"","timesb":"","times":"","timesd":"","tint":"","toea":"","topbot":"","topcir":"","top":"","Topf":"","topf":"","topfork":"","tosa":"","tprime":"","trade":"","TRADE":"","triangle":"","triangledown":"","triangleleft":"","trianglelefteq":"","triangleq":"","triangleright":"","trianglerighteq":"","tridot":"","trie":"","triminus":"","TripleDot":"","triplus":"","trisb":"","tritime":"","trpezium":"","Tscr":"","tscr":"","TScy":"","tscy":"","TSHcy":"","tshcy":"","Tstrok":"","tstrok":"","twixt":"","twoheadleftarrow":"","twoheadrightarrow":"","Uacute":"","uacute":"","uarr":"","Uarr":"","uArr":"","Uarrocir":"","Ubrcy":"","ubrcy":"","Ubreve":"","ubreve":"","Ucirc":"","ucirc":"","Ucy":"","ucy":"","udarr":"","Udblac":"","udblac":"","udhar":"","ufisht":"","Ufr":"","ufr":"","Ugrave":"","ugrave":"","uHar":"","uharl":"","uharr":"","uhblk":"","ulcorn":"","ulcorner":"","ulcrop":"","ultri":"","Umacr":"","umacr":"","uml":"","UnderBar":"_","UnderBrace":"","UnderBracket":"","UnderParenthesis":"","Union":"","UnionPlus":"","Uogon":"","uogon":"","Uopf":"","uopf":"","UpArrowBar":"","uparrow":"","UpArrow":"","Uparrow":"","UpArrowDownArrow":"","updownarrow":"","UpDownArrow":"","Updownarrow":"","UpEquilibrium":"","upharpoonleft":"","upharpoonright":"","uplus":"","UpperLeftArrow":"","UpperRightArrow":"","upsi":"","Upsi":"","upsih":"","Upsilon":"","upsilon":"","UpTeeArrow":"","UpTee":"","upuparrows":"","urcorn":"","urcorner":"","urcrop":"","Uring":"","uring":"","urtri":"","Uscr":"","uscr":"","utdot":"","Utilde":"","utilde":"","utri":"","utrif":"","uuarr":"","Uuml":"","uuml":"","uwangle":"","vangrt":"","varepsilon":"","varkappa":"","varnothing":"","varphi":"","varpi":"","varpropto":"","varr":"","vArr":"","varrho":"","varsigma":"","varsubsetneq":"","varsubsetneqq":"","varsupsetneq":"","varsupsetneqq":"","vartheta":"","vartriangleleft":"","vartriangleright":"","vBar":"","Vbar":"","vBarv":"","Vcy":"","vcy":"","vdash":"","vDash":"","Vdash":"","VDash":"","Vdashl":"","veebar":"","vee":"","Vee":"","veeeq":"","vellip":"","verbar":"|","Verbar":"","vert":"|","Vert":"","VerticalBar":"","VerticalLine":"|","VerticalSeparator":"","VerticalTilde":"","VeryThinSpace":"","Vfr":"","vfr":"","vltri":"","vnsub":"","vnsup":"","Vopf":"","vopf":"","vprop":"","vrtri":"","Vscr":"","vscr":"","vsubnE":"","vsubne":"","vsupnE":"","vsupne":"","Vvdash":"","vzigzag":"","Wcirc":"","wcirc":"","wedbar":"","wedge":"","Wedge":"","wedgeq":"","weierp":"","Wfr":"","wfr":"","Wopf":"","wopf":"","wp":"","wr":"","wreath":"","Wscr":"","wscr":"","xcap":"","xcirc":"","xcup":"","xdtri":"","Xfr":"","xfr":"","xharr":"","xhArr":"","Xi":"","xi":"","xlarr":"","xlArr":"","xmap":"","xnis":"","xodot":"","Xopf":"","xopf":"","xoplus":"","xotime":"","xrarr":"","xrArr":"","Xscr":"","xscr":"","xsqcup":"","xuplus":"","xutri":"","xvee":"","xwedge":"","Yacute":"","yacute":"","YAcy":"","yacy":"","Ycirc":"","ycirc":"","Ycy":"","ycy":"","yen":"","Yfr":"","yfr":"","YIcy":"","yicy":"","Yopf":"","yopf":"","Yscr":"","yscr":"","YUcy":"","yucy":"","yuml":"","Yuml":"","Zacute":"","zacute":"","Zcaron":"","zcaron":"","Zcy":"","zcy":"","Zdot":"","zdot":"","zeetrf":"","ZeroWidthSpace":"","Zeta":"","zeta":"","zfr":"","Zfr":"","ZHcy":"","zhcy":"","zigrarr":"","zopf":"","Zopf":"","Zscr":"","zscr":"","zwj":"","zwnj":""}');

/***/ }),

/***/ 9591:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"Aacute":"","aacute":"","Acirc":"","acirc":"","acute":"","AElig":"","aelig":"","Agrave":"","agrave":"","amp":"&","AMP":"&","Aring":"","aring":"","Atilde":"","atilde":"","Auml":"","auml":"","brvbar":"","Ccedil":"","ccedil":"","cedil":"","cent":"","copy":"","COPY":"","curren":"","deg":"","divide":"","Eacute":"","eacute":"","Ecirc":"","ecirc":"","Egrave":"","egrave":"","ETH":"","eth":"","Euml":"","euml":"","frac12":"","frac14":"","frac34":"","gt":">","GT":">","Iacute":"","iacute":"","Icirc":"","icirc":"","iexcl":"","Igrave":"","igrave":"","iquest":"","Iuml":"","iuml":"","laquo":"","lt":"<","LT":"<","macr":"","micro":"","middot":"","nbsp":"","not":"","Ntilde":"","ntilde":"","Oacute":"","oacute":"","Ocirc":"","ocirc":"","Ograve":"","ograve":"","ordf":"","ordm":"","Oslash":"","oslash":"","Otilde":"","otilde":"","Ouml":"","ouml":"","para":"","plusmn":"","pound":"","quot":"\\"","QUOT":"\\"","raquo":"","reg":"","REG":"","sect":"","shy":"","sup1":"","sup2":"","sup3":"","szlig":"","THORN":"","thorn":"","times":"","Uacute":"","uacute":"","Ucirc":"","ucirc":"","Ugrave":"","ugrave":"","uml":"","Uuml":"","uuml":"","Yacute":"","yacute":"","yen":"","yuml":""}');

/***/ }),

/***/ 2586:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"amp":"&","apos":"\'","gt":">","lt":"<","quot":"\\""}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./node_modules/vue/dist/vue.js
var vue = __webpack_require__(1094);
var vue_default = /*#__PURE__*/__webpack_require__.n(vue);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/views/StandaloneSchemeView.vue?vue&type=template&id=6cc0ab02&
var render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "ssc-container",
      staticStyle: { position: "relative" },
      attrs: { oncontextmenu: "return false;" },
    },
    [
      _c("div", { staticClass: "ssc-header" }, [
        _c("div", { staticClass: "ssc-header-search" }, [
          _vm._v("\n            Zoom:\n            "),
          _c("input", {
            directives: [
              {
                name: "model",
                rawName: "v-model",
                value: _vm.textZoom,
                expression: "textZoom",
              },
            ],
            staticClass: "ssc-zoom",
            attrs: { type: "text" },
            domProps: { value: _vm.textZoom },
            on: {
              keydown: function ($event) {
                if (
                  !$event.type.indexOf("key") &&
                  _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                ) {
                  return null
                }
                return _vm.onZoomSubmitted.apply(null, arguments)
              },
              input: function ($event) {
                if ($event.target.composing) {
                  return
                }
                _vm.textZoom = $event.target.value
              },
            },
          }),
          _vm._v(" "),
          _c(
            "span",
            { staticClass: "ssc-button", on: { click: _vm.zoomToScheme } },
            [_vm._v("Auto-Zoom")]
          ),
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "ssc-header-right" }, [
          _vm._v("\n            built by "),
          _c("a", { attrs: { target: "_top", href: _vm.homeLink } }, [
            _vm._v("Schemio"),
          ]),
        ]),
      ]),
      _vm._v(" "),
      _c(
        "div",
        { staticClass: "ssc-body" },
        [
          _vm.schemeContainer
            ? _c("svg-editor", {
                ref: "svgEditor",
                attrs: {
                  "scheme-container": _vm.schemeContainer,
                  "offset-x": _vm.offsetX,
                  "offset-y": _vm.offsetY,
                  zoom: _vm.vZoom,
                  "use-mouse-wheel": _vm.useMouseWheel,
                  mode: "view",
                  userEventBus: _vm.userEventBus,
                },
                on: {
                  "mouse-wheel": _vm.mouseWheel,
                  "mouse-move": _vm.mouseMove,
                  "mouse-down": _vm.mouseDown,
                  "mouse-up": _vm.mouseUp,
                  "mouse-double-click": _vm.mouseDoubleClick,
                },
              })
            : _vm._e(),
          _vm._v(" "),
          _vm.itemTooltip.shown
            ? _c("item-tooltip", {
                attrs: {
                  item: _vm.itemTooltip.item,
                  x: _vm.itemTooltip.x,
                  y: _vm.itemTooltip.y,
                },
                on: {
                  close: function ($event) {
                    _vm.itemTooltip.shown = false
                  },
                },
              })
            : _vm._e(),
          _vm._v(" "),
          _vm.sidePanel.item
            ? _c(
                "div",
                {
                  staticClass: "ssc-side-panel-right",
                  style: { width: _vm.sidePanelWidth + "px" },
                },
                [
                  _c(
                    "div",
                    { staticClass: "ssc-side-panel-content" },
                    [
                      _c(
                        "span",
                        {
                          staticClass: "ssc-button",
                          on: {
                            click: function ($event) {
                              _vm.sidePanel.item = null
                            },
                          },
                        },
                        [_vm._v("Close")]
                      ),
                      _vm._v(" "),
                      _c("item-details", {
                        attrs: { item: _vm.sidePanel.item },
                      }),
                    ],
                    1
                  ),
                ]
              )
            : _vm._e(),
        ],
        1
      ),
    ]
  )
}
var staticRenderFns = []
render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/views/StandaloneSchemeView.vue?vue&type=template&id=6cc0ab02&

;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/SvgEditor.vue?vue&type=template&id=30c57726&lang=html&
var SvgEditorvue_type_template_id_30c57726_lang_html_render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    { staticClass: "svg-editor", attrs: { id: "svg-editor" } },
    [
      _c(
        "svg",
        {
          ref: "svgDomElement",
          class: _vm.cssClass,
          style: {
            background: _vm.schemeContainer.scheme.style.backgroundColor,
          },
          attrs: { id: "svg_plot", "data-void": "true" },
          on: {
            mousemove: _vm.mouseMove,
            mousedown: _vm.mouseDown,
            mouseup: _vm.mouseUp,
            dblclick: _vm.mouseDoubleClick,
            dragenter: _vm.onDragEnter,
            dragover: _vm.onDragOver,
            dragleave: _vm.onDragLeave,
          },
        },
        [
          _vm.mode === "view" && _vm.schemeContainer
            ? _c(
                "g",
                [
                  _c(
                    "g",
                    {
                      attrs: {
                        "data-type": "scene-transform",
                        transform: _vm.transformSvg,
                      },
                    },
                    [
                      _vm._l(_vm.schemeContainer.worldItems, function (item) {
                        return item.visible && item.shape !== "hud"
                          ? _c(
                              "g",
                              {
                                staticClass: "item-container",
                                class: "item-cursor-" + item.cursor,
                              },
                              [
                                _c("ItemSvg", {
                                  key:
                                    item.id +
                                    "-" +
                                    item.shape +
                                    "-" +
                                    _vm.textSelectionEnabled,
                                  attrs: {
                                    item: item,
                                    mode: _vm.mode,
                                    textSelectionEnabled:
                                      _vm.textSelectionEnabled,
                                    patchIndex: _vm.patchIndex,
                                  },
                                  on: {
                                    "custom-event": _vm.onItemCustomEvent,
                                    "frame-animator": _vm.onFrameAnimatorEvent,
                                  },
                                }),
                              ],
                              1
                            )
                          : _vm._e()
                      }),
                      _vm._v(" "),
                      _vm._l(_vm.worldHighlightedItems, function (item) {
                        return _c(
                          "g",
                          { attrs: { transform: item.transform } },
                          [
                            _c("path", {
                              staticStyle: { opacity: "0.5" },
                              attrs: {
                                d: item.path,
                                fill: "none",
                                stroke: item.stroke,
                                "stroke-width":
                                  item.strokeSize +
                                  6 / (item.scalingFactor * _vm.safeZoom) +
                                  "px",
                                "data-item-id": item.id,
                                "data-preview-ignore": "true",
                              },
                            }),
                          ]
                        )
                      }),
                      _vm._v(" "),
                      _vm.showClickableMarkers
                        ? _c(
                            "g",
                            { attrs: { "data-preview-ignore": "true" } },
                            _vm._l(_vm.clickableItemMarkers, function (marker) {
                              return marker.visible
                                ? _c("circle", {
                                    staticClass: "clickable-item-marker",
                                    attrs: {
                                      cx: marker.x,
                                      cy: marker.y,
                                      r: 5 / _vm.safeZoom,
                                      "data-item-id": marker.itemId,
                                      stroke:
                                        _vm.schemeContainer.scheme.style
                                          .itemMarkerColor,
                                      fill: _vm.schemeContainer.scheme.style
                                        .itemMarkerColor,
                                    },
                                  })
                                : _vm._e()
                            }),
                            0
                          )
                        : _vm._e(),
                    ],
                    2
                  ),
                  _vm._v(" "),
                  _vm._l(_vm.selectedItemLinks, function (link, linkIndex) {
                    return _c(
                      "g",
                      { attrs: { "data-preview-ignore": "true" } },
                      [
                        _c(
                          "a",
                          {
                            staticClass: "item-link",
                            attrs: {
                              id: "item-link-" + linkIndex,
                              "xlink:href": link.url,
                            },
                            on: {
                              click: function ($event) {
                                return _vm.onSvgItemLinkClick(
                                  link.url,
                                  arguments[0]
                                )
                              },
                            },
                          },
                          [
                            _c("circle", {
                              attrs: {
                                cx: link.x,
                                cy: link.y,
                                r: 12,
                                stroke:
                                  _vm.linkPalette[
                                    linkIndex % _vm.linkPalette.length
                                  ],
                                fill: _vm.linkPalette[
                                  linkIndex % _vm.linkPalette.length
                                ],
                              },
                            }),
                            _vm._v(" "),
                            _c(
                              "text",
                              {
                                staticClass: "item-link-icon",
                                class: ["link-icon-" + link.type],
                                attrs: {
                                  x: link.x - 6,
                                  y: link.y + 5,
                                  "font-size": 13 + "px",
                                  title: link.title,
                                },
                              },
                              [_vm._v(_vm._s(link.shortTitle))]
                            ),
                            _vm._v(" "),
                            _c(
                              "foreignObject",
                              {
                                attrs: {
                                  x: link.x + 16,
                                  y: link.y - 11,
                                  width: link.width,
                                  height: link.height,
                                },
                              },
                              [
                                _c("span", { staticClass: "item-link-title" }, [
                                  _vm._v(
                                    _vm._s(_vm._f("formatLinkTitle")(link))
                                  ),
                                ]),
                              ]
                            ),
                          ]
                        ),
                      ]
                    )
                  }),
                  _vm._v(" "),
                  _c(
                    "g",
                    _vm._l(_vm.schemeContainer.hudItems, function (hud) {
                      return hud.visible
                        ? _c(
                            "g",
                            {
                              style: {
                                opacity: hud.opacity / 100.0,
                                "mix-blend-mode": hud.blendMode,
                              },
                              attrs: { transform: _vm.createHUDTransform(hud) },
                            },
                            _vm._l(hud.childItems, function (item) {
                              return item.visible
                                ? _c("ItemSvg", {
                                    key:
                                      item.id +
                                      "-" +
                                      item.shape +
                                      "-" +
                                      _vm.textSelectionEnabled,
                                    attrs: {
                                      item: item,
                                      textSelectionEnabled:
                                        _vm.textSelectionEnabled,
                                      patchIndex: _vm.patchIndex,
                                      mode: _vm.mode,
                                    },
                                    on: {
                                      "custom-event": _vm.onItemCustomEvent,
                                      "frame-animator":
                                        _vm.onFrameAnimatorEvent,
                                    },
                                  })
                                : _vm._e()
                            }),
                            1
                          )
                        : _vm._e()
                    }),
                    0
                  ),
                ],
                2
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.mode === "edit"
            ? _c("g", [
                _c(
                  "g",
                  {
                    staticClass: "grid",
                    attrs: {
                      "data-preview-ignore": "true",
                      transform: _vm.gridTransform,
                      "data-void": "true",
                    },
                  },
                  [
                    _vm._l(_vm.gridCount.x, function (index) {
                      return _c("line", {
                        class: { "grid-line-zero": index === _vm.gridCount.x0 },
                        attrs: {
                          x1: index * _vm.gridStep,
                          y1: "0",
                          x2: index * _vm.gridStep,
                          y2: _vm.height + 2 * _vm.gridStep,
                          stroke: _vm.schemeContainer.scheme.style.gridColor,
                          "data-void": "true",
                        },
                      })
                    }),
                    _vm._v(" "),
                    _vm._l(_vm.gridCount.y, function (index) {
                      return _c("line", {
                        class: { "grid-line-zero": index === _vm.gridCount.y0 },
                        attrs: {
                          x1: "0",
                          y1: index * _vm.gridStep,
                          x2: _vm.width + 2 * _vm.gridStep,
                          y2: index * _vm.gridStep,
                          stroke: _vm.schemeContainer.scheme.style.gridColor,
                          "data-void": "true",
                        },
                      })
                    }),
                  ],
                  2
                ),
                _vm._v(" "),
                _c(
                  "g",
                  {
                    attrs: {
                      "data-type": "scene-transform",
                      transform: _vm.transformSvg,
                    },
                  },
                  [
                    _vm._l(_vm.schemeContainer.worldItems, function (item) {
                      return item.visible
                        ? _c(
                            "g",
                            {
                              staticClass: "item-container",
                              class: "item-cursor-" + item.cursor,
                            },
                            [
                              _c("ItemSvg", {
                                key: item.id + "-" + item.shape,
                                attrs: {
                                  item: item,
                                  patchIndex: _vm.patchIndex,
                                  mode: _vm.mode,
                                },
                              }),
                            ],
                            1
                          )
                        : _vm._e()
                    }),
                    _vm._v(" "),
                    _vm.schemeContainer.activeBoundaryBox
                      ? _c("g", { attrs: { "data-preview-ignore": "true" } }, [
                          _c("rect", {
                            staticClass: "boundary-box",
                            attrs: {
                              stroke:
                                _vm.schemeContainer.scheme.style
                                  .boundaryBoxColor,
                              x: _vm.schemeContainer.activeBoundaryBox.x,
                              y: _vm.schemeContainer.activeBoundaryBox.y,
                              width: _vm.schemeContainer.activeBoundaryBox.w,
                              height: _vm.schemeContainer.activeBoundaryBox.h,
                            },
                          }),
                        ])
                      : _vm._e(),
                    _vm._v(" "),
                    _vm._t("scene-transform"),
                    _vm._v(" "),
                    _vm._l(_vm.worldHighlightedItems, function (item) {
                      return _c(
                        "g",
                        { attrs: { transform: item.transform } },
                        [
                          _c("path", {
                            staticStyle: { opacity: "0.5" },
                            attrs: {
                              d: item.path,
                              fill: "none",
                              stroke: item.stroke,
                              "stroke-width":
                                item.strokeSize +
                                6 / (item.scalingFactor * _vm.safeZoom) +
                                "px",
                              "data-item-id": item.id,
                              "stroke-linejoin": "round",
                              "data-preview-ignore": "true",
                            },
                          }),
                          _vm._v(" "),
                          _vm._l(item.pins, function (pin) {
                            return _c("circle", {
                              staticStyle: { opacity: "0.5" },
                              attrs: {
                                cx: pin.x,
                                cy: pin.y,
                                r: 8 / (item.scalingFactor * _vm.safeZoom),
                                "data-preview-ignore": "true",
                                fill: item.stroke,
                              },
                            })
                          }),
                        ],
                        2
                      )
                    }),
                  ],
                  2
                ),
                _vm._v(" "),
                _vm.multiSelectBox
                  ? _c("g", [
                      _c("rect", {
                        staticClass: "multi-select-box",
                        attrs: {
                          x: _vm._x(_vm.multiSelectBox.x),
                          y: _vm._y(_vm.multiSelectBox.y),
                          width: _vm._z(_vm.multiSelectBox.w),
                          height: _vm._z(_vm.multiSelectBox.h),
                        },
                      }),
                    ])
                  : _vm._e(),
                _vm._v(" "),
                _vm.horizontalSnapper
                  ? _c("line", {
                      staticStyle: {
                        stroke: "red",
                        opacity: "0.4",
                        "stroke-width": "1px",
                      },
                      attrs: {
                        x1: 0,
                        y1: _vm._y(_vm.horizontalSnapper.value),
                        x2: _vm.width,
                        y2: _vm._y(_vm.horizontalSnapper.value),
                      },
                    })
                  : _vm._e(),
                _vm._v(" "),
                _vm.verticalSnapper
                  ? _c("line", {
                      staticStyle: {
                        stroke: "red",
                        opacity: "0.4",
                        "stroke-width": "1px",
                      },
                      attrs: {
                        x1: _vm._x(_vm.verticalSnapper.value),
                        y1: 0,
                        x2: _vm._x(_vm.verticalSnapper.value),
                        y2: _vm.height,
                      },
                    })
                  : _vm._e(),
                _vm._v(" "),
                _vm.stateLayerShown
                  ? _c("rect", {
                      staticClass: "state-hover-layer",
                      attrs: {
                        x: "0",
                        y: "0",
                        width: _vm.width,
                        height: _vm.height,
                        fill: "rgba(255, 255, 255, 0.0)",
                      },
                    })
                  : _vm._e(),
              ])
            : _vm._e(),
        ]
      ),
      _vm._v(" "),
      _vm._t("overlay"),
    ],
    2
  )
}
var SvgEditorvue_type_template_id_30c57726_lang_html_staticRenderFns = []
SvgEditorvue_type_template_id_30c57726_lang_html_render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/SvgEditor.vue?vue&type=template&id=30c57726&lang=html&

// EXTERNAL MODULE: ./node_modules/lodash/map.js
var map = __webpack_require__(5161);
var map_default = /*#__PURE__*/__webpack_require__.n(map);
// EXTERNAL MODULE: ./node_modules/lodash/max.js
var max = __webpack_require__(6162);
var max_default = /*#__PURE__*/__webpack_require__.n(max);
// EXTERNAL MODULE: ./node_modules/lodash/forEach.js
var lodash_forEach = __webpack_require__(4486);
var forEach_default = /*#__PURE__*/__webpack_require__.n(lodash_forEach);
// EXTERNAL MODULE: ./node_modules/lodash/find.js
var find = __webpack_require__(3311);
var find_default = /*#__PURE__*/__webpack_require__.n(find);
// EXTERNAL MODULE: ./src/ui/myMath.js
var myMath = __webpack_require__(3590);
// EXTERNAL MODULE: ./src/ui/scheme/Item.js
var Item = __webpack_require__(7196);
// EXTERNAL MODULE: ./src/ui/scheme/ItemFixer.js
var ItemFixer = __webpack_require__(1377);
// EXTERNAL MODULE: ./src/ui/components/editor/EventBus.js
var EventBus = __webpack_require__(536);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/ItemSvg.vue?vue&type=template&id=65809a37&lang=html&
var ItemSvgvue_type_template_id_65809a37_lang_html_render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "g",
    {
      style: {
        opacity: _vm.item.opacity / 100.0,
        "mix-blend-mode": _vm.item.blendMode,
      },
      attrs: {
        transform: _vm.svgItemTransform,
        "data-svg-item-container-id": _vm.item.id,
        "data-item-id": _vm.item.id,
      },
    },
    [
      _vm._l(_vm.backgroundEffects, function (backgroundEffectHTML) {
        return _c("g", {
          domProps: { innerHTML: _vm._s(backgroundEffectHTML) },
        })
      }),
      _vm._v(" "),
      _c(
        "defs",
        _vm._l(_vm.svgFilters, function (svgFilter) {
          return _c("filter", {
            attrs: {
              id: svgFilter.id,
              x: "-50%",
              y: "-50%",
              width: "200%",
              height: "200%",
            },
            domProps: { innerHTML: _vm._s(svgFilter.html) },
          })
        }),
        0
      ),
      _vm._v(" "),
      _c(
        "g",
        { attrs: { filter: _vm.filterUrl } },
        [
          _vm.shouldBeDrawn && _vm.shapeComponent && _vm.item.visible
            ? _c(_vm.shapeComponent, {
                key:
                  "item-component-" +
                  _vm.item.id +
                  "-" +
                  _vm.item.shape +
                  "-" +
                  _vm.revision,
                tag: "component",
                style: { opacity: _vm.item.selfOpacity / 100.0 },
                attrs: { item: _vm.item, mode: _vm.mode },
                on: {
                  "custom-event": _vm.onShapeCustomEvent,
                  "frame-animator": _vm.onFrameAnimatorEvent,
                },
              })
            : _vm._e(),
          _vm._v(" "),
          !_vm.shapeComponent &&
          _vm.item.visible &&
          _vm.shapeType === "standard" &&
          _vm.itemStandardCurves
            ? _c(
                "g",
                { style: { opacity: _vm.item.selfOpacity / 100.0 } },
                [
                  _c("advanced-fill", {
                    key: "advanced-fill-" + _vm.item.id + "-" + _vm.revision,
                    attrs: {
                      fillId: "fill-pattern-" + _vm.item.id,
                      fill: _vm.item.shapeProps.fill,
                      area: _vm.item.area,
                    },
                  }),
                  _vm._v(" "),
                  _vm._l(_vm.itemStandardCurves, function (curve) {
                    return _c("path", {
                      attrs: {
                        d: curve.path,
                        "stroke-width": curve.strokeSize + "px",
                        stroke: curve.strokeColor,
                        "stroke-dasharray": _vm.strokeDashArray,
                        "data-item-id": _vm.item.id,
                        "stroke-linejoin": "round",
                        fill: curve.fill,
                      },
                    })
                  }),
                ],
                2
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.shapeType === "missing" && _vm.item.visible
            ? _c("g", { staticClass: "missing-shape" }, [
                _c("rect", {
                  attrs: {
                    x: "0",
                    y: "0",
                    width: _vm.item.area.w,
                    height: _vm.item.area.h,
                  },
                }),
                _vm._v(" "),
                _c(
                  "foreignObject",
                  {
                    attrs: {
                      x: "0",
                      y: "0",
                      width: _vm.item.area.w,
                      height: _vm.item.area.h,
                    },
                  },
                  [
                    _c(
                      "div",
                      {
                        style: {
                          width: _vm.item.area.w + "px",
                          height: _vm.item.area.h + "px",
                        },
                        attrs: { xmlns: "http://www.w3.org/1999/xhtml" },
                      },
                      [
                        _c("div", { style: _vm.missingShapeTextStyle }, [
                          _vm._v("Missing Shape"),
                        ]),
                      ]
                    ),
                  ]
                ),
              ])
            : _vm._e(),
          _vm._v(" "),
          _vm._l(_vm.textSlots, function (slot) {
            return slot.name !== _vm.hiddenTextSlotName
              ? _c("g", [
                  _c(
                    "foreignObject",
                    {
                      ref: "textSlots",
                      refInFor: true,
                      attrs: {
                        "data-text-slot-name": slot.name,
                        id: "item-text-slot-" + _vm.item.id + "-" + slot.name,
                        x: slot.area.x,
                        y: slot.area.y,
                        width: slot.area.w,
                        height: slot.area.h,
                      },
                    },
                    [
                      _c(
                        "div",
                        {
                          staticClass: "item-text-container",
                          class: slot.cssClass,
                          style: slot.style,
                          attrs: {
                            xmlns: "http://www.w3.org/1999/xhtml",
                            "data-item-id": _vm.item.id,
                          },
                        },
                        [
                          _c("div", {
                            staticClass: "item-text-element",
                            staticStyle: { display: "inline-block" },
                            attrs: {
                              "data-item-text-element-item-id": _vm.item.id,
                            },
                            domProps: { innerHTML: _vm._s(slot.sanitizedText) },
                          }),
                        ]
                      ),
                    ]
                  ),
                ])
              : _vm._e()
          }),
        ],
        2
      ),
      _vm._v(" "),
      _vm._l(_vm.foregroundEffects, function (foregroundEffectHTML) {
        return _c("g", {
          domProps: { innerHTML: _vm._s(foregroundEffectHTML) },
        })
      }),
      _vm._v(" "),
      _c("g", {
        attrs: {
          id: "animation-container-" + _vm.item.id,
          "data-preview-ignore": "true",
        },
      }),
      _vm._v(" "),
      _vm.item._childItems && _vm.item.visible && _vm.mode === "edit"
        ? _c(
            "g",
            { style: _vm.childrenLayerStyle },
            _vm._l(_vm.item._childItems, function (childItem) {
              return childItem.visible
                ? _c("ItemSvg", {
                    key:
                      childItem.id +
                      "-" +
                      childItem.shape +
                      "-" +
                      _vm.item.meta.revision,
                    attrs: {
                      item: childItem,
                      patchIndex: _vm.patchIndex,
                      mode: _vm.mode,
                    },
                    on: {
                      "custom-event": function ($event) {
                        return _vm.$emit("custom-event", arguments[0])
                      },
                      "frame-animator": _vm.onFrameAnimatorEvent,
                    },
                  })
                : _vm._e()
            }),
            1
          )
        : _vm._e(),
      _vm._v(" "),
      _vm.itemSvgOutlinePath &&
      _vm.shouldDrawEventLayer &&
      !_vm.textSelectionEnabled
        ? _c("path", {
            staticClass: "svg-event-layer",
            style: { cursor: _vm.item.cursor },
            attrs: {
              "data-preview-ignore": "true",
              id: "item-svg-path-" + _vm.item.id,
              d: _vm.itemSvgOutlinePath,
              "data-item-id": _vm.item.id,
              "stroke-width": _vm.hoverPathStrokeWidth,
              stroke: "rgba(255, 255, 255, 0)",
              fill: _vm.hoverPathFill,
            },
          })
        : _vm._e(),
      _vm._v(" "),
      _vm.shapeType === "missing"
        ? _c("rect", {
            staticClass: "svg-event-layer",
            attrs: {
              "data-preview-ignore": "true",
              "data-item-id": _vm.item.id,
              x: "0",
              y: "0",
              width: _vm.item.area.w,
              height: _vm.item.area.h,
              stroke: "rgba(255, 255, 255, 0)",
              fill: _vm.hoverPathFill,
            },
          })
        : _vm._e(),
      _vm._v(" "),
      _vm.item.clip
        ? _c("defs", [
            _c("clipPath", { attrs: { id: "item-clip-path-" + _vm.item.id } }, [
              _vm.itemSvgOutlinePath
                ? _c("path", {
                    staticClass: "svg-event-layer",
                    attrs: {
                      d: _vm.itemSvgOutlinePath,
                      "data-item-id": _vm.item.id,
                      "stroke-width": "0px",
                      stroke: "rgba(255, 255, 255, 0)",
                      fill: "rgba(255, 255, 255, 0)",
                    },
                  })
                : _vm._e(),
            ]),
          ])
        : _vm._e(),
      _vm._v(" "),
      _vm.itemSvgOutlinePath &&
      _vm.patchOutline &&
      _vm.patchIsDiffColoringEnabled
        ? _c("path", {
            attrs: {
              "data-preview-ignore": "true",
              d: _vm.itemSvgOutlinePath,
              "data-item-id": _vm.item.id,
              "stroke-width": _vm.patchOutlineStrokeSize,
              stroke: _vm.patchOutline,
              fill: "none",
            },
          })
        : _vm._e(),
      _vm._v(" "),
      _vm.item.childItems && _vm.item.visible
        ? _c(
            "g",
            { style: _vm.childrenLayerStyle },
            _vm._l(_vm.item.childItems, function (childItem) {
              return childItem.visible &&
                ((childItem.shape !== "hud" && _vm.mode === "view") ||
                  _vm.mode === "edit")
                ? _c("ItemSvg", {
                    key:
                      childItem.id +
                      "-" +
                      childItem.shape +
                      "-" +
                      _vm.textSelectionEnabled,
                    attrs: {
                      item: childItem,
                      textSelectionEnabled: _vm.textSelectionEnabled,
                      patchIndex: _vm.patchIndex,
                      mode: _vm.mode,
                    },
                    on: {
                      "custom-event": function ($event) {
                        return _vm.$emit("custom-event", arguments[0])
                      },
                      "frame-animator": _vm.onFrameAnimatorEvent,
                    },
                  })
                : _vm._e()
            }),
            1
          )
        : _vm._e(),
      _vm._v(" "),
      _vm.item._childItems && _vm.item.visible && _vm.mode === "view"
        ? _c(
            "g",
            { style: _vm.childrenLayerStyle },
            _vm._l(_vm.item._childItems, function (childItem) {
              return childItem.visible && childItem.shape !== "hud"
                ? _c("ItemSvg", {
                    key:
                      childItem.id +
                      "-" +
                      childItem.shape +
                      "-" +
                      _vm.textSelectionEnabled,
                    attrs: {
                      item: childItem,
                      textSelectionEnabled: _vm.textSelectionEnabled,
                      mode: _vm.mode,
                    },
                    on: {
                      "custom-event": function ($event) {
                        return _vm.$emit("custom-event", arguments[0])
                      },
                      "frame-animator": _vm.onFrameAnimatorEvent,
                    },
                  })
                : _vm._e()
            }),
            1
          )
        : _vm._e(),
    ],
    2
  )
}
var ItemSvgvue_type_template_id_65809a37_lang_html_staticRenderFns = []
ItemSvgvue_type_template_id_65809a37_lang_html_render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/items/ItemSvg.vue?vue&type=template&id=65809a37&lang=html&

// EXTERNAL MODULE: ./src/ui/components/editor/items/AdvancedFill.vue + 4 modules
var AdvancedFill = __webpack_require__(6777);
// EXTERNAL MODULE: ./src/ui/components/editor/items/StrokePattern.js
var StrokePattern = __webpack_require__(4502);
// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/Shape.js
var Shape = __webpack_require__(3363);
// EXTERNAL MODULE: ./src/ui/utils.js
var ui_utils = __webpack_require__(4691);
// EXTERNAL MODULE: ./src/htmlSanitize.js
var htmlSanitize = __webpack_require__(3762);
var htmlSanitize_default = /*#__PURE__*/__webpack_require__.n(htmlSanitize);
// EXTERNAL MODULE: ./src/ui/components/editor/text/ItemText.js
var ItemText = __webpack_require__(5635);
;// CONCATENATED MODULE: ./src/ui/components/effects/Effects.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */





function svgElement(name, attrs, childElements) {
  const el = document.createElementNS('http://www.w3.org/2000/svg', name);

  if (attrs) {
    forEach_default()(attrs, (value, attrName) => {
      el.setAttribute(attrName, value);
    });
  }

  if (childElements) {
    forEach_default()(childElements, child => {
      el.appendChild(child);
    });
  }

  return el;
}

const $ = svgElement;
const effects = {
  'drop-shadow': {
    name: 'Drop Shadow',
    args: {
      color: {
        type: 'color',
        value: 'rgba(0,0,0,1.0)',
        name: 'Color'
      },
      dx: {
        type: 'number',
        value: 10,
        name: 'Offset X'
      },
      dy: {
        type: 'number',
        value: 10,
        name: 'Offset Y'
      },
      blur: {
        type: 'number',
        value: 5,
        name: 'Blur',
        min: 0,
        max: 100
      },
      opacity: {
        type: 'number',
        value: 50,
        name: 'Opacity (%)',
        min: 0,
        max: 100
      },
      inside: {
        type: 'boolean',
        value: false,
        name: 'Inside'
      }
    },

    applyEffect(item, effectIdx, effectArgs) {
      const shape = Shape/* default.find */.Z.find(item.shape);

      if (!shape) {
        return null;
      }

      const path = shape.computeOutline(item);

      if (!path) {
        return null;
      }

      const filterId = `item-effect-drop-shadow-${item.id}-${effectIdx}`;

      if (effectArgs.inside) {
        return {
          kind: 'svg-filter',
          html: $('g', {}, [$('feComponentTransfer', {
            in: 'SourceAlpha'
          }, [$('feFuncA', {
            type: 'table',
            tableValues: '1 0'
          })]), $('feGaussianBlur', {
            stdDeviation: effectArgs.blur
          }), $('feOffset', {
            dx: effectArgs.dx,
            dy: effectArgs.dy,
            result: 'offsetblur'
          }), $('feFlood', {
            'flood-color': effectArgs.color,
            result: 'color',
            'flood-opacity': effectArgs.opacity / 100.0
          }), $('feComposite', {
            in2: 'offsetblur',
            operator: 'in'
          }), $('feComposite', {
            in2: 'SourceAlpha',
            operator: 'in'
          }), $('feMerge', {}, [$('feMergeNode', {
            in: 'SourceGraphic'
          }), $('feMergeNode')])]).innerHTML
        };
      } else {
        return {
          kind: 'back',
          html: $('g', {}, [$('defs', {}, [$('filter', {
            id: filterId,
            x: '-500%',
            y: '-500%',
            width: '2000%',
            height: '2000%'
          }, [$('feGaussianBlur', {
            in: 'SourceGraphic',
            stdDeviation: effectArgs.blur
          })])]), $('path', {
            d: path,
            stroke: 'none',
            fill: effectArgs.color,
            transform: `translate(${effectArgs.dx} ${effectArgs.dy})`,
            style: `opacity: ${effectArgs.opacity / 100.0}`,
            filter: `url(#${filterId})`
          })]).innerHTML
        };
      }
    }

  },
  'blur': {
    name: 'Blur',
    args: {
      size: {
        type: 'number',
        value: 5,
        name: 'Size'
      }
    },

    applyEffect(item, effectIdx, effectArgs) {
      return {
        kind: 'svg-filter',
        html: $('feGaussianBlur', {
          in: 'SourceGraphic',
          stdDeviation: effectArgs.size
        }).outerHTML
      };
    }

  },
  'glow': {
    name: 'Glow',
    args: {
      color: {
        type: 'color',
        value: 'rgba(126,237,255,1.0)',
        name: 'Color'
      },
      size: {
        type: 'number',
        value: 3,
        name: 'Size',
        min: 0,
        max: 100
      },
      blur: {
        type: 'number',
        value: 5,
        name: 'Blur',
        min: 0,
        max: 100
      },
      opacity: {
        type: 'number',
        value: 50,
        name: 'Opacity (%)',
        min: 0,
        max: 100
      }
    },

    applyEffect(item, effectIdx, effectArgs) {
      const shape = Shape/* default.find */.Z.find(item.shape);

      if (!shape) {
        return null;
      }

      const path = shape.computeOutline(item);

      if (!path) {
        return null;
      }

      const filterId = `item-effect-glow-${item.id}-${effectIdx}`;
      let strokeSize = effectArgs.size;
      const strokeSizeArgDef = Shape/* default.getShapePropDescriptor */.Z.getShapePropDescriptor(shape, 'strokeSize');

      if (strokeSizeArgDef && strokeSizeArgDef.type === 'number') {
        strokeSize = effectArgs.size + item.shapeProps['strokeSize'];
      }

      return {
        kind: 'front',
        html: $('g', {}, [$('defs', {}, [$('filter', {
          id: filterId,
          x: '-500%',
          y: '-500%',
          width: '2000%',
          height: '2000%'
        }, [$('feGaussianBlur', {
          in: 'SourceGraphic',
          stdDeviation: effectArgs.blur
        })])]), $('path', {
          d: path,
          'data-item-id': item.id,
          stroke: effectArgs.color,
          'stroke-width': `${strokeSize}px`,
          fill: 'none',
          style: `opacity: ${effectArgs.opacity / 100.0}`,
          filter: `url(#${filterId})`
        })]).innerHTML
      };
    }

  },
  'repeat': {
    name: 'Repeat',
    args: {
      repeat: {
        type: 'number',
        value: 3,
        name: 'Repeat',
        min: 1,
        max: 20
      },
      dx: {
        type: 'number',
        value: 10,
        name: 'Offset X'
      },
      dy: {
        type: 'number',
        value: -10,
        name: 'Offset Y'
      },
      fade: {
        type: 'number',
        value: 0,
        name: 'Fade (%)',
        min: 0,
        max: 100
      }
    },

    applyEffect(item, effectIdx, effectArgs) {
      const shape = Shape/* default.find */.Z.find(item.shape);

      if (!shape) {
        return null;
      }

      const itemStandardCurves = Shape/* default.computeStandardCurves */.Z.computeStandardCurves(item, shape);

      if (!itemStandardCurves) {
        return null;
      }

      const root = svgElement('g', {});

      for (let i = 0; i < effectArgs.repeat; i++) {
        const x = (effectArgs.repeat - i) * effectArgs.dx;
        const y = (effectArgs.repeat - i) * effectArgs.dy;
        let start = 100;
        let end = 100 - effectArgs.fade;
        let t = (i + 1) / effectArgs.repeat;
        let opacity = (start * t + end * (1 - t)) / 100;
        const g = svgElement('g', {
          transform: `translate(${x}, ${y})`,
          style: `opacity: ${opacity}`
        });
        let strokeDashArray = '';

        if (shape.shapeType === 'standard') {
          strokeDashArray = StrokePattern/* default.createDashArray */.Z.createDashArray(item.shapeProps.strokePattern, item.shapeProps.strokeSize);
        }

        forEach_default()(itemStandardCurves, curve => {
          g.appendChild(svgElement('path', {
            d: curve.path,
            fill: curve.fill,
            stroke: curve.strokeColor,
            'stroke-width': `${curve.strokeSize}px`,
            'stroke-dasharray': strokeDashArray,
            'stroke-linejoin': 'round'
          }));
        });
        root.appendChild(g);
      }

      return {
        kind: 'back',
        html: root.innerHTML
      };
    }

  },
  'adjust-color': {
    name: 'Adjust Color',
    args: {
      matrix: {
        type: 'color-matrix',
        name: 'Color matrix',
        value: [[1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0]]
      }
    },

    applyEffect(item, effectIdx, effectArgs) {
      let matrixEncoded = '1 0 0 0 0' + '0 1 0 0 0' + '0 0 1 0 0' + '0 0 0 1 0';

      if (Array.isArray(effectArgs.matrix)) {
        matrixEncoded = '';
        effectArgs.matrix.forEach(row => {
          if (Array.isArray(row)) {
            matrixEncoded += row.join(' ');
          } else {
            matrixEncoded += '0 0 0 0 0';
          }

          matrixEncoded += ' ';
        });
      }

      return {
        kind: 'svg-filter',
        html: $('feColorMatrix', {
          type: 'matrix',
          values: matrixEncoded
        }).outerHTML
      };
    }

  }
};
/**
 * Generates args with default values for specified effect
 * @param {Effect} effect 
 * @returns 
 */

function generateEffectArgs(effect) {
  if (!effect) {
    return {};
  }

  const props = {};
  forEach(effect.args, (arg, argName) => {
    props[argName] = utils.clone(arg.value);
  });
  return props;
}
function getEffects() {
  return effects;
}
function findEffect(effectId) {
  return effects[effectId];
}
function getDefaultEffectId() {
  return 'drop-shadow';
}
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/items/ItemSvg.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//











function generateFilters(item) {
  const svgFilters = [];
  let filterUrl = '';
  const backgroundEffects = [];
  const foregroundEffects = [];
  forEach_default()(item.effects, (itemEffect, idx) => {
    const effect = findEffect(itemEffect.effect);

    if (effect) {
      const generatedEffect = effect.applyEffect(item, idx, itemEffect.args);

      if (generatedEffect.kind === 'svg-filter') {
        const filterId = `item-svg-filter-effect-${item.id}-${idx}`;
        svgFilters.push({
          id: filterId,
          html: generatedEffect.html
        });
        filterUrl += `url(#${filterId}) `;
      } else if (generatedEffect.kind === 'back') {
        backgroundEffects.push(generatedEffect.html);
      } else if (generatedEffect.kind === 'front') {
        foregroundEffects.push(generatedEffect.html);
      }
    }
  });
  return {
    svgFilters,
    filterUrl,
    backgroundEffects,
    foregroundEffects
  };
}

function hasStrokeSizeProp(shape) {
  const descriptor = Shape/* default.getShapePropDescriptor */.Z.getShapePropDescriptor(shape, 'strokeSize');
  return descriptor && descriptor.type === 'number';
}

/* harmony default export */ const ItemSvgvue_type_script_lang_js_ = ({
  name: 'ItemSvg',
  props: {
    item: {
      type: Object
    },
    mode: {
      type: String
    },
    patchIndex: {
      type: Object,
      default: null
    },
    mode: {
      type: String,
      default: 'edit'
    },
    textSelectionEnabled: {
      type: Boolean,
      default: false
    }
  },
  components: {
    AdvancedFill: AdvancedFill/* default */.Z
  },

  mounted() {
    this.switchShape(this.item.shape);
    EventBus/* default.subscribeForItemChanged */.Z.subscribeForItemChanged(this.item.id, this.onItemChanged);
    EventBus/* default.$on */.Z.$on(EventBus/* default.ITEM_TEXT_SLOT_EDIT_TRIGGERED */.Z.ITEM_TEXT_SLOT_EDIT_TRIGGERED, this.onItemTextSlotEditTriggered);
    EventBus/* default.$on */.Z.$on(EventBus/* default.ITEM_TEXT_SLOT_EDIT_CANCELED */.Z.ITEM_TEXT_SLOT_EDIT_CANCELED, this.onItemTextSlotEditCanceled);
    const shape = Shape/* default.find */.Z.find(this.item.shape);

    if (shape && shape.shapeEvents.mounted) {
      shape.shapeEvents.mounted(this.$store, this.item, {
        textSlots: this.$refs.textSlots
      });
    }
  },

  beforeDestroy() {
    EventBus/* default.unsubscribeForItemChanged */.Z.unsubscribeForItemChanged(this.item.id, this.onItemChanged);
    EventBus/* default.$off */.Z.$off(EventBus/* default.ITEM_TEXT_SLOT_EDIT_TRIGGERED */.Z.ITEM_TEXT_SLOT_EDIT_TRIGGERED, this.onItemTextSlotEditTriggered);
    EventBus/* default.$off */.Z.$off(EventBus/* default.ITEM_TEXT_SLOT_EDIT_CANCELED */.Z.ITEM_TEXT_SLOT_EDIT_CANCELED, this.onItemTextSlotEditCanceled);
  },

  data() {
    const shape = Shape/* default.find */.Z.find(this.item.shape);
    const data = {
      shapeType: shape ? shape.shapeType : 'missing',
      shapeComponent: null,
      oldShape: this.item.shape,
      itemStandardCurves: [],
      itemSvgOutlinePath: null,
      shouldDrawEventLayer: true,
      shouldRenderText: true,
      // using revision in order to trigger full re-render of item component
      // on each item changed event revision is incremented
      revision: 0,
      textSlots: [],
      // name of text slot that should not be drawn
      // this is used when in-place text slot edit is triggered
      hiddenTextSlotName: null,
      strokeDashArray: '',
      supportsStrokeSize: shape ? hasStrokeSizeProp(shape) : false,
      svgFilters: [],
      filterUrl: '',
      backgroundEffects: [],
      foregroundEffects: [],
      svgItemTransform: this.calculateSVGItemTransform()
    };

    if (shape) {
      if (!shape.editorProps || !shape.editorProps.customTextRendering) {
        data.textSlots = this.generateTextSlots();
      } else {
        data.shouldRenderText = false;
      }
    }

    const {
      svgFilters,
      filterUrl,
      backgroundEffects,
      foregroundEffects
    } = generateFilters(this.item);
    data.svgFilters = svgFilters;
    data.filterUrl = filterUrl;
    data.backgroundEffects = backgroundEffects;
    data.foregroundEffects = foregroundEffects;
    return data;
  },

  methods: {
    calculateSVGItemTransform() {
      const m = myMath/* default.standardTransformWithArea */.Z.standardTransformWithArea(myMath/* default.identityMatrix */.Z.identityMatrix(), this.item.area);
      return `matrix(${m[0][0]},${m[1][0]},${m[0][1]},${m[1][1]},${m[0][2]},${m[1][2]})`;
    },

    switchShape(shapeId) {
      this.oldShape = this.item.shape;
      const shape = Shape/* default.find */.Z.find(shapeId);

      if (!shape) {
        return;
      }

      this.shapeType = shape.shapeType;
      this.supportsStrokeSize = hasStrokeSizeProp(shape);

      if (shape.editorProps && shape.editorProps.ignoreEventLayer && this.mode === 'view' || this.mode === 'view' && this.textSelectionEnabled) {
        this.shouldDrawEventLayer = false;
      }

      if (shape.vueComponent) {
        this.shapeComponent = shape.vueComponent;
      } else {
        this.shapeComponent = null;
      }

      if (shape.shapeType === 'standard') {
        this.strokeDashArray = StrokePattern/* default.createDashArray */.Z.createDashArray(this.item.shapeProps.strokePattern, this.item.shapeProps.strokeSize);
        this.itemStandardCurves = Shape/* default.computeStandardCurves */.Z.computeStandardCurves(this.item, shape);
      }

      this.itemSvgOutlinePath = shape.computeOutline(this.item);
    },

    onItemChanged(propertyPath) {
      this.svgItemTransform = this.calculateSVGItemTransform();
      const shape = Shape/* default.find */.Z.find(this.item.shape);

      if (!shape) {
        this.revision += 1;
        return;
      }

      if (this.oldShape !== this.item.shape) {
        this.switchShape(this.item.shape);
      } else if (shape) {
        // re-computing item svg path for event layer
        if (shape.shapeType === 'standard') {
          this.strokeDashArray = StrokePattern/* default.createDashArray */.Z.createDashArray(this.item.shapeProps.strokePattern, this.item.shapeProps.strokeSize);
          this.itemStandardCurves = Shape/* default.computeStandardCurves */.Z.computeStandardCurves(this.item, shape);
        }

        this.itemSvgOutlinePath = shape.computeOutline(this.item);
      }

      if (!shape.editorProps || !shape.editorProps.customTextRendering) {
        this.textSlots = this.generateTextSlots();
      } //updating filters


      const {
        svgFilters,
        filterUrl,
        backgroundEffects,
        foregroundEffects
      } = generateFilters(this.item);
      this.svgFilters = svgFilters;
      this.filterUrl = filterUrl;
      this.backgroundEffects = backgroundEffects;
      this.foregroundEffects = foregroundEffects;
      this.revision += 1;
      this.$forceUpdate();
    },

    onShapeCustomEvent(eventName, ...args) {
      this.$emit('custom-event', {
        itemId: this.item.id,
        eventName: eventName,
        args: arguments
      });
    },

    onFrameAnimatorEvent(args) {
      this.$emit('frame-animator', args);
    },

    generateTextSlots() {
      const shape = Shape/* default.find */.Z.find(this.item.shape);

      if (!shape) {
        return [];
      }

      const slots = ui_utils/* default.clone */.Z.clone(shape.getTextSlots(this.item));
      const filteredSlots = [];
      forEach_default()(slots, slot => {
        const itemTextSlot = this.item.textSlots[slot.name];

        if (itemTextSlot) {
          slot.text = itemTextSlot.text || '';
          slot.sanitizedText = htmlSanitize_default()(slot.text);

          if (!slot.cssClass) {
            slot.cssClass = '';
          }

          slot.style = (0,ItemText/* generateTextStyle */.A)(itemTextSlot);
          slot.style.width = `${slot.area.w}px`;
          slot.style.height = `${slot.area.h}px`;
          filteredSlots.push(slot);
        }
      });
      return filteredSlots;
    },

    onItemTextSlotEditTriggered(item, slotName, area, markupDisabled) {
      if (item.id === this.item.id) {
        this.hiddenTextSlotName = slotName;
      }
    },

    onItemTextSlotEditCanceled(item, slotName) {
      if (item.id === this.item.id && this.hiddenTextSlotName === slotName) {
        this.hiddenTextSlotName = null;
      }
    }

  },
  computed: {
    hoverPathStrokeWidth() {
      if (this.supportsStrokeSize) {
        return parseInt(this.item.shapeProps.strokeSize) + 2 + 'px';
      }

      return '0px';
    },

    hoverPathFill() {
      if (this.item.shape === 'path') {
        if (this.item.shapeProps.fill && this.item.shapeProps.fill.type === 'none') {
          return 'none';
        }
      }

      if (this.item.shape === 'connector' && !this.item.shapeProps.fat) {
        return 'none';
      }

      return 'rgba(255, 255, 255, 0)';
    },

    shouldBeDrawn() {
      if (!this.shapeComponent) {
        return false;
      }

      if (!this.item.visible) {
        return false;
      }

      if (this.mode === 'view' && this.shapeComponent.shapeConfig.editorProps && this.shapeComponent.shapeConfig.editorProps.onlyEditMode) {
        return false;
      }

      return true;
    },

    childrenLayerStyle() {
      if (this.item.clip) {
        return {
          'clip-path': `url(#item-clip-path-${this.item.id})`
        };
      }

      return {};
    },

    patchOutline() {
      if (this.patchIndex) {
        if (this.patchIndex.addedItems.has(this.item.id)) {
          return this.$store.getters.patchAdditionsColor;
        }

        if (this.patchIndex.deletedItems.has(this.item.id)) {
          return this.$store.getters.patchDeletionsColor;
        }

        if (this.patchIndex.modifiedItems.has(this.item.id)) {
          return this.$store.getters.patchModificationsColor;
        }
      }

      return null;
    },

    patchIsDiffColoringEnabled() {
      return this.$store.getters.patchIsDiffColoringEnabled;
    },

    patchOutlineStrokeSize() {
      if (this.supportsStrokeSize) {
        return parseInt(this.item.shapeProps.strokeSize) + 10 + 'px';
      }

      return '8px';
    },

    missingShapeTextStyle() {
      const fontSize = Math.min(this.item.area.w, this.item.area.h) / 6;
      return {
        'font-size': `${fontSize}px`,
        display: 'inline-block'
      };
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/items/ItemSvg.vue?vue&type=script&lang=js&
 /* harmony default export */ const items_ItemSvgvue_type_script_lang_js_ = (ItemSvgvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__(1900);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/ItemSvg.vue





/* normalize component */
;
var component = (0,componentNormalizer/* default */.Z)(
  items_ItemSvgvue_type_script_lang_js_,
  ItemSvgvue_type_template_id_65809a37_lang_html_render,
  ItemSvgvue_type_template_id_65809a37_lang_html_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var api; }
component.options.__file = "src/ui/components/editor/items/ItemSvg.vue"
/* harmony default export */ const ItemSvg = (component.exports);
// EXTERNAL MODULE: ./src/ui/components/editor/LinkTypes.js
var LinkTypes = __webpack_require__(9874);
// EXTERNAL MODULE: ./src/ui/scheme/SchemeContainer.js + 6 modules
var SchemeContainer = __webpack_require__(8566);
// EXTERNAL MODULE: ./src/ui/userevents/Compiler.js
var Compiler = __webpack_require__(2672);
// EXTERNAL MODULE: ./src/ui/animations/AnimationRegistry.js
var AnimationRegistry = __webpack_require__(9737);
// EXTERNAL MODULE: ./src/ui/animations/ValueAnimation.js
var ValueAnimation = __webpack_require__(3805);
// EXTERNAL MODULE: ./src/ui/userevents/Events.js
var Events = __webpack_require__(6085);
;// CONCATENATED MODULE: ./src/ui/store/StoreUtils.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




/* harmony default export */ const store_StoreUtils = ({
  setItemControlPoints(store, item) {
    const shape = Shape/* default.find */.Z.find(item.shape);

    if (shape && shape.controlPoints) {
      const controlPoints = shape.controlPoints.make(item); // since item control points are supposed to be used by multi-item edit box
      // and it uses scale of 1 always
      // we need to convert positions of those points
      // by recalculating the complete scaling effect of the item relative to the world

      const scalingVector = (0,SchemeContainer/* worldScalingVectorOnItem */.pD)(item);
      forEach_default()(controlPoints, controlPoint => {
        controlPoint.x = controlPoint.x * scalingVector.x;
        controlPoint.y = controlPoint.y * scalingVector.y;
      });
      store.dispatch('setItemControlPoints', controlPoints);
    } else {
      this.clearItemControlPoints(store);
    }
  },

  clearItemControlPoints(store) {
    store.dispatch('clearItemControlPoints');
  },

  updateAllCurveEditPoints(store, item) {
    // the following action will reset all the curve eidt points in store
    store.dispatch('setCurveEditItem', item);
  },

  updateCurveEditPoint(store, item, pathId, pointId, point) {
    store.dispatch('updateCurveEditPoint', {
      item,
      pathId,
      pointId,
      point
    });
  },

  toggleCurveEditPointSelection(store, pathId, pointId, inclusive) {
    store.dispatch('toggleCurveEditPointSelection', {
      pathId,
      pointId,
      inclusive
    });
  },

  resetCurveEditPointSelection(store) {
    store.dispatch('resetCurveEditPointSelection');
  },

  selectCurveEditPoint(store, pathId, pointId, inclusive) {
    store.dispatch('selectCurveEditPoint', {
      pathId,
      pointId,
      inclusive
    });
  },

  getCurveEditPaths(store) {
    return store.state.curveEditing.paths;
  },

  setMultiSelectBox(store, box) {
    store.dispatch('setMultiSelectBox', box);
  },

  setSelectedConnectorPath(store, path) {
    store.dispatch('setSelectedConnectorPath', path);
  },

  /**
   * 
   * @param {*} store 
   * @param {ItemSnapper} snapper 
   */
  setItemSnapper(store, snapper) {
    store.dispatch('setItemSnapper', snapper);
  },

  clearItemSnappers(store) {
    store.dispatch('clearItemSnappers');
  },

  setAutoRemount(store, shouldAutoRemount) {
    store.dispatch('setAutoRemount', shouldAutoRemount);
  },

  setShowPivot(store, show) {
    store.dispatch('setShowPivot', show);
  },

  setShowClickableMarkers(store, show) {
    store.dispatch('setShowClickableMarkers', show);
  },

  proposeConnectorDestinationItems(store, connectorItemId, mx, my) {
    store.dispatch('proposeConnectorDestinationItems', {
      connectorItemId,
      mx,
      my
    });
  },

  disableProposeConnectorDestinationItems(store) {
    store.dispatch('disableProposeConnectorDestinationItems');
  },

  addInfoSystemMessage(store, message, id) {
    store.dispatch('addSystemMessage', {
      status: 'info',
      message,
      id
    });
  },

  addErrorSystemMessage(store, message, id) {
    store.dispatch('addSystemMessage', {
      status: 'error',
      message,
      id
    });
  },

  removeSystemMessage(store, id) {
    store.dispatch('removeSystemMessage', id);
  },

  startAnimationEditor(store, framePlayer) {
    store.dispatch('startAnimationEditor', framePlayer);
  },

  setAnimationEditorRecording(store, isRecording) {
    store.dispatch('setAnimationEditorRecording', isRecording);
  },

  setDefaultConnectorSmoothing(store, smoothing) {
    store.dispatch('setDefaultConnectorSmoothing', smoothing);
  },

  copyItemStyle(store, item) {
    store.dispatch('copyItemStyle', item);
  },

  // used in connecting state and set the current connector item that is being created
  setCurrentConnector(store, item) {
    store.dispatch('setCurrentConnector', item);
  },

  addArtPack(store, artPackId, artPack) {
    store.dispatch('addArtPack', {
      artPack,
      artPackId
    });
  },

  removeArtPack(store, artPackId) {
    store.dispatch('removeArtPack', artPackId);
  },

  registerShapeGroupId(store, shapeGroupId) {
    store.dispatch('registerShapeGroupId', shapeGroupId);
  }

});
// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/Component.vue + 4 modules
var Component = __webpack_require__(332);
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/SvgEditor.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




















const EMPTY_OBJECT = {
  type: 'void'
};
const LINK_FONT_SYMBOL_SIZE = 10;
const behaviorCompiler = new Compiler/* default */.Z();
/**
 * This variable is used for storing the last known position of mouse cursor
 * The reason this is needed is because some items handle click event themselves.
 * Because of this the position of the mouse is not available.
 * But the mouse position is needed to render item tooltip.
 * That is why these coords get updated on each mouse move and click event inside SvgEditor component.
 */

const lastMousePosition = {
  x: 0,
  y: 0
};
/* harmony default export */ const SvgEditorvue_type_script_lang_js_ = ({
  props: {
    offline: {
      type: Boolean,
      default: false
    },
    mode: {
      type: String,
      default: 'edit'
    },
    textSelectionEnabled: {
      type: Boolean,
      default: false
    },
    stateLayerShown: {
      type: Boolean,
      default: false
    },
    userEventBus: {
      type: Object,
      default: null
    },
    patchIndex: {
      type: Object,
      default: null
    },

    /** @type {SchemeContainer} */
    schemeContainer: {
      default: null,
      type: Object
    },
    zoom: {
      default: 1.0,
      type: Number
    },
    useMouseWheel: {
      default: true,
      type: Boolean
    }
  },
  components: {
    ItemSvg: ItemSvg
  },

  beforeMount() {
    if (this.mode === 'view') {
      store_StoreUtils.setShowClickableMarkers(this.$store, this.schemeContainer.scheme.style.itemMarkerToggled);
      this.buildClickableItemMarkers();
      this.reindexUserEvents();
      this.prepareFrameAnimations();
    }

    EventBus/* default.$on */.Z.$on(EventBus/* default.BRING_TO_VIEW */.Z.BRING_TO_VIEW, this.onBringToView);
    EventBus/* default.$on */.Z.$on(EventBus/* default.ITEM_LINKS_SHOW_REQUESTED */.Z.ITEM_LINKS_SHOW_REQUESTED, this.onShowItemLinks);
    EventBus/* default.$on */.Z.$on(EventBus/* default.ANY_ITEM_CLICKED */.Z.ANY_ITEM_CLICKED, this.onAnyItemClicked);
    EventBus/* default.$on */.Z.$on(EventBus/* default.ANY_ITEM_SELECTED */.Z.ANY_ITEM_SELECTED, this.onAnyItemSelected);
    EventBus/* default.$on */.Z.$on(EventBus/* default.VOID_CLICKED */.Z.VOID_CLICKED, this.onVoidClicked);
    EventBus/* default.$on */.Z.$on(EventBus/* default.VOID_DOUBLE_CLICKED */.Z.VOID_DOUBLE_CLICKED, this.onVoidDoubleClicked);
    EventBus/* default.$on */.Z.$on(EventBus/* default.ITEMS_HIGHLIGHTED */.Z.ITEMS_HIGHLIGHTED, this.highlightItems);
    EventBus/* default.$on */.Z.$on(EventBus/* default.COMPONENT_SCHEME_MOUNTED */.Z.COMPONENT_SCHEME_MOUNTED, this.onComponentSchemeMounted);
    EventBus/* default.$on */.Z.$on(EventBus/* default.COMPONENT_LOAD_FAILED */.Z.COMPONENT_LOAD_FAILED, this.onComponentLoadFailed);
    EventBus/* default.$on */.Z.$on(EventBus/* default.FRAME_PLAYER_PREPARED */.Z.FRAME_PLAYER_PREPARED, this.onFramePlayerPrepared);
    EventBus/* default.$on */.Z.$on(EventBus/* default.CLICKABLE_MARKERS_TOGGLED */.Z.CLICKABLE_MARKERS_TOGGLED, this.updateClickableMarkers);
  },

  mounted() {
    this.updateSvgSize();
    window.addEventListener("resize", this.updateSvgSize);

    if (this.useMouseWheel) {
      var svgElement = this.$refs.svgDomElement;

      if (svgElement) {
        svgElement.addEventListener('wheel', this.mouseWheel);
      }
    }

    if (this.mode === 'view') {
      forEach_default()(this.itemsForInit, (val, itemId) => {
        this.userEventBus.emitItemEvent(itemId, Events/* default.standardEvents.init.id */.Z.standardEvents.init.id);
      });
    }
  },

  beforeDestroy() {
    window.removeEventListener("resize", this.updateSvgSize);
    this.mouseEventsEnabled = false;
    EventBus/* default.$off */.Z.$off(EventBus/* default.BRING_TO_VIEW */.Z.BRING_TO_VIEW, this.onBringToView);
    EventBus/* default.$off */.Z.$off(EventBus/* default.ITEM_LINKS_SHOW_REQUESTED */.Z.ITEM_LINKS_SHOW_REQUESTED, this.onShowItemLinks);
    EventBus/* default.$off */.Z.$off(EventBus/* default.ANY_ITEM_CLICKED */.Z.ANY_ITEM_CLICKED, this.onAnyItemClicked);
    EventBus/* default.$off */.Z.$off(EventBus/* default.ANY_ITEM_SELECTED */.Z.ANY_ITEM_SELECTED, this.onAnyItemSelected);
    EventBus/* default.$off */.Z.$off(EventBus/* default.VOID_CLICKED */.Z.VOID_CLICKED, this.onVoidClicked);
    EventBus/* default.$off */.Z.$off(EventBus/* default.VOID_DOUBLE_CLICKED */.Z.VOID_DOUBLE_CLICKED, this.onVoidDoubleClicked);
    EventBus/* default.$off */.Z.$off(EventBus/* default.ITEMS_HIGHLIGHTED */.Z.ITEMS_HIGHLIGHTED, this.highlightItems);
    EventBus/* default.$off */.Z.$off(EventBus/* default.COMPONENT_SCHEME_MOUNTED */.Z.COMPONENT_SCHEME_MOUNTED, this.onComponentSchemeMounted);
    EventBus/* default.$off */.Z.$off(EventBus/* default.COMPONENT_LOAD_FAILED */.Z.COMPONENT_LOAD_FAILED, this.onComponentLoadFailed);
    EventBus/* default.$off */.Z.$off(EventBus/* default.FRAME_PLAYER_PREPARED */.Z.FRAME_PLAYER_PREPARED, this.onFramePlayerPrepared);
    EventBus/* default.$off */.Z.$off(EventBus/* default.CLICKABLE_MARKERS_TOGGLED */.Z.CLICKABLE_MARKERS_TOGGLED, this.updateClickableMarkers);

    if (this.useMouseWheel) {
      var svgElement = this.$refs.svgDomElement;

      if (svgElement) {
        svgElement.removeEventListener('wheel', this.mouseWheel);
      }
    }
  },

  data() {
    return {
      mouseEventsEnabled: !(this.mode === 'view' && this.textSelectionEnabled),
      linkPalette: ['#ec4b4b', '#bd4bec', '#4badec', '#5dec4b', '#cba502', '#02cbcb'],
      // the following two properties are going to be updated in mounted hook
      width: window.innerWidth,
      height: window.innerHeight,
      selectedItemLinks: [],
      lastHoveredItem: null,
      // ids of items that have subscribed for Init event
      itemsForInit: {},
      // array of markers for items that are clickable
      clickableItemMarkers: [],
      worldHighlightedItems: []
    };
  },

  methods: {
    updateSvgSize() {
      const svgRect = this.$refs.svgDomElement.getBoundingClientRect();
      this.width = svgRect.width;
      this.height = svgRect.height;
      this.schemeContainer.screenSettings.width = svgRect.width;
      this.schemeContainer.screenSettings.height = svgRect.height;
      this.$emit('svg-size-updated', {
        width: this.width,
        height: this.height
      });
    },

    mouseCoordsFromEvent(event) {
      return this.mouseCoordsFromPageCoords(event.pageX, event.pageY);
    },

    mouseCoordsFromPageCoords(pageX, pageY) {
      var rect = this.$refs.svgDomElement.getBoundingClientRect(),
          offsetX = pageX - rect.left,
          offsetY = pageY - rect.top;
      return {
        x: Math.round(offsetX),
        y: Math.round(offsetY)
      };
    },

    identifyElement(element, point) {
      if (element) {
        const elementType = element.getAttribute('data-type');

        if (elementType === 'path-segment') {
          return {
            type: elementType,
            pathIndex: parseInt(element.getAttribute('data-path-index')),
            segmentIndex: parseInt(element.getAttribute('data-path-segment-index'))
          };
        } else if (elementType === 'path-point') {
          return {
            type: elementType,
            pointIndex: parseInt(element.getAttribute('data-path-point-index')),
            pathIndex: parseInt(element.getAttribute('data-path-index'))
          };
        } else if (elementType === 'path-control-point') {
          return {
            type: elementType,
            pointIndex: parseInt(element.getAttribute('data-path-point-index')),
            pathIndex: parseInt(element.getAttribute('data-path-index')),
            controlPointIndex: parseInt(element.getAttribute('data-path-control-point-index'))
          };
        } else if (elementType === 'multi-item-edit-box' || elementType === 'multi-item-edit-box-rotational-dragger' || elementType === 'multi-item-edit-box-pivot-dragger' || elementType === 'multi-item-edit-box-reset-image-crop-link') {
          return {
            type: elementType,
            multiItemEditBox: this.schemeContainer.multiItemEditBox
          };
        } else if (elementType === 'multi-item-edit-box-resize-dragger') {
          return {
            type: elementType,
            multiItemEditBox: this.schemeContainer.multiItemEditBox,
            draggerEdges: map_default()(element.getAttribute('data-dragger-edges').split(','), edge => edge.trim())
          };
        }

        const itemId = element.getAttribute('data-item-id');

        if (itemId) {
          const item = this.schemeContainer.findItemById(itemId);

          if (item) {
            return {
              type: 'item',
              item
            };
          }
        }

        const connectorStarterItemId = element.getAttribute('data-connector-starter-item-id');

        if (connectorStarterItemId) {
          const item = this.schemeContainer.findItemById(connectorStarterItemId);

          if (item) {
            return {
              type: 'connection-starter',
              connectorStarter: {
                item,
                point
              }
            };
          }
        }

        const controlPointId = element.getAttribute('data-control-point-id');

        if (controlPointId) {
          const item = this.schemeContainer.findItemById(element.getAttribute('data-control-point-item-id'));

          if (item) {
            return {
              type: 'control-point',
              controlPoint: {
                pointId: controlPointId,
                item
              }
            };
          }
        }

        const textContainerElement = element.closest('.item-text-element');

        if (textContainerElement) {
          const item = this.schemeContainer.findItemById(textContainerElement.getAttribute('data-item-text-element-item-id'));

          if (item) {
            return {
              type: 'item-text-element',
              itemTextElement: {
                item
              }
            };
          }
        }
      }

      return EMPTY_OBJECT;
    },

    mouseWheel(event) {
      var coords = this.mouseCoordsFromEvent(event);
      var p = this.toLocalPoint(coords.x, coords.y);
      this.$emit('mouse-wheel', p.x, p.y, coords.x, coords.y, event);
    },

    mouseMove(event) {
      if (this.mouseEventsEnabled) {
        const coords = this.mouseCoordsFromEvent(event);
        const p = this.toLocalPoint(coords.x, coords.y);
        lastMousePosition.x = coords.x;
        lastMousePosition.y = coords.y;
        this.$emit('mouse-move', p.x, p.y, coords.x, coords.y, this.identifyElement(event.srcElement, p), event);
      }
    },

    mouseDown(event) {
      if (this.mouseEventsEnabled) {
        var coords = this.mouseCoordsFromEvent(event);
        var p = this.toLocalPoint(coords.x, coords.y);
        lastMousePosition.x = coords.x;
        lastMousePosition.y = coords.y;
        this.$emit('mouse-down', p.x, p.y, coords.x, coords.y, this.identifyElement(event.srcElement, p), event);
      }
    },

    mouseUp(event) {
      if (this.mouseEventsEnabled) {
        var coords = this.mouseCoordsFromEvent(event);
        var p = this.toLocalPoint(coords.x, coords.y);
        this.$emit('mouse-up', p.x, p.y, coords.x, coords.y, this.identifyElement(event.srcElement, p), event);
      }
    },

    mouseDoubleClick(event) {
      if (this.mouseEventsEnabled) {
        var coords = this.mouseCoordsFromEvent(event);
        var p = this.toLocalPoint(coords.x, coords.y);
        this.$emit('mouse-double-click', p.x, p.y, coords.x, coords.y, this.identifyElement(event.srcElement, p), event);
      }
    },

    buildClickableItemMarkers() {
      const markers = [];

      const traverseVisibleItems = (itemArray, callback) => {
        if (!itemArray || !Array.isArray(itemArray)) {
          return;
        }

        itemArray.forEach(item => {
          if (item.visible && item.opacity > 0 && item.selfOpacity > 0) {
            callback(item);
            traverseVisibleItems(item.childItems, callback);
            traverseVisibleItems(item._childItems, callback);
          }
        });
      };

      traverseVisibleItems(this.schemeContainer.worldItems, item => {
        const hasItemLinks = item.links && item.links.length > 0;
        const hasItemClickEvents = find_default()(item.behavior.events, event => event.event === Events/* default.standardEvents.clicked.id */.Z.standardEvents.clicked.id);

        if ((0,Item/* hasItemDescription */.U3)(item) || hasItemLinks || hasItemClickEvents) {
          const box = this.schemeContainer.getBoundingBoxOfItems([item]);
          markers.push({
            x: box.x + box.w,
            y: box.y,
            itemId: item.id,
            visible: true
          });
        }
      });
      this.clickableItemMarkers = markers;
    },

    updateClickableMarkers() {
      if (this.mode === 'view') {
        this.buildClickableItemMarkers();
        this.$forceUpdate();
      }
    },

    highlightItems(itemIds, options) {
      const highlightPins = options ? options.highlightPins : false;
      this.worldHighlightedItems = [];
      forEach_default()(itemIds, itemId => {
        const item = this.schemeContainer.findItemById(itemId);

        if (!item) {
          return;
        }

        const shape = Shape/* default.find */.Z.find(item.shape);

        if (!shape) {
          return;
        }

        const path = shape.computeOutline(item);

        if (!path) {
          return;
        }

        const m = (0,SchemeContainer/* itemCompleteTransform */.aR)(item);
        const scalingVector = (0,SchemeContainer/* worldScalingVectorOnItem */.pD)(item);
        let scalingFactor = Math.max(scalingVector.x, scalingVector.y);

        if (myMath/* default.tooSmall */.Z.tooSmall(scalingFactor)) {
          scalingFactor = 1;
        }

        let fill = this.schemeContainer.scheme.style.boundaryBoxColor;
        let strokeSize = 6;

        if (item.shape === 'path') {
          strokeSize = item.shapeProps.strokeSize;

          if (item.shapeProps.fill.type === 'none' && !item.shapeProps.closed) {
            fill = 'none';
          }
        } else {
          const shape = Shape/* default.find */.Z.find(item.shape);

          if (Shape/* default.getShapePropDescriptor */.Z.getShapePropDescriptor(shape, 'strokeSize')) {
            strokeSize = item.shapeProps.strokeSize;
          }
        }

        const itemHighlight = {
          id: itemId,
          transform: `matrix(${m[0][0]},${m[1][0]},${m[0][1]},${m[1][1]},${m[0][2]},${m[1][2]})`,
          path,
          fill,
          strokeSize,
          stroke: this.schemeContainer.scheme.style.boundaryBoxColor,
          pins: [],
          scalingFactor
        };

        if (highlightPins) {
          itemHighlight.pins = shape.getPins(item);
        }

        this.worldHighlightedItems.push(itemHighlight);
      });
    },

    reindexUserEvents() {
      if (this.userEventBus) {
        this.userEventBus.clear();
        this.indexUserEventsInItems(this.schemeContainer.scheme.items, this.itemsForInit);
      }
    },

    /**
     *
     * @param {Array} items
     * @param {Object} itemsForInit - used for collecting items that have subscribed for init event
     */
    indexUserEventsInItems(items, itemsForInit) {
      forEach_default()(items, rootItem => {
        (0,Item/* traverseItems */.Hp)(rootItem, item => {
          if (item.behavior && item.behavior.events) {
            forEach_default()(item.behavior.events, event => {
              const eventCallback = behaviorCompiler.compileActions(this.schemeContainer, item, event.actions);

              if (event.event === Events/* default.standardEvents.init.id */.Z.standardEvents.init.id) {
                itemsForInit[item.id] = 1;
              }

              this.userEventBus.subscribeItemEvent(item.id, event.event, eventCallback);
            });
          }
        });
      });
    },

    onComponentSchemeMounted(item) {
      if (item._childItems) {
        const componentItemsForInit = {};
        this.indexUserEventsInItems(item._childItems, componentItemsForInit);
        forEach_default()(componentItemsForInit, (val, itemId) => {
          this.userEventBus.emitItemEvent(itemId, Events/* default.standardEvents.init.id */.Z.standardEvents.init.id);
        });
      }

      if (item.shape === 'component' && this.userEventBus) {
        this.userEventBus.emitItemEvent(item.id, Component/* COMPONENT_LOADED_EVENT */.lK);
      }
    },

    onComponentLoadFailed(item) {
      if (item.shape === 'component' && this.userEventBus) {
        this.userEventBus.emitItemEvent(item.id, Component/* COMPONENT_FAILED */.LM);
      }
    },

    /**
     * Compiles animations for all frame players in the scheme so that they could be played in view mode
     */
    prepareFrameAnimations() {
      this.schemeContainer.prepareFrameAnimations();
    },

    onFramePlayerPrepared(item, frameCallbacks) {
      if (this.mode !== 'view') {
        return;
      }

      const frameAnimation = this.schemeContainer.getFrameAnimation(item.id);

      if (!frameAnimation) {
        return;
      }

      frameAnimation.setCallbacks(frameCallbacks);
    },

    onFrameAnimatorEvent(args) {
      if (this.mode !== 'view') {
        return;
      }

      const itemId = args.item.id;
      const frameAnimation = this.schemeContainer.getFrameAnimation(itemId);

      if (!frameAnimation) {
        return;
      }

      if (args.operation === 'play') {
        frameAnimation.setCallbacks(args.callbacks);
        frameAnimation.setFrame(args.frame);

        if (args.stopFrame) {
          frameAnimation.setStopFrame(args.stopFrame);
        } else {
          frameAnimation.setStopFrame(-1);
        }

        AnimationRegistry/* default.play */.Z.play(frameAnimation, itemId, 'frame-player');
      } else if (args.operation === 'setFrame') {
        frameAnimation.toggleFrame(args.frame);
      } else if (args.operation === 'stop') {
        frameAnimation.stop();
      }
    },

    onSvgItemLinkClick(url, event) {
      if (url.startsWith('/')) {
        window.location = url;
        event.preventDefault();
      }

      return false;
    },

    onShowItemLinks(item) {
      if (this.mode === 'view') {
        this.selectedItemLinks = this.generateItemLinks(item);
        this.$nextTick(() => {
          //readjusting links width and height
          forEach_default()(this.selectedItemLinks, (link, index) => {
            const domLinkTitle = document.querySelector(`#item-link-${index} span.item-link-title`);

            if (domLinkTitle) {
              const bbRect = domLinkTitle.getBoundingClientRect();
              link.width = bbRect.width;
              link.height = bbRect.height;
            }
          });
        });
        this.startLinksAnimation();
      }
    },

    onAnyItemClicked(item) {
      this.removeDrawnLinks();
      this.resetHighlightedItems();
    },

    onAnyItemSelected() {
      this.resetHighlightedItems();
    },

    resetHighlightedItems() {
      if (this.worldHighlightedItems.length > 0) {
        this.worldHighlightedItems = [];
      }
    },

    onVoidClicked() {
      this.removeDrawnLinks();
    },

    onVoidDoubleClicked(x, y, mx, my) {
      if (this.mode === 'edit') {
        const textItem = ui_utils/* default.clone */.Z.clone(Item/* defaultItem */.XZ);
        textItem.name = this.schemeContainer.copyNameAndMakeUnique('Label');
        textItem.textSlots = {
          body: {
            text: '',
            halign: 'left',
            valign: 'top',
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            paddingBottom: 0
          }
        };
        textItem.shape = 'none';
        textItem.area = {
          x,
          y,
          w: 40,
          h: 40
        };
        (0,ItemFixer/* enrichItemWithDefaults */.z9)(textItem);
        this.schemeContainer.addItem(textItem);
        this.$nextTick(() => {
          EventBus/* default.emitItemTextSlotEditTriggered */.Z.emitItemTextSlotEditTriggered(textItem, 'body', {
            x: 0,
            y: 0,
            w: textItem.area.w,
            h: textItem.area.h
          }, false, true);
        });
      }
    },

    removeDrawnLinks() {
      if (this.selectedItemLinks.length > 0) {
        this.selectedItemLinks = [];
      }
    },

    onBringToView(area, animated) {
      let newZoom = 1.0;

      if (area.w > 0 && area.h > 0 && this.width - 400 > 0 && this.height > 0) {
        newZoom = Math.floor(100.0 * Math.min(this.width / area.w, this.height / area.h)) / 100.0;
        newZoom = Math.max(0.0001, newZoom);
      }

      if (newZoom > 0.7 && newZoom < 1) {
        newZoom = 1;
      }

      const oldX = this.schemeContainer.screenTransform.x;
      const oldY = this.schemeContainer.screenTransform.y;
      const oldZoom = this.schemeContainer.screenTransform.scale;
      const destX = this.width / 2 - (area.x + area.w / 2) * newZoom;
      const destY = this.height / 2 - (area.y + area.h / 2) * newZoom;

      if (animated) {
        AnimationRegistry/* default.play */.Z.play(new ValueAnimation/* default */.ZP({
          durationMillis: 400,
          animationType: 'ease-out',
          update: t => {
            this.schemeContainer.screenTransform.scale = oldZoom * (1.0 - t) + newZoom * t;
            this.schemeContainer.screenTransform.x = oldX * (1.0 - t) + destX * t;
            this.schemeContainer.screenTransform.y = oldY * (1.0 - t) + destY * t;
          },
          destroy: () => {
            this.informUpdateOfScreenTransform(this.schemeContainer.screenTransform);
          }
        }), 'screen', 'screen-tansform');
      } else {
        this.schemeContainer.screenTransform.scale = newZoom;
        this.schemeContainer.screenTransform.x = destX;
        this.schemeContainer.screenTransform.y = destY;
        this.informUpdateOfScreenTransform(this.schemeContainer.screenTransform);
      }
    },

    startLinksAnimation() {
      AnimationRegistry/* default.play */.Z.play(new ValueAnimation/* default */.ZP({
        durationMillis: 300,
        update: t => {
          forEach_default()(this.selectedItemLinks, link => {
            link.x = link.startX * (1.0 - t) + link.destinationX * t;
            link.y = link.startY * (1.0 - t) + link.destinationY * t;
          });
        }
      }), 'screen', 'links-animation');
    },

    generateItemLinks(item) {
      if (item.links && item.links.length > 0) {
        const worldPointCenter = this.schemeContainer.worldPointOnItem(item.area.w / 2, item.area.h / 2, item);

        let cx = this._x(worldPointCenter.x);

        let cy = this._y(worldPointCenter.y);

        let startX = cx;
        let startY = cy;

        if (cy > this.height - 100 || cy < 100) {
          cy = this.height / 4;
        }

        let step = 40;
        let y0 = cy - item.links.length * step / 2;
        const worldPointRight = this.schemeContainer.worldPointOnItem(item.area.w, 0, item);
        let destinationX = this._x(worldPointRight.x) + 10; // taking side panel into account

        if (destinationX > this.width - 500) {
          let maxLinkLength = max_default()(map_default()(item.links, link => link.title ? link.title.length : link.url.length));

          const leftX = this._x(this.schemeContainer.worldPointOnItem(0, 0, item).x);

          destinationX = leftX - maxLinkLength * LINK_FONT_SYMBOL_SIZE;
        } // perhaps not the best way to handle this, but for now this trick should do
        // drive app uses different type of router and therefor we need to adjust the url so that it can properly reference other diagrams


        const convertLinkUrl = link => {
          if (link.type === 'doc' && link.url && link.url.startsWith('/docs/') && this.$router && this.$router.mode !== 'history') {
            return '#' + link.url;
          }

          return link.url;
        };

        return map_default()(item.links, (link, index) => {
          return {
            url: convertLinkUrl(link),
            type: link.type,
            shortTitle: this.getFontAwesomeSymbolForLink(link),
            title: link.title,
            x: cx,
            y: cy,
            startX,
            startY,
            destinationX,
            destinationY: y0 + step * index,
            width: 1000,
            height: 30
          };
        });
      }

      return [];
    },

    informUpdateOfScreenTransform(screenTransform) {
      EventBus/* default.$emit */.Z.$emit(EventBus/* default.SCREEN_TRANSFORM_UPDATED */.Z.SCREEN_TRANSFORM_UPDATED, screenTransform);
    },

    calculateLinkBackgroundRectWidth(link) {
      if (link.title) {
        return link.title.length * LINK_FONT_SYMBOL_SIZE;
      } else {
        return link.url.length * LINK_FONT_SYMBOL_SIZE;
      }
    },

    getFontAwesomeSymbolForLink(link) {
      return LinkTypes/* default.findTypeByNameOrDefault */.Z.findTypeByNameOrDefault(link.type).fontAwesomeSymbol;
    },

    toLocalPoint(mouseX, mouseY) {
      return {
        x: (mouseX - this.schemeContainer.screenTransform.x) / this.schemeContainer.screenTransform.scale,
        y: (mouseY - this.schemeContainer.screenTransform.y) / this.schemeContainer.screenTransform.scale
      };
    },

    onItemCustomEvent(event) {
      if (event.eventName === 'clicked') {
        // handling links and toolip/side-panel appearance
        const item = this.schemeContainer.findItemById(event.itemId);

        if (item.links && item.links.length > 0) {
          this.onShowItemLinks(item);
        }

        if (item.description.trim().length > 8) {
          if (item.interactionMode === Item/* ItemInteractionMode.SIDE_PANEL */.pp.SIDE_PANEL) {
            EventBus/* default.$emit */.Z.$emit(EventBus/* default.ITEM_SIDE_PANEL_TRIGGERED */.Z.ITEM_SIDE_PANEL_TRIGGERED, item);
          } else if (item.interactionMode === Item/* ItemInteractionMode.TOOLTIP */.pp.TOOLTIP) {
            EventBus/* default.$emit */.Z.$emit(EventBus/* default.ITEM_TOOLTIP_TRIGGERED */.Z.ITEM_TOOLTIP_TRIGGERED, item, lastMousePosition.x, lastMousePosition.y);
          }
        }
      }

      if (this.userEventBus) {
        this.userEventBus.emitItemEvent(event.itemId, event.eventName);
      }
    },

    /**
     * Generates transform for HUD item so that it is rendered in correct position in view mode
     */
    createHUDTransform(hud) {
      let x = 0;
      let y = 0;

      if (hud.shapeProps.horizontalPosition === 'left') {
        x = 0;
      } else if (hud.shapeProps.horizontalPosition === 'right') {
        x = this.width - hud.area.w;
      } else if (hud.shapeProps.horizontalPosition === 'center') {
        x = (this.width - hud.area.w) / 2;
      }

      if (hud.shapeProps.verticalPosition === 'top') {
        y = 0;
      } else if (hud.shapeProps.verticalPosition === 'bottom') {
        y = this.height - hud.area.h;
      } else if (hud.shapeProps.verticalPosition === 'center') {
        y = (this.height - hud.area.h) / 2;
      }

      return `translate(${x} ${y})`;
    },

    onDragEnter(event) {
      event.preventDefault();
      event.stopPropagation();
    },

    onDragOver(event) {
      event.preventDefault();
      event.stopPropagation();
    },

    onDragLeave(event) {
      event.preventDefault();
      event.stopPropagation();
    },

    //calculates from world to screen
    _x(x) {
      return x * this.schemeContainer.screenTransform.scale + this.schemeContainer.screenTransform.x;
    },

    _y(y) {
      return y * this.schemeContainer.screenTransform.scale + this.schemeContainer.screenTransform.y;
    },

    _z(v) {
      return v * this.schemeContainer.screenTransform.scale;
    },

    //TODO apparently something is off if the formula is identical to conversion from world to screen. This needs to be investigated
    //calculates from screen to world
    x_(x) {
      return x * this.schemeContainer.screenTransform.scale + this.schemeContainer.screenTransform.x;
    },

    y_(y) {
      return y * this.schemeContainer.screenTransform.scale + this.schemeContainer.screenTransform.y;
    },

    z_(v) {
      return v * this.schemeContainer.screenTransform.scale;
    }

  },
  computed: {
    cssClass() {
      const css = ['mode-' + this.mode];

      if (!(this.mode === 'view' && this.textSelectionEnabled)) {
        css.push('text-nonselectable');
      }

      return css;
    },

    safeZoom() {
      if (this.schemeContainer.screenTransform.scale > 0.00001) {
        return this.schemeContainer.screenTransform.scale;
      }

      return 1.0;
    },

    transformSvg() {
      const x = Math.floor(this.schemeContainer.screenTransform.x || 0);
      const y = Math.floor(this.schemeContainer.screenTransform.y || 0);
      const scale = this.schemeContainer.screenTransform.scale || 1.0;
      return `translate(${x} ${y}) scale(${scale} ${scale})`;
    },

    gridStep() {
      const snapSize = myMath/* default.getSnappingWidthForScale */.Z.getSnappingWidthForScale(this.schemeContainer.screenTransform.scale);
      return snapSize * this.schemeContainer.screenTransform.scale;
    },

    gridCount() {
      const snapSize = myMath/* default.getSnappingWidthForScale */.Z.getSnappingWidthForScale(this.schemeContainer.screenTransform.scale);
      const screenStep = snapSize * this.schemeContainer.screenTransform.scale;

      if (screenStep < 4) {
        return {
          x: 0,
          y: 0,
          x0: 0,
          y0: 0
        };
      }

      const x = Math.ceil(this.width / screenStep) + 1;
      const y = Math.ceil(this.height / screenStep) + 1;
      const zSnap = snapSize * this.schemeContainer.screenTransform.scale;
      let dx = Math.ceil(this.schemeContainer.screenTransform.x % zSnap) - zSnap;
      let dy = Math.ceil(this.schemeContainer.screenTransform.y % zSnap) - zSnap;
      return {
        x,
        y,
        x0: Math.ceil((this._x(0) - dx) / screenStep),
        y0: Math.ceil((this._y(0) - dy) / screenStep)
      };
    },

    gridTransform() {
      const snapSize = myMath/* default.getSnappingWidthForScale */.Z.getSnappingWidthForScale(this.schemeContainer.screenTransform.scale);
      const zSnap = snapSize * this.schemeContainer.screenTransform.scale;
      let x = Math.ceil(this.schemeContainer.screenTransform.x % zSnap) - zSnap;
      let y = Math.ceil(this.schemeContainer.screenTransform.y % zSnap) - zSnap;
      return `translate(${x} ${y})`;
    },

    multiSelectBox() {
      return this.$store.getters.multiSelectBox;
    },

    horizontalSnapper() {
      return this.$store.getters.horizontalSnapper;
    },

    verticalSnapper() {
      return this.$store.getters.verticalSnapper;
    },

    shouldShowDropMask() {
      return this.$store.getters.isDraggingItemCreation;
    },

    showClickableMarkers() {
      return this.$store.getters.showClickableMarkers;
    }

  },
  filters: {
    formatLinkTitle(link) {
      if (link.title) {
        return link.title;
      } else {
        return link.url;
      }
    }

  },
  watch: {
    textSelectionEnabled(isEnabled) {
      this.mouseEventsEnabled = !(this.mode === 'view' && isEnabled);
      this.$forceUpdate();
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/SvgEditor.vue?vue&type=script&lang=js&
 /* harmony default export */ const editor_SvgEditorvue_type_script_lang_js_ = (SvgEditorvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/ui/components/editor/SvgEditor.vue





/* normalize component */
;
var SvgEditor_component = (0,componentNormalizer/* default */.Z)(
  editor_SvgEditorvue_type_script_lang_js_,
  SvgEditorvue_type_template_id_30c57726_lang_html_render,
  SvgEditorvue_type_template_id_30c57726_lang_html_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var SvgEditor_api; }
SvgEditor_component.options.__file = "src/ui/components/editor/SvgEditor.vue"
/* harmony default export */ const SvgEditor = (SvgEditor_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/ItemTooltip.vue?vue&type=template&id=422bfce5&
var ItemTooltipvue_type_template_id_422bfce5_render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    {
      staticClass: "item-tooltip",
      style: _vm.tooltipStyle,
      attrs: { id: _vm.domId, "data-type": "item-tooltip" },
    },
    [
      _c("div", { staticClass: "tooltip-header" }, [
        _c(
          "span",
          {
            staticClass: "item-tooltip-close",
            style: { color: _vm.tooltipColor },
            on: {
              click: function ($event) {
                return _vm.$emit("close")
              },
            },
          },
          [_vm._v("")]
        ),
        _vm._v(" "),
        _c("h3", { style: { color: _vm.tooltipColor } }, [
          _vm._v(_vm._s(_vm.item.name)),
        ]),
      ]),
      _vm._v(" "),
      _c("div", {
        staticClass: "item-tooltip-body",
        domProps: { innerHTML: _vm._s(_vm.sanitizedItemDescription) },
      }),
    ]
  )
}
var ItemTooltipvue_type_template_id_422bfce5_staticRenderFns = []
ItemTooltipvue_type_template_id_422bfce5_render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/ItemTooltip.vue?vue&type=template&id=422bfce5&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/ItemTooltip.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ const ItemTooltipvue_type_script_lang_js_ = ({
  props: ['item', 'x', 'y'],

  beforeMount() {
    this.timeMounted = new Date().getTime();
    document.body.addEventListener('click', this.onBodyClick);
  },

  mounted() {
    const rect = document.getElementById(this.domId).getBoundingClientRect();
    const leftOverlap = Math.min(0, window.innerWidth - this.x - rect.width);
    const topOverlap = Math.min(0, window.innerHeight - this.y - rect.height);
    this.positionLeft = this.x + leftOverlap;
    this.positionTop = this.y + topOverlap;
  },

  beforeDestroy() {
    document.body.removeEventListener('click', this.onBodyClick);
  },

  data() {
    const minWidth = Math.min(200, window.innerWidth - 60);
    const maxWidth = Math.min(700, window.innerWidth - 60);
    const maxHeight = Math.min(500, window.innerHeight - 60);
    return {
      domId: `item-tooltip-${this.item.id}`,
      timeMounted: 0,
      positionLeft: this.x,
      positionTop: this.y,
      minWidth: minWidth,
      maxWidth: maxWidth,
      maxHeight: maxHeight,
      tooltipBackground: this.item.tooltipBackground || '#eeeeee',
      tooltipColor: this.item.tooltipColor || '#111111'
    };
  },

  methods: {
    onBodyClick(event) {
      //checking whether there is a race condition and 
      // this is the initial click event that led to opening of a tooltip
      if (new Date().getTime() - this.timeMounted > 200) {
        // checking whether user clicked inside tooltip or not
        if (!this.isInsideTooltip(event.srcElement)) {
          this.$emit('close');
        }
      }
    },

    isInsideTooltip(domElement) {
      if (domElement.closest('[data-type="item-tooltip"]')) {
        return true;
      }

      return false;
    }

  },
  computed: {
    tooltipStyle() {
      return {
        'left': this.positionLeft + 'px',
        'top': this.positionTop + 'px',
        'background': this.tooltipBackground,
        'color': this.tooltipColor,
        'padding': '10px',
        'min-width': `${this.minWidth}px`,
        'max-width': `${this.maxWidth}px`,
        'max-height': `${this.maxHeight}px`
      };
    },

    sanitizedItemDescription() {
      return htmlSanitize_default()(this.item.description);
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/ItemTooltip.vue?vue&type=script&lang=js&
 /* harmony default export */ const editor_ItemTooltipvue_type_script_lang_js_ = (ItemTooltipvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/ui/components/editor/ItemTooltip.vue





/* normalize component */
;
var ItemTooltip_component = (0,componentNormalizer/* default */.Z)(
  editor_ItemTooltipvue_type_script_lang_js_,
  ItemTooltipvue_type_template_id_422bfce5_render,
  ItemTooltipvue_type_template_id_422bfce5_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ItemTooltip_api; }
ItemTooltip_component.options.__file = "src/ui/components/editor/ItemTooltip.vue"
/* harmony default export */ const ItemTooltip = (ItemTooltip_component.exports);
;// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/ItemDetails.vue?vue&type=template&id=d1e030b8&lang=html&
var ItemDetailsvue_type_template_id_d1e030b8_lang_html_render = function () {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", { staticClass: "item-details" }, [
    _c("h3", [_vm._v(_vm._s(_vm.item.name))]),
    _vm._v(" "),
    _c("div", {
      domProps: { innerHTML: _vm._s(_vm.sanitizedItemDescription) },
    }),
    _vm._v(" "),
    _vm.item.links && _vm.item.links.length > 0
      ? _c("div", [
          _c("h5", [_vm._v("Links")]),
          _vm._v(" "),
          _c(
            "ul",
            { staticClass: "links" },
            _vm._l(_vm.item.links, function (link) {
              return _c("li", [
                _c(
                  "a",
                  {
                    staticClass: "link",
                    attrs: { href: link.url, target: "_blank" },
                  },
                  [
                    _c("i", { class: _vm.getLinkCssClass(link) }),
                    _vm._v(
                      "\n                    " +
                        _vm._s(_vm._f("formatLinkTitle")(link)) +
                        "\n                "
                    ),
                  ]
                ),
              ])
            }),
            0
          ),
        ])
      : _vm._e(),
  ])
}
var ItemDetailsvue_type_template_id_d1e030b8_lang_html_staticRenderFns = []
ItemDetailsvue_type_template_id_d1e030b8_lang_html_render._withStripped = true


;// CONCATENATED MODULE: ./src/ui/components/editor/ItemDetails.vue?vue&type=template&id=d1e030b8&lang=html&

;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/components/editor/ItemDetails.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//


/* harmony default export */ const ItemDetailsvue_type_script_lang_js_ = ({
  props: ['item'],
  methods: {
    getLinkCssClass(link) {
      return LinkTypes/* default.findTypeByNameOrDefault */.Z.findTypeByNameOrDefault(link.type).cssClass;
    }

  },
  computed: {
    sanitizedItemDescription() {
      return htmlSanitize_default()(this.item.description);
    }

  },
  filters: {
    formatLinkTitle(link) {
      if (link.title) {
        return link.title;
      } else {
        return link.url;
      }
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/components/editor/ItemDetails.vue?vue&type=script&lang=js&
 /* harmony default export */ const editor_ItemDetailsvue_type_script_lang_js_ = (ItemDetailsvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/ui/components/editor/ItemDetails.vue





/* normalize component */
;
var ItemDetails_component = (0,componentNormalizer/* default */.Z)(
  editor_ItemDetailsvue_type_script_lang_js_,
  ItemDetailsvue_type_template_id_d1e030b8_lang_html_render,
  ItemDetailsvue_type_template_id_d1e030b8_lang_html_staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var ItemDetails_api; }
ItemDetails_component.options.__file = "src/ui/components/editor/ItemDetails.vue"
/* harmony default export */ const ItemDetails = (ItemDetails_component.exports);
;// CONCATENATED MODULE: ./node_modules/vuex/dist/vuex.esm.js
/*!
 * vuex v3.6.2
 * (c) 2021 Evan You
 * @license MIT
 */
function applyMixin (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if ( options === void 0 ) options = {};

      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit () {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
}

var target = typeof window !== 'undefined'
  ? window
  : typeof __webpack_require__.g !== 'undefined'
    ? __webpack_require__.g
    : {};
var devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin (store) {
  if (!devtoolHook) { return }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  }, { prepend: true });

  store.subscribeAction(function (action, state) {
    devtoolHook.emit('vuex:action', action, state);
  }, { prepend: true });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
function vuex_esm_find (list, f) {
  return list.filter(f)[0]
}

/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */
function deepCopy (obj, cache) {
  if ( cache === void 0 ) cache = [];

  // just return if obj is immutable value
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // if obj is hit, it is in circular structure
  var hit = vuex_esm_find(cache, function (c) { return c.original === obj; });
  if (hit) {
    return hit.copy
  }

  var copy = Array.isArray(obj) ? [] : {};
  // put the copy into cache at first
  // because we want to refer it in recursive deepCopy
  cache.push({
    original: obj,
    copy: copy
  });

  Object.keys(obj).forEach(function (key) {
    copy[key] = deepCopy(obj[key], cache);
  });

  return copy
}

/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

function partial (fn, arg) {
  return function () {
    return fn(arg)
  }
}

// Base data struct for store's module, package with some attribute and method
var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  // Store some children item
  this._children = Object.create(null);
  // Store the origin module object which passed by programmer
  this._rawModule = rawModule;
  var rawState = rawModule.state;

  // Store the origin module's state
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors = { namespaced: { configurable: true } };

prototypeAccessors.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.hasChild = function hasChild (key) {
  return key in this._children
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1 = this;
    if ( runtime === void 0 ) runtime = true;

  if ((false)) {}

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);

  if (!child) {
    if ((false)) {}
    return
  }

  if (!child.runtime) {
    return
  }

  parent.removeChild(key);
};

ModuleCollection.prototype.isRegistered = function isRegistered (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];

  if (parent) {
    return parent.hasChild(key)
  }

  return false
};

function update (path, targetModule, newModule) {
  if ((false)) {}

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if ((false)) {}
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}

var functionAssert = {
  assert: function (value) { return typeof value === 'function'; },
  expected: 'function'
};

var objectAssert = {
  assert: function (value) { return typeof value === 'function' ||
    (typeof value === 'object' && typeof value.handler === 'function'); },
  expected: 'function or object with "handler" function'
};

var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule (path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) { return }

    var assertOptions = assertTypes[key];

    forEachValue(rawModule[key], function (value, type) {
      assert(
        assertOptions.assert(value),
        makeAssertionMessage(path, key, type, value, assertOptions.expected)
      );
    });
  });
}

function makeAssertionMessage (path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + (path.join('.')) + "\"";
  }
  buf += " is " + (JSON.stringify(value)) + ".";
  return buf
}

var Vue; // bind on install

var Store = function Store (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if ((false)) {}

  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();
  this._makeLocalGettersCache = Object.create(null);

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  var state = this._modules.root.state;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.forEach(function (plugin) { return plugin(this$1); });

  var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;
  if (useDevtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors$1 = { state: { configurable: true } };

prototypeAccessors$1.state.get = function () {
  return this._vm._data.$$state
};

prototypeAccessors$1.state.set = function (v) {
  if ((false)) {}
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if ((false)) {}
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });

  this._subscribers
    .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
    .forEach(function (sub) { return sub(mutation, this$1.state); });

  if (
    false
  ) {}
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
    var this$1 = this;

  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var action = { type: type, payload: payload };
  var entry = this._actions[type];
  if (!entry) {
    if ((false)) {}
    return
  }

  try {
    this._actionSubscribers
      .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
      .filter(function (sub) { return sub.before; })
      .forEach(function (sub) { return sub.before(action, this$1.state); });
  } catch (e) {
    if ((false)) {}
  }

  var result = entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload);

  return new Promise(function (resolve, reject) {
    result.then(function (res) {
      try {
        this$1._actionSubscribers
          .filter(function (sub) { return sub.after; })
          .forEach(function (sub) { return sub.after(action, this$1.state); });
      } catch (e) {
        if ((false)) {}
      }
      resolve(res);
    }, function (error) {
      try {
        this$1._actionSubscribers
          .filter(function (sub) { return sub.error; })
          .forEach(function (sub) { return sub.error(action, this$1.state, error); });
      } catch (e) {
        if ((false)) {}
      }
      reject(error);
    });
  })
};

Store.prototype.subscribe = function subscribe (fn, options) {
  return genericSubscribe(fn, this._subscribers, options)
};

Store.prototype.subscribeAction = function subscribeAction (fn, options) {
  var subs = typeof fn === 'function' ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options)
};

Store.prototype.watch = function watch (getter, cb, options) {
    var this$1 = this;

  if ((false)) {}
  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule, options) {
    if ( options === void 0 ) options = {};

  if (typeof path === 'string') { path = [path]; }

  if ((false)) {}

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1 = this;

  if (typeof path === 'string') { path = [path]; }

  if ((false)) {}

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hasModule = function hasModule (path) {
  if (typeof path === 'string') { path = [path]; }

  if ((false)) {}

  return this._modules.isRegistered(path)
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors$1 );

function genericSubscribe (fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend
      ? subs.unshift(fn)
      : subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
}

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM (store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  // reset local getters cache
  store._makeLocalGettersCache = Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure environment.
    computed[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      get: function () { return store._vm[key]; },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () { return oldVm.$destroy(); });
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    if (store._modulesNamespaceMap[namespace] && ("production" !== 'production')) {}
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      if ((false)) {}
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (false) {}
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (false) {}
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function (type) {
      // skip if the target getter is not match this namespace
      if (type.slice(0, splitPos) !== namespace) { return }

      // extract local getter type
      var localType = type.slice(splitPos);

      // Add a port to the getters proxy.
      // Define as getter property because
      // we do not want to evaluate the getters in this time.
      Object.defineProperty(gettersProxy, localType, {
        get: function () { return store.getters[type]; },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }

  return store._makeLocalGettersCache[namespace]
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if ((false)) {}
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, function () {
    if ((false)) {}
  }, { deep: true, sync: true });
}

function getNestedState (state, path) {
  return path.reduce(function (state, key) { return state[key]; }, state)
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if ((false)) {}

  return { type: type, payload: payload, options: options }
}

function install (_Vue) {
  if (Vue && _Vue === Vue) {
    if ((false)) {}
    return
  }
  Vue = _Vue;
  applyMixin(Vue);
}

/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */
var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  if (false) {}
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  if (false) {}
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // Get the commit method from store
      var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return
        }
        commit = module.context.commit;
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */
var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  if (false) {}
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    // The namespace has been mutated by normalizeNamespace
    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if (false) {}
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  if (false) {}
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // get dispatch function from store
      var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */
var createNamespacedHelpers = function (namespace) { return ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
}); };

/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */
function normalizeMap (map) {
  if (!isValidMap(map)) {
    return []
  }
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

/**
 * Validate whether given map is valid or not
 * @param {*} map
 * @return {Boolean}
 */
function isValidMap (map) {
  return Array.isArray(map) || isObject(map)
}

/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */
function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */
function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (false) {}
  return module
}

// Credits: borrowed code from fcomb/redux-logger

function createLogger (ref) {
  if ( ref === void 0 ) ref = {};
  var collapsed = ref.collapsed; if ( collapsed === void 0 ) collapsed = true;
  var filter = ref.filter; if ( filter === void 0 ) filter = function (mutation, stateBefore, stateAfter) { return true; };
  var transformer = ref.transformer; if ( transformer === void 0 ) transformer = function (state) { return state; };
  var mutationTransformer = ref.mutationTransformer; if ( mutationTransformer === void 0 ) mutationTransformer = function (mut) { return mut; };
  var actionFilter = ref.actionFilter; if ( actionFilter === void 0 ) actionFilter = function (action, state) { return true; };
  var actionTransformer = ref.actionTransformer; if ( actionTransformer === void 0 ) actionTransformer = function (act) { return act; };
  var logMutations = ref.logMutations; if ( logMutations === void 0 ) logMutations = true;
  var logActions = ref.logActions; if ( logActions === void 0 ) logActions = true;
  var logger = ref.logger; if ( logger === void 0 ) logger = console;

  return function (store) {
    var prevState = deepCopy(store.state);

    if (typeof logger === 'undefined') {
      return
    }

    if (logMutations) {
      store.subscribe(function (mutation, state) {
        var nextState = deepCopy(state);

        if (filter(mutation, prevState, nextState)) {
          var formattedTime = getFormattedTime();
          var formattedMutation = mutationTransformer(mutation);
          var message = "mutation " + (mutation.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
          endMessage(logger);
        }

        prevState = nextState;
      });
    }

    if (logActions) {
      store.subscribeAction(function (action, state) {
        if (actionFilter(action, state)) {
          var formattedTime = getFormattedTime();
          var formattedAction = actionTransformer(action);
          var message = "action " + (action.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
          endMessage(logger);
        }
      });
    }
  }
}

function startMessage (logger, message, collapsed) {
  var startMessage = collapsed
    ? logger.groupCollapsed
    : logger.group;

  // render
  try {
    startMessage.call(logger, message);
  } catch (e) {
    logger.log(message);
  }
}

function endMessage (logger) {
  try {
    logger.groupEnd();
  } catch (e) {
    logger.log(' log end ');
  }
}

function getFormattedTime () {
  var time = new Date();
  return (" @ " + (pad(time.getHours(), 2)) + ":" + (pad(time.getMinutes(), 2)) + ":" + (pad(time.getSeconds(), 2)) + "." + (pad(time.getMilliseconds(), 3)))
}

function repeat (str, times) {
  return (new Array(times + 1)).join(str)
}

function pad (num, maxLength) {
  return repeat('0', maxLength - num.toString().length) + num
}

var index = {
  Store: Store,
  install: install,
  version: '3.6.2',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers,
  createLogger: createLogger
};

/* harmony default export */ const vuex_esm = (index);


;// CONCATENATED MODULE: ./src/ui/LimitedSettingsStorage.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

class LimitedSettingsStorage {
  /**
   * 
   * @param {Storage} localStorage 
   * @param {String} name 
   * @param {Number} limit Amount of objects to be stored in settings storage
   */
  constructor(localStorage, name, limit) {
    this.storage = localStorage;
    this.name = name;
    this.limit = limit;
    this.items = {};
    this.amountOfElements = 0;
    this.revision = 0;
    this.loadFromSettingsStorage();
  }

  _saveItem(itemName, obj) {
    this.storage.setItem(itemName, JSON.stringify(obj));
  }

  _getItem(name, defaultValue) {
    const encodedJson = this.storage.getItem(name);

    if (encodedJson) {
      return JSON.parse(encodedJson);
    } else {
      return defaultValue;
    }
  }

  loadFromSettingsStorage() {
    const that = this._getItem(`LSS-${this.name}`);

    if (that && that.items && that.amountOfElements && that.revision) {
      this.items = that.items;
      this.amountOfElements = that.amountOfElements;
      this.revision = that.revision;
    }
  }

  saveToSettingsStorage() {
    this._saveItem(`LSS-${this.name}`, {
      items: this.items,
      amountOfElements: this.amountOfElements,
      revision: this.revision
    });
  }

  save(id, value) {
    if (this.items.hasOwnProperty(id)) {
      this.makeMostRecent(this.items[id]);
      this.items[id].v = value;
      this.saveToSettingsStorage();
      return;
    } else if (this.amountOfElements >= this.limit) {
      this.evict();
    }

    this.items[id] = {
      r: this.getNewRevision(),
      v: value
    };
    this.amountOfElements += 1;
    this.saveToSettingsStorage();
  }

  get(id, defualtValue) {
    const item = this.items[id];

    if (item) {
      return item.v;
    }

    return defualtValue;
  }

  makeMostRecent(item) {
    item.r = this.getNewRevision();
  }

  evict() {
    // since this operation is only triggered once per scheme, it's not a big deal to iterate through all the objects
    // otherwise it would have to use the proper LRU cache,
    // but even then there is an efficiency problem due to serialization to local storage on each update, so meh...
    let oldestKey = null;
    let oldestRevision = 0;
    forEach_default()(this.items, (item, key) => {
      if (!oldestKey || oldestRevision > item.r) {
        oldestKey = key;
        oldestRevision = item.r;
      }
    });

    if (oldestKey) {
      delete this.items[oldestKey];
      this.amountOfElements -= 1;
    }
  }

  getElementsCount() {
    return this.amountOfElements;
  }

  getNewRevision() {
    this.revision += 1;
    return this.revision;
  }

}
const schemioLocalStorage = {
  getItem(key) {
    return window.localStorage.getItem(key);
  },

  setItem(key, value) {
    window.localStorage.setItem(key, value);
  }

};
function createSettingStorageFromLocalStorage(name, limit) {
  return new LimitedSettingsStorage(schemioLocalStorage, name, limit);
}
// EXTERNAL MODULE: ./node_modules/shortid/index.js
var shortid = __webpack_require__(4670);
var shortid_default = /*#__PURE__*/__webpack_require__.n(shortid);
// EXTERNAL MODULE: ./src/ui/components/editor/items/shapes/StandardCurves.js
var StandardCurves = __webpack_require__(8270);
;// CONCATENATED MODULE: ./src/ui/store/Store.js
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */








vue_default().use(vuex_esm);
const DEFAULT_CONNECTOR_SMOOTHING = 'defaultConnectorSmoothing';
const myStorage = createSettingStorageFromLocalStorage('store', 100);

function createCurvePointConverter(item) {
  return point => {
    const convertedPoint = ui_utils/* default.clone */.Z.clone(point);
    const p = (0,SchemeContainer/* worldPointOnItem */.rs)(point.x, point.y, item);
    convertedPoint.x = p.x;
    convertedPoint.y = p.y;

    if (point.t === 'B') {
      const p1 = (0,SchemeContainer/* worldPointOnItem */.rs)(point.x + point.x1, point.y + point.y1, item);
      convertedPoint.x1 = p1.x - p.x;
      convertedPoint.y1 = p1.y - p.y;
    }

    if (point.t === 'B') {
      const p2 = (0,SchemeContainer/* worldPointOnItem */.rs)(point.x + point.x2, point.y + point.y2, item);
      convertedPoint.x2 = p2.x - p.x;
      convertedPoint.y2 = p2.y - p.y;
    }

    return convertedPoint;
  };
}

function enrichCurvePoint(point) {
  if (point.t === 'B') {
    let length = Math.sqrt(point.x1 * point.x1 + point.y1 * point.y1);
    let vx1 = 1,
        vy1 = 0;

    if (length > 0.000001) {
      vx1 = point.x1 / length;
      vy1 = point.y1 / length;
    }

    length = Math.sqrt(point.x2 * point.x2 + point.y2 * point.y2);
    let vx2 = 1,
        vy2 = 0;

    if (length > 0.000001) {
      vx2 = point.x2 / length;
      vy2 = point.y2 / length;
    }

    point.vx1 = vx1;
    point.vy1 = vy1;
    point.vx2 = vx2;
    point.vy2 = vy2;
  }
}

function validatePointIds(pathId, pointId, curveEditing) {
  return pathId >= 0 && pathId < curveEditing.paths.length && pointId >= 0 && pointId < curveEditing.paths[pathId].points.length;
}

function findFirstSelectedCurveEditPoint(paths) {
  for (let i = 0; i < paths.length; i++) {
    for (let j = 0; j < paths[i].points.length; j++) {
      if (paths[i].points[j].selected) {
        return paths[i].points[j];
      }
    }
  }

  return null;
}

const store = new vuex_esm.Store({
  state: {
    //rootPath is used in the header for a home link, since if this is being hosted in GitHub Pages the we cannot use '/' as root path
    rootPath: '/',
    assetsPath: '/assets',
    apiClient: null,
    schemeModified: false,
    editorStateName: 'interact',
    editorSubStateName: null,
    itemMenu: {
      artPackIds: new Set(),
      artPacks: [],
      shapeGroupIds: new Set()
    },
    curveEditing: {
      // item whose curve is currently edited
      item: null,
      paths: [],
      firstSelectedPoint: null
    },
    // used in "connecting" state
    connecting: {
      connectorItem: null
    },
    patch: {
      settings: {
        additionsColor: 'rgba(90, 255, 90, 0.4)',
        deletionsColor: 'rgba(255, 90, 90, 0.4)',
        modificationsColor: 'rgba(90, 90, 255, 0.4)'
      },
      diffColoringEnabled: true
    },
    defaultConnectorSmoothing: myStorage.get(DEFAULT_CONNECTOR_SMOOTHING, 'linear'),
    autoRemount: true,
    showPivot: false,
    // toggles clickable item markers in view mode so that users can see
    // what they can click on the diagram and which elements are interactive
    showClickableMarkers: false,
    // stores the state of the history in scheme editing
    history: {
      undoable: false,
      redoable: false
    },
    // item which style should be copied to other items
    copiedStyleItem: null,
    snap: {
      grid: myStorage.get('snap.grid', false),
      items: myStorage.get('snap.items', true)
    },
    itemSurround: {
      padding: 40
    },
    itemControlPoints: [],
    // used when only single connector is selected
    // in this case we need to render its path to make it highlighted
    selectedConnectorPath: null,
    multiSelectBox: null,
    // used to render snapping lines when user drags item and it is snapped to other items
    snappers: {
      horizontal: null,
      vertical: null
    },
    // used to display proposed new items
    connectorProposedDestination: {
      shown: false,
      connectorItemId: null,
      mx: 0,
      // value on x viewport axis
      my: 0 // value on y viewport axis

    },
    // used for storing information about images that were dropped on svg editor
    imageUpload: {
      images: new Map()
    },
    statusMessage: {
      message: null,
      isError: false
    },
    // Contains global self destructing messages that can be written from any components
    systemMessages: [],
    draw: {
      epsilon: 5
    },
    animationEditor: {
      currentFramePlayer: null,
      isRecording: false
    }
  },
  mutations: {
    SET_ROOT_PATH(state, path) {
      state.rootPath = path;
    },

    SET_ASSESTS_PATH(state, path) {
      state.assetsPath = path;
    },

    SET_API_CLIENT(state, apiClient) {
      state.apiClient = apiClient;
    },

    SET_SCHEME_MODIFIED(state, isModified) {
      state.schemeModified = isModified;
    },

    SET_AUTO_REMOUNT(state, autoRemount) {
      state.autoRemount = autoRemount;
    },

    SET_SHOW_PIVOT(state, show) {
      state.showPivot = show;
    },

    SET_SHOW_CLICKABLE_MARKERS(state, show) {
      state.showClickableMarkers = show;
    },

    /* Curve Editing */
    SET_CURVE_EDIT_ITEM(state, {
      item,
      paths
    }) {
      state.curveEditing.item = item;
      state.curveEditing.paths.length = 0;

      if (item) {
        const pointConverter = createCurvePointConverter(item);
        paths.forEach((path, pathId) => {
          state.curveEditing.paths[pathId] = {
            id: path.id,
            points: path.points.map(pointConverter)
          };
        });
      }
    },

    UPDATE_CURVE_EDIT_POINT(state, {
      item,
      pathId,
      pointId,
      point
    }) {
      if (!validatePointIds(pathId, pointId, state.curveEditing)) {
        return;
      }

      const pointConverter = createCurvePointConverter(item);
      const convertedPoint = pointConverter((0,StandardCurves/* convertCurvePointToItemScale */.oJ)(point, item.area.w, item.area.h));
      forEach_default()(convertedPoint, (value, field) => {
        state.curveEditing.paths[pathId].points[pointId][field] = value;
        enrichCurvePoint(state.curveEditing.paths[pathId].points[pointId]);
      });
    },

    TOGGLE_CURVE_EDIT_POINT_SELECTION(state, {
      pathId,
      pointId,
      inclusive
    }) {
      if (!validatePointIds(pathId, pointId, state.curveEditing)) {
        return;
      }

      if (inclusive) {
        state.curveEditing.paths[pathId].points[pointId].selected = !state.curveEditing.paths[pathId].points[pointId].selected;
        state.curveEditing.firstSelectedPoint = findFirstSelectedCurveEditPoint(state.curveEditing.paths);
      } else {
        state.curveEditing.paths.forEach((path, _pathIndex) => {
          path.points.forEach((point, _pointIndex) => {
            point.selected = _pathIndex === pathId && _pointIndex === pointId;
          });
        });
        state.curveEditing.firstSelectedPoint = state.curveEditing.paths[pathId].points[pointId];
      }
    },

    RESET_CURVE_EDIT_POINT_SELECTION(state) {
      state.curveEditing.paths.forEach(path => {
        path.points.forEach(point => {
          point.selected = false;
        });
      });
      state.curveEditing.firstSelectedPoint = null;
    },

    SELECT_CURVE_EDIT_POINT(state, {
      pathId,
      pointId,
      inclusive
    }) {
      if (!validatePointIds(pathId, pointId, state.curveEditing)) {
        return;
      }

      if (inclusive) {
        state.curveEditing.paths[pathId].points[pointId].selected = true;
        state.curveEditing.firstSelectedPoint = findFirstSelectedCurveEditPoint(state.curveEditing.paths);
      } else {
        state.curveEditing.paths.forEach((path, _pathIndex) => {
          path.points.forEach((point, _pointIndex) => {
            point.selected = _pathIndex === pathId && _pointIndex === pointId;
          });
        });
        state.curveEditing.firstSelectedPoint = state.curveEditing.paths[pathId].points[pointId];
      }
    },

    /* History */
    SET_HISTORY_UNDOABLE(state, isUndoable) {
      state.history.undoable = isUndoable;
    },

    SET_HISTORY_REDOABLE(state, isRedoable) {
      state.history.redoable = isRedoable;
    },

    SET_DEFAULT_CONNECTOR_SMOOTHING(state, smoothing) {
      state.defaultConnectorSmoothing = smoothing;
      myStorage.save(DEFAULT_CONNECTOR_SMOOTHING, smoothing);
    },

    SET_GRID_SNAP(state, enabled) {
      state.snap.grid = enabled;
      myStorage.save('snap.grid', enabled);
    },

    SET_ITEM_SNAP(state, enabled) {
      state.snap.items = enabled;
      myStorage.save('snap.items', enabled);
    },

    SET_EDITOR_STATE_NAME(state, stateName) {
      state.editorStateName = stateName;
    },

    SET_EDITOR_SUB_STATE_NAME(state, stateName) {
      state.editorSubStateName = stateName;
    },

    SET_ITEM_SURROUND_PADDING(state, padding) {
      state.itemSurround.padding = padding;
    },

    /*************** Item Control Points *****************/
    SET_ITEM_CONTROL_POINTS(state, itemControlPoints) {
      state.itemControlPoints = itemControlPoints;
    },

    CLEAR_ITEM_CONTROL_POINTS(state) {
      state.itemControlPoints.length = 0;
    },

    SET_MULTI_SELECT_BOX(state, box) {
      state.multiSelectBox = box;
    },

    SET_SELECTED_CONNECTOR_PATH(state, path) {
      state.selectedConnectorPath = path;
    },

    /************ Snappers ****************/
    SET_ITEM_SNAPPER(state, snapper) {
      if (snapper.snapperType === 'horizontal') {
        state.snappers.horizontal = snapper;
      } else if (snapper.snapperType === 'vertical') {
        state.snappers.vertical = snapper;
      }
    },

    CLEAR_ITEM_SNAPPERS(state) {
      state.snappers.horizontal = null;
      state.snappers.vertical = null;
    },

    PROPOSE_CONNECTOR_DESTINATION_ITEMS(state, {
      connectorItemId,
      mx,
      my
    }) {
      state.connectorProposedDestination.connectorItemId = connectorItemId;
      state.connectorProposedDestination.mx = mx;
      state.connectorProposedDestination.my = my;
      state.connectorProposedDestination.shown = true;
    },

    DISABLE_PROPOSE_CONNECTOR_DESTINATION_ITEMS(state) {
      state.connectorProposedDestination.shown = false;
    },

    UPDATE_IMAGE_UPLOAD_STATUS(state, {
      imageId,
      uploading,
      uploadFailed
    }) {
      if (uploadFailed) {
        state.statusMessage.message = 'Failed to upload image';
        state.statusMessage.isError = true;
      }

      if ((!uploading || uploadFailed) && state.imageUpload.images.has(imageId)) {
        state.imageUpload.images.delete(imageId);
      } else {
        state.imageUpload.images.set(imageId, {
          uploading,
          date: new Date()
        });
      }

      let imagesUploading = 0;
      state.imageUpload.images.forEach(image => {
        if (image.uploading) {
          imagesUploading += 1;
        }
      });

      if (state.statusMessage.isError && state.statusMessage.message) {
        return;
      }

      if (imagesUploading > 0) {
        let suffix = '';

        if (imagesUploading > 1) {
          suffix = 's';
        }

        state.statusMessage.message = `Uploading ${imagesUploading} image${suffix}`;
        state.statusMessage.isError = false;
      } else {
        state.statusMessage.message = null;
        state.statusMessage.isError = false;
      }
    },

    RESET_IMAGE_UPLOAD_STATUS(state) {
      const now = new Date();
      const toDeleteIds = [];
      state.imageUpload.images.forEach((image, imageId) => {
        if (now.getTime() - image.date.getTime() > 45000) {
          toDeleteIds.push(imageId);
        }
      });
      forEach_default()(toDeleteIds, id => {
        state.imageUpload.images.delete(id);
      });
    },

    CLEAR_STATUS_MESSAGE(state) {
      state.statusMessage.message = null;
      state.statusMessage.isError = false;
    },

    SET_STATUS_MESSAGE(state, {
      message,
      isError
    }) {
      state.statusMessage.message = message;
      state.statusMessage.isError = isError;
    },

    ADD_SYSTEM_MESSAGE(state, {
      message,
      status,
      id
    }) {
      if (id) {
        // checking if there are already messages with the same id
        for (let i = 0; i < state.systemMessages.length; i++) {
          if (state.systemMessages[i].id === id) {
            return;
          }
        }
      } else {
        id = shortid_default().generate();
      }

      state.systemMessages.push({
        id,
        message,
        status
      });
      const timeout = 5000;

      const selfDestruct = () => {
        for (let i = 0; i < state.systemMessages.length; i++) {
          if (state.systemMessages[i].id === id) {
            state.systemMessages.splice(i, 1);
            return;
          }
        }
      };

      setTimeout(selfDestruct, timeout);
    },

    REMOVE_SYSTEM_MESSAGE(state, id) {
      for (let i = 0; i < state.systemMessages.length; i++) {
        if (state.systemMessages[i].id === id) {
          state.systemMessages.splice(i, 1);
          return;
        }
      }
    },

    UPDATE_DRAW_EPSILON(state, epsilon) {
      if (!isNaN(epsilon)) {
        state.draw.epsilon = epsilon;
      }
    },

    START_ANIMATION_EDITOR(state, framePlayer) {
      state.animationEditor.currentFramePlayer = framePlayer;
    },

    SET_ANIMATION_EDITOR_RECORDING(state, isRecording) {
      state.animationEditor.isRecording = isRecording;
    },

    COPY_ITEM_STYLE(state, item) {
      state.copiedStyleItem = ui_utils/* default.clone */.Z.clone(item);
    },

    SET_PATCH_DIFF_COLORING_ENABLED(state, enabled) {
      state.patch.diffColoringEnabled = enabled;
    },

    UPDATE_PATCH_DIFF_COLOR(state, {
      changeType,
      color
    }) {
      console.log('UPDATE_PATCH_DIFF_COLOR', changeType, color);

      if (changeType === 'additions') {
        state.patch.settings.additionsColor = color;
      } else if (changeType === 'deletions') {
        state.patch.settings.deletionsColor = color;
      } else if (changeType === 'modifications') {
        state.patch.settings.modificationsColor = color;
      }
    },

    SET_CURRENT_CONNECTOR(state, {
      item
    }) {
      state.connecting.connectorItem = item;
    },

    ADD_ART_PACK(state, {
      artPack,
      artPackId
    }) {
      if (!state.itemMenu.artPackIds.has(artPackId)) {
        state.itemMenu.artPacks.push(_objectSpread(_objectSpread({}, artPack), {}, {
          id: artPackId
        }));
        state.itemMenu.artPackIds.add(artPackId);
      }
    },

    REMOVE_ART_PACK(state, artPackId) {
      if (state.itemMenu.artPackIds.has(artPackId)) {
        state.itemMenu.artPackIds.delete(artPackId);

        for (let i = 0; i < state.itemMenu.artPacks.length; i++) {
          if (state.itemMenu.artPacks[i].id === artPackId) {
            state.itemMenu.artPacks.splice(i, 1);
            return;
          }
        }
      }
    },

    REGISTER_SHAPE_GROUP_ID(state, id) {
      state.itemMenu.shapeGroupIds.add(id);
    }

  },
  actions: {
    setRootPath({
      commit
    }, path) {
      commit('SET_ROOT_PATH', path);
    },

    setAssetsPath({
      commit
    }, path) {
      commit('SET_ASSESTS_PATH', path);
    },

    setApiClient({
      commit
    }, apiClient) {
      commit('SET_API_CLIENT', apiClient);
    },

    markSchemeAsModified({
      commit
    }) {
      commit('SET_SCHEME_MODIFIED', true);
    },

    markSchemeAsUnmodified({
      commit
    }) {
      commit('SET_SCHEME_MODIFIED', false);
    },

    setCurveEditItem({
      commit
    }, item) {
      const paths = [];

      if (item) {
        item.shapeProps.paths.forEach((path, pathId) => {
          const points = [];
          path.points.forEach((point, pointId) => {
            const p = (0,StandardCurves/* convertCurvePointToItemScale */.oJ)(point, item.area.w, item.area.h);
            p.id = pointId;
            p.selected = false;
            enrichCurvePoint(p);
            points.push(p);
          });
          paths.push({
            id: pathId,
            points
          });
        });
      }

      commit('SET_CURVE_EDIT_ITEM', {
        item,
        paths
      });
    },

    updateCurveEditPoint({
      commit
    }, {
      item,
      pathId,
      pointId,
      point
    }) {
      commit('UPDATE_CURVE_EDIT_POINT', {
        item,
        pathId,
        pointId,
        point
      });
    },

    toggleCurveEditPointSelection({
      commit
    }, {
      pathId,
      pointId,
      inclusive
    }) {
      commit('TOGGLE_CURVE_EDIT_POINT_SELECTION', {
        pathId,
        pointId,
        inclusive
      });
    },

    resetCurveEditPointSelection({
      commit
    }) {
      commit('RESET_CURVE_EDIT_POINT_SELECTION');
    },

    selectCurveEditPoint({
      commit
    }, {
      pathId,
      pointId,
      inclusive
    }) {
      commit('SELECT_CURVE_EDIT_POINT', {
        pathId,
        pointId,
        inclusive
      });
    },

    setHistoryUndoable({
      commit
    }, isUndoable) {
      commit('SET_HISTORY_UNDOABLE', isUndoable);
    },

    setHistoryRedoable({
      commit
    }, isRedoable) {
      commit('SET_HISTORY_REDOABLE', isRedoable);
    },

    setDefaultConnectorSmoothing({
      commit
    }, smoothing) {
      commit('SET_DEFAULT_CONNECTOR_SMOOTHING', smoothing);
    },

    setGridSnap({
      commit
    }, enabled) {
      commit('SET_GRID_SNAP', enabled);
    },

    setItemSnap({
      commit
    }, enabled) {
      commit('SET_ITEM_SNAP', enabled);
    },

    setEditorStateName({
      commit
    }, stateName) {
      commit('SET_EDITOR_STATE_NAME', stateName);
    },

    setEditorSubStateName({
      commit
    }, stateName) {
      commit('SET_EDITOR_SUB_STATE_NAME', stateName);
    },

    setItemSurroundPadding({
      commit
    }, padding) {
      commit('SET_ITEM_SURROUND_PADDING', padding);
    },

    setItemControlPoints({
      commit
    }, itemControlPoints) {
      const list = [];
      forEach_default()(itemControlPoints, (controlPoint, pointId) => {
        list.push({
          id: pointId,
          point: controlPoint
        });
      });
      commit('SET_ITEM_CONTROL_POINTS', list);
    },

    clearItemControlPoints({
      commit
    }) {
      commit('CLEAR_ITEM_CONTROL_POINTS');
    },

    setMultiSelectBox({
      commit
    }, box) {
      commit('SET_MULTI_SELECT_BOX', box);
    },

    setSelectedConnectorPath({
      commit
    }, path) {
      commit('SET_SELECTED_CONNECTOR_PATH', path);
    },

    setItemSnapper({
      commit
    }, snapper) {
      commit('SET_ITEM_SNAPPER', snapper);
    },

    clearItemSnappers({
      commit
    }) {
      commit('CLEAR_ITEM_SNAPPERS');
    },

    setAutoRemount({
      commit
    }, autoRemount) {
      commit('SET_AUTO_REMOUNT', autoRemount);
    },

    setShowPivot({
      commit
    }, show) {
      commit('SET_SHOW_PIVOT', show);
    },

    setShowClickableMarkers({
      commit
    }, show) {
      commit('SET_SHOW_CLICKABLE_MARKERS', show);
    },

    proposeConnectorDestinationItems({
      commit
    }, payload) {
      commit('PROPOSE_CONNECTOR_DESTINATION_ITEMS', payload);
    },

    disableProposeConnectorDestinationItems({
      commit
    }) {
      commit('DISABLE_PROPOSE_CONNECTOR_DESTINATION_ITEMS');
    },

    updateImageUploadStatus({
      commit
    }, {
      imageId,
      uploading,
      uploadFailed
    }) {
      commit('UPDATE_IMAGE_UPLOAD_STATUS', {
        imageId,
        uploading,
        uploadFailed
      }); // triggering an update of all messages in a minute
      // this is needed in case image uploading gets somehow stuck

      setTimeout(() => {
        commit('RESET_IMAGE_UPLOAD_STATUS');
      }, 60000);
    },

    clearStatusMessage({
      commit
    }) {
      commit('CLEAR_STATUS_MESSAGE');
    },

    setErrorStatusMessage({
      commit
    }, message) {
      commit('SET_STATUS_MESSAGE', {
        message,
        isError: true
      });
    },

    addSystemMessage({
      commit
    }, {
      message,
      status,
      id
    }) {
      commit('ADD_SYSTEM_MESSAGE', {
        message,
        status,
        id
      });
    },

    removeSystemMessage({
      commit
    }, id) {
      commit('REMOVE_SYSTEM_MESSAGE', id);
    },

    updateDrawEpsilon({
      commit
    }, epsilon) {
      commit('UPDATE_DRAW_EPSILON', epsilon);
    },

    startAnimationEditor({
      commit
    }, framePlayer) {
      commit('START_ANIMATION_EDITOR', framePlayer);
    },

    setAnimationEditorRecording({
      commit
    }, isRecording) {
      commit('SET_ANIMATION_EDITOR_RECORDING', isRecording);
    },

    copyItemStyle({
      commit
    }, item) {
      commit('COPY_ITEM_STYLE', item);
    },

    setPatchDiffColoringEnabled({
      commit
    }, enabled) {
      commit('SET_PATCH_DIFF_COLORING_ENABLED', enabled);
    },

    updatePatchDiffColor({
      commit
    }, {
      changeType,
      color
    }) {
      commit('UPDATE_PATCH_DIFF_COLOR', {
        changeType,
        color
      });
    },

    setCurrentConnector({
      commit
    }, item) {
      commit('SET_CURRENT_CONNECTOR', {
        item
      });
    },

    addArtPack({
      commit
    }, {
      artPack,
      artPackId
    }) {
      commit('ADD_ART_PACK', {
        artPack,
        artPackId
      });
    },

    removeArtPack({
      commit
    }, artPackId) {
      commit('REMOVE_ART_PACK', artPackId);
    },

    registerShapeGroupId({
      commit
    }, shapeGroupId) {
      commit('REGISTER_SHAPE_GROUP_ID', shapeGroupId);
    }

  },
  getters: {
    apiClient: state => state.apiClient,
    schemeModified: state => state.schemeModified,
    itemControlPointsList: state => state.itemControlPoints,
    curveEditPaths: state => state.curveEditing.paths,
    firstSelectedCurveEditPoint: state => state.curveEditing.firstSelectedPoint,
    multiSelectBox: state => state.multiSelectBox,
    horizontalSnapper: state => state.snappers.horizontal,
    verticalSnapper: state => state.snappers.vertical,
    shouldSnapToGrid: state => state.snap.grid,
    shouldSnapToItems: state => state.snap.items,
    autoRemount: state => state.autoRemount,
    showPivot: state => state.showPivot,
    showClickableMarkers: state => state.showClickableMarkers,
    connectorProposedDestination: state => state.connectorProposedDestination,
    statusMessage: state => state.statusMessage,
    selectedConnectorPath: state => state.selectedConnectorPath,
    systemMessages: state => state.systemMessages,
    drawEpsilon: state => state.draw.epsilon,
    editorStateName: state => state.editorStateName,
    editorSubStateName: state => state.editorSubStateName,
    animationEditorCurrentFramePlayer: state => state.animationEditor.currentFramePlayer,
    animationEditorIsRecording: state => state.animationEditor.isRecording,
    patchAdditionsColor: state => state.patch.settings.additionsColor,
    patchDeletionsColor: state => state.patch.settings.deletionsColor,
    patchModificationsColor: state => state.patch.settings.modificationsColor,
    patchIsDiffColoringEnabled: state => state.patch.diffColoringEnabled,
    staticExportAllowed: state => {
      if (state.apiClient && state.apiClient.submitStaticExport) {
        return true;
      }

      return false;
    },
    rootPath: state => state.rootPath,
    assetsPath: state => state.assetsPath
  }
});
/* harmony default export */ const store_Store = (store);
// EXTERNAL MODULE: ./src/ui/logger.js
var logger = __webpack_require__(2017);
;// CONCATENATED MODULE: ./src/ui/userevents/UserEventBus.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */



const log = new logger/* Logger */.Yd('UserEventBus');
/**
 * This UserEventBus is used in order to track and handle events that emitted in interactive mode
 * when user interacts with elements
 */

class UserEventBus {
  constructor() {
    this.itemEventSubscribers = {};
    this.revision = shortid_default().generate();
  }

  subscribeItemEvent(itemId, eventName, callback) {
    if (!this.itemEventSubscribers.hasOwnProperty(itemId)) {
      this.itemEventSubscribers[itemId] = {};
    }

    if (!this.itemEventSubscribers[itemId].hasOwnProperty(eventName)) {
      this.itemEventSubscribers[itemId][eventName] = [];
    }

    this.itemEventSubscribers[itemId][eventName].push({
      callback
    });
  }
  /**
   * Emits event that originated for a specific item
   * @param {string} itemId 
   * @param {string} eventName 
   */


  emitItemEvent(itemId, eventName) {
    log.infoEvent(eventName, [itemId]);
    const itemSubs = this.itemEventSubscribers[itemId];

    if (itemSubs && itemSubs[eventName]) {
      forEach_default()(itemSubs[eventName], subscriber => {
        subscriber.callback.apply(null, [this, this.revision, itemId, eventName]);
      });
    }
  }

  clear() {
    this.itemEventSubscribers = {};
    this.revision = shortid_default().generate();
  }

  isActionAllowed(revision) {
    return this.revision === revision;
  }

}
;
// EXTERNAL MODULE: ./src/ui/events.js
var events = __webpack_require__(8442);
;// CONCATENATED MODULE: ./src/ui/components/editor/states/State.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */






const SUB_STATE_STACK_LIMIT = 10;
/**
 * Checkes whether keys like shift, meta (mac), ctrl were pressed during the mouse event
 * @param {MouseEvent} event 
 */

function isMultiSelectKey(event) {
  return event.metaKey || event.ctrlKey || event.shiftKey;
}
function isEventMiddleClick(event) {
  return event.button === 1;
}
function isEventRightClick(event) {
  return event.button === 2;
}

class State {
  /**
   * @param {EventBus} EventBus 
   * @param {Vuex.Store} store - a Vuex store object
   */
  constructor(eventBus, store, name) {
    this.schemeContainer = null;
    this.eventBus = eventBus;
    this.name = name || '';
    this.store = store;
    this.subState = null;
    this.previousSubStates = [];
  }

  migrateSubState(newSubState) {
    if (this.subState) {
      this.previousSubStates.push(this.subState);

      if (this.previousSubStates.length > SUB_STATE_STACK_LIMIT) {
        this.previousSubStates.shift();
      }
    }

    this.subState = newSubState;
    this.store.dispatch('setEditorSubStateName', this.subState ? this.subState.name : 'null');
  }

  migrateToPreviousSubState() {
    if (this.previousSubStates.length > 0) {
      this.subState = this.previousSubStates.pop();
      this.store.dispatch('setEditorSubStateName', this.subState ? this.subState.name : 'null');
    }
  }

  resetPreviousSubStates() {
    this.previousSubStates = [];
  }

  setSchemeContainer(schemeContainer) {
    this.schemeContainer = schemeContainer;
  }

  reset() {} // invoked when user cancels the state (e.g. press Esc key)


  cancel() {
    this.reset();
    this.eventBus.$emit(this.eventBus.CANCEL_CURRENT_STATE, this.name);
  }

  keyPressed(key, keyOptions) {
    if (this.subState) this.subState.keyPressed(key, keyOptions);
  }

  keyUp(key, keyOptions) {
    if (this.subState) this.subState.keyUp(key, keyOptions);
  }

  mouseDoubleClick(x, y, mx, my, object, event) {
    if (this.subState) this.subState.mouseDoubleClick(x, y, mx, my, object, event);
  }

  mouseDown(x, y, mx, my, object, event) {
    if (this.subState) this.subState.mouseDown(x, y, mx, my, object, event);
  }

  mouseMove(x, y, mx, my, object, event) {
    if (this.subState) this.subState.mouseMove(x, y, mx, my, object, event);
  }

  mouseUp(x, y, mx, my, object, event) {
    if (this.subState) this.subState.mouseUp(x, y, mx, my, object, event);
  }
  /**
   * 
   * @param {*} x 
   * @param {*} y 
   * @param {*} mx 
   * @param {*} my 
   * @param {MouseEvent} event 
   */


  mouseWheel(x, y, mx, my, event) {
    if (event) {
      // explanation to this check is here https://stackoverflow.com/a/62415754/2704008
      const isTouchPad = event.wheelDeltaY ? event.wheelDeltaY === -3 * event.deltaY : event.deltaMode === 0;

      if (event.deltaX !== 0 || event.deltaY !== 0) {
        if (isTouchPad) {
          this.dragScreenOffset(event.deltaX, -event.deltaY);
        } else {
          this.zoomByWheel(mx, my, event.deltaY);
        }
      }
    }
  }

  zoomByWheel(mx, my, delta) {
    const zoomRatio = 1.1;
    var nz = 0;
    var xo = this.schemeContainer.screenTransform.x;
    var yo = this.schemeContainer.screenTransform.y;

    if (delta < 0) {
      nz = this.schemeContainer.screenTransform.scale * zoomRatio;
      const sx = mx - nz * (mx - xo) / this.schemeContainer.screenTransform.scale;
      const sy = my - nz * (my - yo) / this.schemeContainer.screenTransform.scale;
      this.schemeContainer.screenTransform.scale = nz;
      this.dragScreenTo(sx, sy);
    } else if (this.schemeContainer.screenTransform.scale > 0.05) {
      nz = this.schemeContainer.screenTransform.scale / zoomRatio;
      const sx = mx - nz * (mx - xo) / this.schemeContainer.screenTransform.scale;
      const sy = my - nz * (my - yo) / this.schemeContainer.screenTransform.scale;
      this.schemeContainer.screenTransform.scale = nz;
      this.dragScreenTo(sx, sy);
    }
  }

  zoomOutByKey() {
    this.changeZoomTo(this.schemeContainer.screenTransform.scale * 0.9);
  }

  zoomInByKey() {
    this.changeZoomTo(this.schemeContainer.screenTransform.scale * 1.1);
  }

  changeZoomTo(newScale) {
    // calculating old center of the scheme
    let schemeContainer = this.schemeContainer;
    const xo = schemeContainer.screenTransform.x;
    const yo = schemeContainer.screenTransform.y;
    const svgRect = document.getElementById('svg_plot').getBoundingClientRect();
    const cx = svgRect.width / 2;
    const cy = svgRect.height / 2;
    const sx = cx - newScale * (cx - xo) / schemeContainer.screenTransform.scale;
    const sy = cy - newScale * (cy - yo) / schemeContainer.screenTransform.scale;
    schemeContainer.screenTransform.scale = newScale;
    schemeContainer.screenTransform.x = sx;
    schemeContainer.screenTransform.y = sy;
    EventBus/* default.$emit */.Z.$emit(EventBus/* default.SCREEN_TRANSFORM_UPDATED */.Z.SCREEN_TRANSFORM_UPDATED, schemeContainer.screenTransform);
  }

  dragScreenOffset(dx, dy) {
    let sx = this.schemeContainer.screenTransform.x + dx;
    let sy = this.schemeContainer.screenTransform.y + dy;
    this.dragScreenTo(sx, sy);
  }
  /**
   * Changes screen offset coords and checks bounding box of all items in relative transform so that they are always visible on the screen
   * @param {*} sx 
   * @param {*} sy 
   */


  dragScreenTo(sx, sy) {
    // getting bounding box of items in relative transform
    const bbox = this.schemeContainer.screenSettings.boundingBox;
    const scale = this.schemeContainer.screenTransform.scale;
    const padding = 10; // we use padding to so that small part of the scheme stays visible and user does not get lost

    if (bbox) {
      const minScreenX = -(bbox.x + bbox.w) * scale + padding;
      const maxScreenX = this.schemeContainer.screenSettings.width - bbox.x * scale - padding;
      const minScreenY = -(bbox.y + bbox.h) * scale + padding;
      const maxScreenY = this.schemeContainer.screenSettings.height - bbox.y * scale - padding;
      this.schemeContainer.screenTransform.x = Math.max(minScreenX, Math.min(sx, maxScreenX));
      this.schemeContainer.screenTransform.y = Math.max(minScreenY, Math.min(sy, maxScreenY));
    } else {
      this.schemeContainer.screenTransform.x = sx;
      this.schemeContainer.screenTransform.y = sy;
    }

    this.eventBus.$emit(EventBus/* default.SCREEN_TRANSFORM_UPDATED */.Z.SCREEN_TRANSFORM_UPDATED, this.schemeContainer.screenTransform);
  }

  isSnappingToItemsEnabled() {
    return this.store.state.snap.items;
  }

  snapToGrid(value) {
    const snap = myMath/* default.getSnappingWidthForScale */.Z.getSnappingWidthForScale(this.schemeContainer.screenTransform.scale);

    if (this.store.state.snap.grid) {
      return Math.round(value / snap) * snap;
    }

    return value;
  }
  /**
   * Checks snapping of item and returns new offset that should be applied to item
   * 
   * @param {SnappingPoints} points - points of an item by which it should snap it to other items
   * @param {Set} excludeItemIds - items that should be excluded from snapping (so that they don't snap to themselve)
   * @param {Number} dx - pre-snap candidate offset on x axis
   * @param {Number} dy - pre-snap candidate offset on y axis
   * @returns {Offset} offset with dx and dy fields specifying how these points should be moved to be snapped
   */


  snapPoints(points, excludeItemIds, dx, dy) {
    if (!points) {
      return {
        dx,
        dy
      };
    }

    let snappedDx = dx;
    let snappedDy = dy; //TODO configure snapping precision

    const maxSnapProximity = 6;
    let zoomScale = this.schemeContainer.screenTransform.scale;
    let horizontalSnapper = null;
    let bestHorizontalProximity = 1000;
    let verticalSnapper = null;
    let bestVerticalProximity = 1000;

    if (this.isSnappingToItemsEnabled()) {
      forEach_default()(this.schemeContainer.relativeSnappers.horizontal, snapper => {
        if (!excludeItemIds.has(snapper.item.id)) {
          forEach_default()(points.horizontal, point => {
            let proximity = Math.abs(snapper.value - point.y - dy);

            if (proximity * zoomScale < maxSnapProximity && proximity < bestHorizontalProximity) {
              horizontalSnapper = {
                snapper,
                dy: snapper.value - point.y
              };
              bestHorizontalProximity = proximity;
            }
          });
        }
      });
      forEach_default()(this.schemeContainer.relativeSnappers.vertical, snapper => {
        if (!excludeItemIds.has(snapper.item.id)) {
          forEach_default()(points.vertical, point => {
            let proximity = Math.abs(snapper.value - point.x - dx);

            if (proximity * zoomScale < maxSnapProximity && proximity < bestVerticalProximity) {
              verticalSnapper = {
                snapper,
                dx: snapper.value - point.x
              };
              bestVerticalProximity = proximity;
            }
          });
        }
      });
    }

    if (horizontalSnapper) {
      store_StoreUtils.setItemSnapper(this.store, horizontalSnapper.snapper);
      snappedDy = horizontalSnapper.dy;
    } else if (this.store.state.snap.grid) {
      //snap to grid
      let bestGridProximity = 1000;
      forEach_default()(points.horizontal, point => {
        const snappedValue = this.snapToGrid(point.y + dy);
        const proximity = Math.abs(snappedValue - point.y);

        if (proximity < bestGridProximity) {
          bestGridProximity = proximity;
          snappedDy = snappedValue - point.y;
        }
      });
    }

    if (verticalSnapper) {
      store_StoreUtils.setItemSnapper(this.store, verticalSnapper.snapper);
      snappedDx = verticalSnapper.dx;
    } else if (this.store.state.snap.grid) {
      //snap to grid
      let bestGridProximity = 1000;
      forEach_default()(points.vertical, point => {
        const snappedValue = this.snapToGrid(point.x + dx);
        const proximity = Math.abs(snappedValue - point.x);

        if (proximity < bestGridProximity) {
          bestGridProximity = proximity;
          snappedDx = snappedValue - point.x;
        }
      });
    }

    return {
      dx: snappedDx,
      dy: snappedDy
    };
  }
  /**
   * Based on zoom it calculates a precision with which we should round the updated value
   * This is needed to avoid issues with floating values calculation so that users don't get uggly values with many digits after point.
   * 
   * @returns precision for which we should round the value
   */


  getUpdatePrecision() {
    const scale = this.schemeContainer.screenTransform.scale;

    if (scale < 0.5) {
      return 0;
    }

    return Math.max(0, Math.round(Math.log10(this.schemeContainer.screenTransform.scale * 100) - 1));
  }

  round(value) {
    return myMath/* default.roundPrecise */.Z.roundPrecise(value, this.getUpdatePrecision());
  }

}

class SubState extends (/* unused pure expression or super */ null && (State)) {
  constructor(parentState, name) {
    super(parentState.eventBus, parentState.store, name);
    this.schemeContainer = parentState.schemeContainer;
    this.parentState = parentState;
  }

  migrate(newSubState) {
    this.parentState.migrateSubState(newSubState);
  }

  migrateSubState(newSubState) {
    this.parentState.migrateSubState(newSubState);
  }

  migrateToPreviousSubState() {
    this.parentState.migrateToPreviousSubState();
  }

  cancel() {
    this.parentState.cancel();
  }

  getSchemeContainer() {
    return this.parentState.schemeContainer;
  }

}
class DragScreenState extends (/* unused pure expression or super */ null && (SubState)) {
  constructor(parentState, originalClickPoint) {
    super(parentState, 'drag-screen');
    this.schemeContainer = parentState.schemeContainer;
    this.originalClickPoint = originalClickPoint;
    this.originalScreenOffset = {
      x: this.schemeContainer.screenTransform.x,
      y: this.schemeContainer.screenTransform.y
    };
  }

  keyUp(key, keyOptions) {
    if (key === Keys.SPACE) {
      this.migrateToPreviousSubState();
    }
  }

  mouseDown(x, y, mx, my, object, event) {
    this.originalClickPoint = {
      x,
      y,
      mx,
      my
    };
    this.originalScreenOffset = {
      x: this.schemeContainer.screenTransform.x,
      y: this.schemeContainer.screenTransform.y
    };
  }

  mouseMove(x, y, mx, my, object, event) {
    if (event.buttons === 0) {
      this.mouseUp(x, y, mx, my, object, event);
      return;
    }

    if (this.originalClickPoint) {
      this.schemeContainer.screenTransform.x = Math.floor(this.originalScreenOffset.x + mx - this.originalClickPoint.mx);
      this.schemeContainer.screenTransform.y = Math.floor(this.originalScreenOffset.y + my - this.originalClickPoint.my);
    }
  }

  mouseUp(x, y, mx, my, object, event) {
    this.eventBus.$emit(this.eventBus.SCREEN_TRANSFORM_UPDATED);
    this.migrateToPreviousSubState();
  }

}
class MultiSelectState extends (/* unused pure expression or super */ null && (SubState)) {
  constructor(parentState, x, y, mx, my, selectorCallback) {
    super(parentState, 'multi-select');
    this.clickedObject = null;
    this.shouldSelectOnlyOne = false;
    this.multiSelectBox = {
      x,
      y,
      w: 0,
      h: 0
    };
    this.originalClickPoint = {
      x,
      y,
      mx,
      my
    };
    this.item = parentState.item;
    this.schemeContainer = parentState.schemeContainer;
    this.selectorCallback = selectorCallback;
  }

  mouseMove(x, y, mx, my, object, event) {
    if (event.buttons === 0) {
      this.mouseUp(x, y, mx, my, object, event);
      return;
    }

    if (x > this.originalClickPoint.x) {
      this.multiSelectBox.x = this.originalClickPoint.x;
      this.multiSelectBox.w = x - this.originalClickPoint.x;
    } else {
      this.multiSelectBox.x = x;
      this.multiSelectBox.w = this.originalClickPoint.x - x;
    }

    if (y > this.originalClickPoint.y) {
      this.multiSelectBox.y = this.originalClickPoint.y;
      this.multiSelectBox.h = y - this.originalClickPoint.y;
    } else {
      this.multiSelectBox.y = y;
      this.multiSelectBox.h = this.originalClickPoint.y - y;
    }

    StoreUtils.setMultiSelectBox(this.store, this.multiSelectBox);
  }

  mouseUp(x, y, mx, my, object, event) {
    this.selectorCallback(this.multiSelectBox, isMultiSelectKey(event));
    StoreUtils.setMultiSelectBox(this.store, null);
    this.migrateToPreviousSubState();
  }

}
/* harmony default export */ const states_State = (State);
;// CONCATENATED MODULE: ./src/ui/components/editor/states/StateInteract.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */






const MOUSE_IN = Events/* default.standardEvents.mousein.id */.Z.standardEvents.mousein.id;
const MOUSE_OUT = Events/* default.standardEvents.mouseout.id */.Z.standardEvents.mouseout.id;
const CLICKED = Events/* default.standardEvents.clicked.id */.Z.standardEvents.clicked.id;
/*
This state works as dragging the screen, zooming, selecting elements
*/

class StateInteract extends states_State {
  /**
   * 
   * @param {EventBus} EventBus 
   * @param {UserEventBus} userEventBus 
   */
  constructor(eventBus, store, userEventBus) {
    super(eventBus, store);
    this.name = 'interact';
    this.startedDragging = false;
    this.initialClickPoint = null;
    this.originalOffset = {
      x: 0,
      y: 0
    };
    this.originalZoom = 1.0; // used in order to track whether mousein or mouseout event can be produced

    this.currentHoveredItem = null;
    this.hoveredItemIds = new Set();
    this.userEventBus = userEventBus;
  }

  softReset() {
    this.initialClickPoint = null;
    this.startedDragging = false;
  }

  reset() {
    this.softReset();
    this.hoveredItemIds = new Set();
  }

  mouseDown(x, y, mx, my, object, event) {
    this.initScreenDrag(mx, my);
  }

  initScreenDrag(x, y) {
    this.startedDragging = true;
    this.initialClickPoint = {
      x,
      y
    };
    this.originalOffset = {
      x: this.schemeContainer.screenTransform.x,
      y: this.schemeContainer.screenTransform.y
    };
    this.originalZoom = this.schemeContainer.screenTransform.scale;
  }

  keyPressed(key, keyOptions) {
    if (key === events/* Keys.MINUS */.R.MINUS) {
      this.zoomOutByKey();
    } else if (key === events/* Keys.EQUALS */.R.EQUALS) {
      this.zoomInByKey();
    }
  }

  mouseUp(x, y, mx, my, object, event) {
    if (this.startedDragging && this.initialClickPoint) {
      if (Math.abs(mx - this.initialClickPoint.x) + Math.abs(my - this.initialClickPoint.y) < 3) {
        if (object && object.item) {
          this.eventBus.$emit(EventBus/* default.ANY_ITEM_CLICKED */.Z.ANY_ITEM_CLICKED, object.item);
          this.emit(object.item, CLICKED);
          this.handleItemClick(object.item, mx, my);
        } else {
          // checking whether user clicked on the item link or not
          // if it was item link - then we don't want to remove them from DOM
          if (!event.target || !event.target.closest('.item-link')) {
            this.eventBus.$emit(EventBus/* default.VOID_CLICKED */.Z.VOID_CLICKED);
          }
        }
      }

      this.softReset();
    }
  }

  mouseMove(x, y, mx, my, object, event) {
    if (this.startedDragging && this.initialClickPoint) {
      event.preventDefault();

      if (event.buttons === 0) {
        // this means that no buttons are actually pressed, so probably user accidentally moved mouse out of view and released it, or simply clicked right button
        this.softReset();
      } else {
        this.dragScreen(mx, my);
      }
    } else {
      this.handleItemHoverEvents(object);
    }
  }

  handleItemClick(item, mx, my) {
    if (item.links && item.links.length > 0) {
      this.eventBus.$emit(EventBus/* default.ITEM_LINKS_SHOW_REQUESTED */.Z.ITEM_LINKS_SHOW_REQUESTED, item);
    }

    if ((0,Item/* hasItemDescription */.U3)(item)) {
      if (item.interactionMode === Item/* ItemInteractionMode.SIDE_PANEL */.pp.SIDE_PANEL) {
        this.eventBus.$emit(EventBus/* default.ITEM_SIDE_PANEL_TRIGGERED */.Z.ITEM_SIDE_PANEL_TRIGGERED, item);
      } else if (item.interactionMode === Item/* ItemInteractionMode.TOOLTIP */.pp.TOOLTIP) {
        this.eventBus.$emit(EventBus/* default.ITEM_TOOLTIP_TRIGGERED */.Z.ITEM_TOOLTIP_TRIGGERED, item, mx, my);
      }
    }
  }

  sendItemEventById(itemId, event) {
    const item = this.schemeContainer.findItemById(itemId);

    if (item) {
      this.emit(item, event);
    }
  }

  handleItemHoverEvents(object) {
    if (object && object.type === 'item' && object.item) {
      if (!this.currentHoveredItem) {
        if (object.item.meta && Array.isArray(object.item.meta.ancestorIds)) {
          this.hoveredItemIds = new Set(object.item.meta.ancestorIds.concat([object.item.id]));
          object.item.meta.ancestorIds.forEach(itemId => {
            this.sendItemEventById(itemId, MOUSE_IN);
          });
        } else {
          this.hoveredItemIds = new Set([object.item.id]);
        }

        this.emit(object.item, MOUSE_IN);
        this.currentHoveredItem = object.item;
      } else if (this.currentHoveredItem.id !== object.item.id) {
        let allNewIds = new Set();

        if (object.item.meta && Array.isArray(object.item.meta.ancestorIds)) {
          allNewIds = new Set(object.item.meta.ancestorIds);
        }

        allNewIds.add(object.item.id);
        this.hoveredItemIds.forEach(itemId => {
          if (!allNewIds.has(itemId)) {
            this.hoveredItemIds.delete(itemId);
            this.sendItemEventById(itemId, MOUSE_OUT);
          }
        });
        allNewIds.forEach(itemId => {
          if (!this.hoveredItemIds.has(itemId)) {
            this.hoveredItemIds.add(itemId);
            this.sendItemEventById(itemId, MOUSE_IN);
          }
        });
        this.currentHoveredItem = object.item;
      }
    } else {
      this.hoveredItemIds.forEach(itemId => {
        this.sendItemEventById(itemId, MOUSE_OUT);
      });
      this.hoveredItemIds.clear();
      this.currentHoveredItem = null;
    }
  }

  emit(element, eventName) {
    if (element && element.id) {
      this.userEventBus.emitItemEvent(element.id, eventName);
    }
  }

  dragScreen(x, y) {
    if (!this.schemeContainer.scheme.settings.screen.draggable) {
      return;
    }

    this.dragScreenTo(Math.floor(this.originalOffset.x + x - this.initialClickPoint.x), Math.floor(this.originalOffset.y + y - this.initialClickPoint.y));
  }

}

/* harmony default export */ const states_StateInteract = (StateInteract);
// EXTERNAL MODULE: ./node_modules/axios/index.js
var axios = __webpack_require__(9669);
var axios_default = /*#__PURE__*/__webpack_require__.n(axios);
;// CONCATENATED MODULE: ./src/ui/components/editor/items/shapes/ExtraShapes.js
function ExtraShapes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function ExtraShapes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ExtraShapes_ownKeys(Object(source), true).forEach(function (key) { ExtraShapes_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ExtraShapes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function ExtraShapes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function generateShapeId(shapeGroupId, shapeDef) {
  return `ext:${shapeDef.shapeConfig.id}:${shapeGroupId}`;
}
function registerExternalShapeGroup($store, shapeGroupId, shapeGroup) {
  //TODO validate shapeGroup JSON schema
  if (typeof shapeGroup !== 'object' || !Array.isArray(shapeGroup.shapes)) {
    throw new Error(`Invalid shape group in ${url}`);
  }

  const menuItems = [];
  shapeGroup.shapes.forEach(shapeDef => {
    const shapeId = generateShapeId(shapeGroupId, shapeDef);
    Shape/* default.registerRawShape */.Z.registerRawShape(shapeId, shapeDef.shapeConfig);

    if (Array.isArray(shapeDef.shapeConfig.menuItems)) {
      shapeDef.shapeConfig.menuItems.forEach(menuItem => {
        menuItems.push(ExtraShapes_objectSpread({
          id: shapeId
        }, menuItem));
      });
    }
  });
  store_StoreUtils.registerShapeGroupId($store, shapeGroupId);
}

function collectMissingShapes(items) {
  const missingShapes = new Set();

  if (Array.isArray(items)) {
    items.forEach(rootItem => {
      (0,Item/* traverseItems */.Hp)(rootItem, item => {
        if (item.shape && !Shape/* default.find */.Z.find(item.shape)) {
          missingShapes.add(item.shape);
        }
      });
    });
  }

  return Array.from(missingShapes);
}

function loadAllMissingShapes(shapeIds, $store) {
  const shapeGroupIds = new Set();
  shapeIds.forEach(shapeId => {
    const parts = shapeId.split(':');

    if (parts.length === 3) {
      shapeGroupIds.add(parts[2]);
    }
  });

  if (shapeGroupIds.size === 0) {
    return Promise.resolve(null);
  }

  const assetsPath = $store.state.assetsPath || '/assets';
  const separator = assetsPath.endsWith('/') ? '' : '/';
  return axios_default().get(`${assetsPath}${separator}shapes/shapes.json`).then(response => {
    const shapeGroups = response.data;

    if (!shapeGroups) {
      return null;
    }

    const shapeGroupIndex = new Map();
    shapeGroups.forEach(shapeGroup => {
      shapeGroupIndex.set(shapeGroup.id, shapeGroup);
    });
    return Promise.all(Array.from(shapeGroupIds).map(shapeGroupId => {
      const shapeGroup = shapeGroupIndex.get(shapeGroupId);

      if (!shapeGroup) {
        return Promise.resolve(null);
      }

      return axios_default().get(shapeGroup.ref).then(response => {
        registerExternalShapeGroup($store, shapeGroupId, response.data);
        EventBus/* default.$emit */.Z.$emit(EventBus/* default.EXTRA_SHAPE_GROUP_REGISTERED */.Z.EXTRA_SHAPE_GROUP_REGISTERED);
      });
    }));
  });
}

function collectAndLoadAllMissingShapes(items, $store) {
  const missingShapes = collectMissingShapes(items);

  if (missingShapes && missingShapes.length > 0) {
    return loadAllMissingShapes(missingShapes, $store);
  }

  return Promise.resolve();
}
;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./node_modules/vue-loader/lib/index.js??vue-loader-options!./src/ui/views/StandaloneSchemeView.vue?vue&type=script&lang=js&
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//










const userEventBus = new UserEventBus();
const stateInteract = new states_StateInteract(EventBus/* default */.Z, store_Store, userEventBus);
/* harmony default export */ const StandaloneSchemeViewvue_type_script_lang_js_ = ({
  props: ['scheme', 'offsetX', 'offsetY', 'zoom', 'autoZoom', 'sidePanelWidth', 'useMouseWheel', 'homeLink'],
  components: {
    SvgEditor: SvgEditor,
    ItemTooltip: ItemTooltip,
    ItemDetails: ItemDetails
  },

  beforeMount() {
    this.$store.dispatch('setAssetsPath', '/');
    this.initSchemeContainer();
    EventBus/* default.$on */.Z.$on(EventBus/* default.SCREEN_TRANSFORM_UPDATED */.Z.SCREEN_TRANSFORM_UPDATED, this.onScreenTransformUpdated);
    EventBus/* default.$on */.Z.$on(EventBus/* default.ITEM_TOOLTIP_TRIGGERED */.Z.ITEM_TOOLTIP_TRIGGERED, this.onItemTooltipTriggered);
    EventBus/* default.$on */.Z.$on(EventBus/* default.ITEM_SIDE_PANEL_TRIGGERED */.Z.ITEM_SIDE_PANEL_TRIGGERED, this.onItemSidePanelTriggered);
    EventBus/* default.$on */.Z.$on(EventBus/* default.VOID_CLICKED */.Z.VOID_CLICKED, this.onVoidClicked);
  },

  beforeDestroy() {
    EventBus/* default.$off */.Z.$off(EventBus/* default.SCREEN_TRANSFORM_UPDATED */.Z.SCREEN_TRANSFORM_UPDATED, this.onScreenTransformUpdated);
    EventBus/* default.$off */.Z.$off(EventBus/* default.ITEM_TOOLTIP_TRIGGERED */.Z.ITEM_TOOLTIP_TRIGGERED, this.onItemTooltipTriggered);
    EventBus/* default.$off */.Z.$off(EventBus/* default.ITEM_SIDE_PANEL_TRIGGERED */.Z.ITEM_SIDE_PANEL_TRIGGERED, this.onItemSidePanelTriggered);
    EventBus/* default.$off */.Z.$off(EventBus/* default.VOID_CLICKED */.Z.VOID_CLICKED, this.onVoidClicked);
  },

  data() {
    return {
      schemeContainer: null,
      initialized: false,
      userEventBus,
      textZoom: "" + this.zoom,
      vZoom: this.zoom,
      itemTooltip: {
        item: null,
        shown: false,
        x: 0,
        y: 0
      },
      sidePanel: {
        item: null
      }
    };
  },

  methods: {
    initSchemeContainer() {
      collectAndLoadAllMissingShapes(this.scheme.items, this.$store).catch(err => {
        console.error('Failed to load shapes', err);
      }).then(() => {
        this.schemeContainer = new SchemeContainer/* default */.ZP(this.scheme, EventBus/* default */.Z);
        stateInteract.schemeContainer = this.schemeContainer;
        stateInteract.reset();
        this.initialized = true;

        if (this.autoZoom) {
          this.zoomToScheme();
        }
      });
    },

    mouseWheel(x, y, mx, my, event) {
      if (this.initialized) {
        stateInteract.mouseWheel(x, y, mx, my, event);
      }
    },

    mouseDown(worldX, worldY, screenX, screenY, object, event) {
      if (this.initialized) {
        stateInteract.mouseDown(worldX, worldY, screenX, screenY, object, event);
      }
    },

    mouseUp(worldX, worldY, screenX, screenY, object, event) {
      if (this.initialized) {
        stateInteract.mouseUp(worldX, worldY, screenX, screenY, object, event);
      }
    },

    mouseMove(worldX, worldY, screenX, screenY, object, event) {
      if (this.initialized) {
        stateInteract.mouseMove(worldX, worldY, screenX, screenY, object, event);
      }
    },

    mouseDoubleClick(worldX, worldY, screenX, screenY, object, event) {
      if (this.initialized) {
        stateInteract.mouseDoubleClick(worldX, worldY, screenX, screenY, object, event);
      }
    },

    onScreenTransformUpdated(screenTransform) {
      this.textZoom = '' + Math.round(screenTransform.scale * 10000) / 100;
    },

    onItemTooltipTriggered(item, mouseX, mouseY) {
      this.itemTooltip.item = item;
      this.itemTooltip.x = mouseX;
      this.itemTooltip.y = mouseY;
      this.itemTooltip.shown = true;
    },

    onItemSidePanelTriggered(item) {
      this.sidePanel.item = item;
    },

    onZoomSubmitted() {
      this.vZoom = parseFloat(this.textZoom);

      if (this.initialized) {
        this.schemeContainer.screenTransform.scale = this.vZoom / 100.0;
      }
    },

    onVoidClicked() {
      this.sidePanel.item = null;
    },

    zoomToScheme() {
      this.zoomToItems(this.schemeContainer.getItems());
    },

    zoomToItems(items) {
      if (items && items.length > 0) {
        const area = this.getBoundingBoxOfItems(items);

        if (area) {
          EventBus/* default.emitBringToViewInstantly */.Z.emitBringToViewInstantly(area);
        }
      }
    },

    getBoundingBoxOfItems(items) {
      let area = null;
      forEach_default()(items, item => {
        if (!area) {
          area = {
            x: item.area.x,
            y: item.area.y,
            w: item.area.w,
            h: item.area.h
          };
        } else {
          if (area.x > item.area.x) {
            area.x = item.area.x;
          }

          if (area.y > item.area.y) {
            area.y = item.area.y;
          }

          if (area.x + area.w < item.area.x + item.area.w) {
            area.w = item.area.x + item.area.w - area.x;
          }

          if (area.y + area.h < item.area.y + item.area.h) {
            area.h = item.area.y + item.area.h - area.y;
          }
        }
      });
      return area;
    }

  }
});
;// CONCATENATED MODULE: ./src/ui/views/StandaloneSchemeView.vue?vue&type=script&lang=js&
 /* harmony default export */ const views_StandaloneSchemeViewvue_type_script_lang_js_ = (StandaloneSchemeViewvue_type_script_lang_js_); 
;// CONCATENATED MODULE: ./src/ui/views/StandaloneSchemeView.vue





/* normalize component */
;
var StandaloneSchemeView_component = (0,componentNormalizer/* default */.Z)(
  views_StandaloneSchemeViewvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* hot reload */
if (false) { var StandaloneSchemeView_api; }
StandaloneSchemeView_component.options.__file = "src/ui/views/StandaloneSchemeView.vue"
/* harmony default export */ const StandaloneSchemeView = (StandaloneSchemeView_component.exports);
;// CONCATENATED MODULE: ./src/ui/standalone-viewer.js
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */




function objProperty(obj, field, defaultValue) {
  if (obj && obj.hasOwnProperty(field)) {
    return obj[field];
  }

  return defaultValue;
}

window.schemioViewScheme = (elementOrSelector, scheme, opts) => {
  const options = opts || {};
  new (vue_default())({
    components: {
      StandaloneSchemeView: StandaloneSchemeView
    },
    store: store_Store,

    data() {
      return {
        scheme,
        offsetX: parseInt(options.offsetX) || 0,
        offsetY: parseInt(options.offsetY) || 0,
        zoom: Math.max(0.00005, parseFloat(options.zoom) || 100),
        autoZoom: objProperty(options, 'autoZoom', true),
        sidePanelWidth: parseInt(options.sidePanelWidth) || 400,
        useMouseWheel: objProperty(options, 'useMouseWheel', false),
        homeLink: 'https://github.com/ishubin/schemio'
      };
    },

    template: '<standalone-scheme-view :scheme="scheme" :offset-x="offsetX" :offset-y="offsetY" :zoom="zoom" :auto-zoom="autoZoom" :home-link="homeLink" :side-panel-width="sidePanelWidth" :use-mouse-wheel="useMouseWheel"/>'
  }).$mount(elementOrSelector);
};
})();

/******/ })()
;